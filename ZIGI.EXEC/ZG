  /* --------------------  rexx procedure  -------------------- *
  | Name:      zg                                              |
  |                                                            |
  | Function:  Add the selected dataset or member to git       |
  |            with optional commit and push.                  |
  |                                                            |
  |            1st time ask for repo name, then remember it    |
  |            based on the z/OS dataset name.                 |
  |                                                            |
  |            Works best when used on an enhanced ISPF        |
  |            member list row.                                |
  |                                                            |
  | Syntax:    %zg dsname(member) opt                          |
  |                                                            |
  |            Only PDS members allowed                        |
  |                                                            |
  |            opt values:                                     |
  |            A    Git Add                                    |
  |            AC   Git Add and Commit                         |
  |            ACP  Git Add, Commit, and Push                  |
  |            blank - prompt via popup                        |
  |            Anything else force prompt for repo             |
  |                                                            |
  | Usage Notes: Requires that zigi has been configured        |
  |              with the local repositories                   |
  |                                                            |
  |              Assumes that the member has been updated      |
  |              as it will be copied to the OMVS repoistory   |
  |              and then Commited and Push if requested.      |
  |                                                            |
  |              A popup for a short Commit message will       |
  |              be generated on Commit.                       |
  |                                                            |
  | Notes:                                                     |
  |           1. All ISPF Panels are inline and dynamically    |
  |              loaded for use by the LOADISPF routine.       |
  |           2. Must be installed into a default SYSEXEC or   |
  |              SYSPROC library for use.                      |
  |           3. For the option to open zigi to work the       |
  |              zigi stub should be installed as in (2).      |
  |                                                            |
  | Author:    Lionel B. Dyck                                  |
  |                                                            |
  | Contributors:                                              |
  |           MRM - Ray Mullins                                |
  |                                                            |
  | History:  (most recent on top)                             |
  |            12/27/24 MRM - Add blank line at top to pop-ups |
  |            09/28/24 LBD - Support 8 Char TSO Userid        |
  |            05/04/24 LBD - Fix binary find in .gitattributes|
  |            11/05/23 LBD - Fix if log off                   |
  |            06/15/23 LBD - Add env ICONV_EBCDIC_ZOS_UNIX=1  |
  |            09/16/22 LBD - Fix view_std lrecl               |
  |            05/16/22 LBD - Correct bad iterate              |
  |            04/16/22 LBD - Support log option               |
  |            04/14/22 LBD - Honor default userid for repo    |
  |            04/12/22 LBD - Support binary elements          |
  |            04/11/22 LBD - Use CoZ if available for stats   |
  |                         - use current zigistat             |
  |                         - Add tutorial for options         |
  |            04/10/22 LBD - correct tagging on new members   |
  |            03/23/22 MWB - correct tagging on new members   |
  |            03/23/22 MWB - fix to include ~/.profile setup  |
  |            06/03/21 LBD - Change SHAREAS to REQUIRED       |
  |            05/29/21 LBD - Improve env setup                |
  |            05/06/21 LBD - Support allmems > 32k            |
  |            10/25/20 LBD - Improve usssafe routine          |
  |            08/07/20 LBD - Add PFSHOW Off/Reset all Pops    |
  |            07/29/20 LBD - Add _EDC_ZERO_RECLEN=Y to env.   |
  |            07/12/20 LBD - Correct TBOpen remove NOWRITE    |
  |            04/05/20 LBD - Expand Commit message to 7 lines |
  |            04/04/20 LBD - Place all ISPF panels inline     |
  |                           to avoid customization req       |
  |            04/01/20 LBD - Add dsn to repo mapping variable |
  |            03/31/20 LBD - Rework to enhance                |
  |            03/29/20 LBD - Finally working                  |
  |            03/09/20 LBD - Creation                         |
  |                                                            |
  | ---------------------------------------------------------- |
  |    zigi - the z/OS ISPF Git Interface                      |
  |    Copyright (C) 2020-2024 - Henri Kuiper and Lionel Dyck  |
  |                                                            |
  |    This program is free software: you can redistribute it  |
  |    and/or modify it under the terms of the GNU General     |
  |    Public License as published by the Free Software        |
  |    Foundation, either version 3 of the License, or (at     |
  |    your option) any later version.                         |
  |                                                            |
  |    This program is distributed in the hope that it will be |
  |    useful, but WITHOUT ANY WARRANTY; without even the      |
  |    implied warranty of MERCHANTABILITY or FITNESS FOR A    |
  |    PARTICULAR PURPOSE.  See the GNU General Public License |
  |    for more details.                                       |
  |                                                            |
  |    You should have received a copy of the GNU General      |
  |    Public License along with this program.  If not, see    |
  |    <https://www.gnu.org/licenses/>.                        |
  * ---------------------------------------------------------- */
  arg adddsn opt

  Address ISPExec

  parse value '' with null hit repo open

  /* ------------------------------------------------- *
  | Validate the input prior to proceeding.           |
  |                                                   |
  | ADDDSN must be a pds with a member name provided. |
  | Opt if non-blank will for repository selection.   |
  * ------------------------------------------------- */
  parse source s1 s2 command s4 .

  if adddsn = '?' then adddsn = null
  if adddsn = null then do
    zedsmsg = null
    zedlmsg = left('zigi Git Command - quick add/commit/push',75) ,
      left('-',75) ,
      left(command 'syntax is:',75) ,
      left('zg dataset(member)',75) ,
      left('or zg dataset(member) opt',75) ,
      left('Where opt is X to force a prompt for a repository,',75) ,
      'or the selection option of A, AC, or ACP.'
    'setmsg msg(isrz001)'
    exit 8
  end
  x = listdsi(adddsn)
  if x > 0 then do
    zedsmsg = null
    zedlmsg = left('zigi Git Command - quick add/commit/push',75) ,
      left('-',75) ,
      left('Input dataset name failure:' adddsn,75),
      sysmsglvl2
    'setmsg msg(isrz001)'
    exit 8
  end
  if pos('(',adddsn) = 0 then do
    zedsmsg = null
    zedlmsg = left('zigi Git Command - quick add/commit/push',75) ,
      left('-',75) ,
      left(command 'syntax is:',75) ,
      left('zg dataset(member)',75) ,
      left('or zg dataset(member) opt',75) ,
      left('Where opt is X to force a prompt for a repository,',75) ,
      'or the selection option of A, AC, or ACP.'
    'setmsg msg(isrz001)'
    exit 8
  end

  'control errors return'

  /* --------------------------------------------- *
  | Recurse into the zigi applid. This makes it   |
  | easier to work with the ISPF Profile variable |
  | with the dsnames and repository names.        |
  * --------------------------------------------- */
  'vget (zapplid)'
  if zapplid /= 'ZIGI' then do
    'Select cmd(%'command adddsn opt') newappl(zigi) passlib'
    exit
  end

  /* ----------------------- *
  | Load inline ISPF Panels |
  * ----------------------- */
  load_info = loadispf()

  /* ------------ *
  | Clean up Opt |
  * ------------ */
  opt = translate(opt,'A','S')

  /* ----------------------------------------------------- *
  | parse the input dsn for dsn and member with no quotes |
  * ----------------------------------------------------- */
  workdsn = strip(adddsn,'B',"'")
  parse value workdsn with dsname'('member')'

  /* -------------------------- *
  | Validate the input options |
  * -------------------------- */
  zsel = opt
  'vget (zgdsns zglogo) profile'

  if wordpos(opt,'A AC ACP O') = 0 then
  if opt /= null then do
    wp = wordpos(dsname,zgdsns)
    if wp = 0 then opt = null   /* dsn not found */
    zgdsns = delword(zgdsns,wp,2)
    'vput (zgdsns) profile'
    parse value '' with zsel opt
  end
  wp = wordpos(dsname,zgdsns)
  if wp > 0 then
  repo = word(zgdsns,wp+1)
  if repo /= null then
  if opt = null then do
    call pfshow 'off'           /* make sure pfshow is off */
    'Addpop row(4) column(4)'
    'display panel(zgopt)'
    drc = rc
    'rempop'
    call pfshow 'reset'         /* restore pfshow setting */
    if drc > 0 then do
      zedsmsg = 'Canceled.'
      zedlmsg = 'zigi Add canceled.'
      'setmsg msg(isrz001)'
      call get_out_of_here
    end
    zsel = opt
  end

  /* ---------------- *
   | Check log option |
   * ---------------- */
   'vput (zglogo) profile'
   if zglogo = 'Y' then do
      logc = 0
      log. = null
      end

  /* ------------------- *
  | Open the zigi table |
  * ------------------- */
  call pop 'Opening zigi Repository Table \ Patience.'
  isptabl = 'ISPTABL'
  x = listdsi(isptabl 'FILE')
  if x > 0 then isptabl = 'ISPPROF'
  'TBOpen zigirepo Library('isptabl') Share'
  if rc > 8 then do
    zedsmsg = 'Error.'
    zedlmsg = 'Unable to open the zigi Local Repository table.' ,
      'Contact your zigi support individual.'
    'setmsg msg(isrz001)'
    call get_out_of_here
  end
  open = 1

  call pop 'Looking for current dataset \ in the Repository.'
  'tbtop zigirepo'
  if repo /= null then do forever
    if repo = zigirep then leave
    'tbskip zigirepo'
    if rc > 0 then do
      repo = null
      leave
    end
  end

  /* --------------------------------------- *
  | Display repository table to select from |
  * --------------------------------------- */
  if repo = null then
  do forever
    zsel = null
    call pfshow 'off'           /* make sure pfshow is off */
    'addpop'
    'tbdispl zigirepo panel(zgtbl)'
    drc = rc
    'rempop'
    call pfshow 'reset'         /* restore pfshow setting */
    if zsel /= null then leave
    if drc > 0 then do
      zsel = null
      call done
    end
  end

  /* ----------------------------- *
  | Get the OMVS environment info |
  * ----------------------------- */
  call getenv

  /* ---------------------------- *
   | Check for the Co:Z utilities |
   * ---------------------------- */
  call Check_for_CoZ

  /* ------------------------------------------------- *
  | Validate that the current dataset is part of repo |
  * ------------------------------------------------- */
  if pos('(',workdsn) > 0 then
  parse value workdsn with workdsn'('member')'
  else member = null
  omvsdsn = remove_dsn_hlq(workdsn)
  cmd = 'cd' localrep'/'zigirep
  cmd = cmd '&& ls' usssafe(omvsdsn)
  x = bpxwunix(cmd,,xo.,xe.)
  if x > 0 then do
    zedsmsg = 'Invalid.'
    zedlmsg = left('The requested dataset' adddsn ,76) ,
      left('is not part of the selected repository:' zigirep,76) ,
      'as such this command is terminating. Please try again.'
    'setmsg msg(isrz001)'
    if wordpos(workdsn,zgdsns) > 0 then do
      wp = wordpos(workdsn,zgdsns)
      zgdsns = delword(zgdsns,wp,wp+1)
      'vput (zgdsns) profile'
    end
    call done
  end
  drop xo. xe.

  if wordpos(workdsn,zgdsns) = 0 then do
    zgdsns = zgdsns workdsn zigirep
    'vput (zgdsns) profile'
  end

  /* --------------------------------------------------- *
  | Get the list of binary files                        |
  | Get the list of datasets to check for file suffixes |
  * --------------------------------------------------- */
  call get_dsn_info
  call get_binfiles

  /* -------------------------------- *
  | Process the repository selection |
  * -------------------------------- */

  /* ------------------------------------------------------- *
  | Select/Add dataset or dataset(member) to the repository |
  | - copy from z/OS to OMVS                                |
  | - git add it                                            |
  | Copy occurs with the Open request or the select/add.    |
  * ------------------------------------------------------- */
  call pop 'Copying the member to OMVS \ Patience. . .'
  if pos(left(zsel,1),'A') > 0 then do
    omvsfs = localrep"/"zigirep
    call Get_Default_Codepage
    hit = 1
    omvsfile = omvsdsn
    ofile = usssafe(omvsfile)
    omem  = usssafe(member)
    if zdsn.omvsdsn = null
    then rmem = omem
    else rmem = lower(omem)'.'zdsn.omvsdsn
    x = is_binfile(ofile'/'rmem)
    if x = 0
       then do
       binopt = null
       tagcmd = 'chtag -tc' encoding localrep'/'zigirep'/'ofile'/'rmem
       end
       else do
       binopt = '-B'
       tagcmd = 'chtag -b 'localrep'/'zigirep'/'ofile'/'rmem
       end
    sdsn = usssafe(dsname)
    copycmd = "//'"sdsn"("omem")'"
    copycmd = '"'copycmd'"'
    copycmd = "cp -U -v" binopt copycmd" "localrep"/"zigirep'/'ofile'/'rmem ,
       '&&' tagcmd
    x = bpxwunix(copycmd,,so.,se.)
  if zglogo = 'Y' then do
     call do_zglog 'Copy element to the repository and tag it'
     call do_zglog copycmd
     do zi = 1 to so.0
        logc = logc + 1
        log.logc = so.zi
        end
     do zi = 1 to se.0
        logc = logc + 1
        log.logc = se.zi
        end
     end
    call add_so 'Command:' copycmd
    if x > 0 then
    call view_std 'B'
    call pop 'Adding to Git Index \ Patience. . .'
    call git_add_member_stats
    call do_zglog 'Update ISPF statistics file'
    cmd = 'cd' localrep'/'zigirep'/'ofile ,
          '&& git add . && git status' ,
          'cd' localrep'/'zigirep'/.zigi' ,
          '&& git add . && git status'
    x = docmd(cmd)
    if zglogo = 'Y' then do
       call do_zglog 'Git Add both the element and the ISPF stats file'
       call do_zglog cmd
       do zi = 1 to so.0
          logc = logc + 1
          log.logc = so.zi
          end
       do zi = 1 to se.0
          logc = logc + 1
          log.logc = se.zi
          end
       end
    call add_so 'Command:' cmd
    if x > 0 then
    call view_std 'B'
  end

  /* ----------------------------------------- *
  | Perform Commit Processing (optional Push) |
  * ----------------------------------------- */
  if pos('C',zsel) > 0 then do
    call pfshow 'off'           /* make sure pfshow is off */
    'Addpop row(4) column(4)'
    'Display Panel(zgcom)'
    drc = rc
    'Rempop'
    call pfshow 'reset'         /* restore pfshow setting */
    if drc > 0 then call done
    if strip(cmsg1 cmsg2 cmsg3 cmsg4 cmsg5 cmsg6 cmsg7) /= null
    then do
      cfile = 1
      call do_cmsg
    end
    else cfile = 0
    hit = 1
    if pos('P',zsel) > 0
    then  call pop 'Performing Git Commit/Push \ Patience. . .'
    else  call pop 'Performing Git Commit \ Patience. . .'
    cmd = 'cd' localrep'/'zigirep
    if cfile =0 then
    cmd = cmd "&& git commit -vm '"cmsg1"'"
    else do
      cmd = cmd "&& git commit -F" file
    end
    if right(zsel,1) = 'P' then do
       cmd = cmd '&& git push -v'
       pmsg = 'and Git Push'
       end
    if cfile = 1 then
    cmd = cmd '&& rm' file
    x = docmd(cmd)
    if zglogo = 'Y' then do
       msg = 'Do Git Commit' pmsg
       call do_zglog 'Do commit and optional push'
       call do_zglog cmd
       do zi = 1 to so.0
          logc = logc + 1
          log.logc = so.zi
          end
       do zi = 1 to se.0
          logc = logc + 1
          log.logc = se.zi
          end
       end
    call add_so 'Command:' cmd
    if x > 0 then
    call view_std 'B'
    call done
  end

  /* ------------------------------------------------------------- *
  | Call zigi to open the repository. Use newappl of ISR to force |
  | zigi to altlib/libdef it's libraries.                         |
  * ------------------------------------------------------------- */
  if zsel = 'O' then do
    open = 0
    zigi_repo = zigirep
    'tbend zigirepo'
    Address ISPExec 'Select cmd(%zigi' zigi_repo') newappl(isr)'
    hit = 0
  end

  /* ---------------- *
  | Done so clean up |
  * ---------------- */
done:
  if hit = 1 then do
    zigidate = date('n')
    sortdate = date('b')''right(time('s')+100000,5)
    'tbmod zigirepo order'
    cmd = 'cd' localrep'/'zigirep
    cmd = cmd '&& git status && git log --cc -m -n 1'
    x = docmd(cmd)
    if zglogo = 'Y' then do
       call do_zglog 'Finished so report out'
       call do_zglog cmd
       do zi = 1 to so.0
          logc = logc + 1
          log.logc = so.zi
          end
       do zi = 1 to se.0
          logc = logc + 1
          log.logc = se.zi
          end
       log.0 = logc
       do zi = 1 to log.0
          so.zi = log.zi
          so.0 = zi
          end
       call view_std
       x = 0
       end
    if x > 0
    then call view_std 'B'
    else do
      zedsmsg = 'Done.'
      msg = null
      if pos('A',zsel) > 0 then msg = msg 'Git Add complete'
      if pos('C',zsel) > 0 then
      if msg = null then msg = 'Git Commit complete'
      else msg = msg', and Git Commit complete'
      if pos('P',zsel) > 0 then
      if msg = null then msg = 'Git Push complete'
      else msg = msg', and Git Push complete'
      if zsel = 'A' then msg = msg', and a Commit/Push should be planned.'
      if zsel = 'AC' then msg = msg', and a Push should be planned.'
      zedlmsg = msg
      'setmsg msg(isrz001)'
    end
  end

Get_Out_Of_Here:
  if open /= 0 then do
    'tbend zigirepo'
  end
  x = dropispf(load_info)
  exit 0

Do_zglog:
  if zglogo /= 'Y' then return
  parse arg log_text
  logc = logc + 1
  log.logc = ' '
  logc = logc + 1
  log.logc = log_text
  logc = logc + 1
  log.logc = ' '
  return

  /* ---------------------- *
   | ISPF Stat Userid Setup |
   * ---------------------- */
zlmmuser: procedure
   arg uid
   if length(uid) > 7
      then return 'user8('uid')'
      else return 'user('uid')'

  /* ----------------------- *
  | Generalized Pop Message |
  | with msg passed         |
  * ----------------------- */
Pop:
  parse arg zs1 '\' zs2
  add = address()             /* save addressing environment */
  Address ISPExec
  call do_popup
  Address add                 /* restore addressing environment */
  return

  /* ------------------------------------------------------ *
  | The pfshow routine will:                               |
  | 1. check to see the passed option                      |
  | 2. if Off then it will save the current pfshow setting |
  |    - save the current setting                          |
  |    - turn off pfshow                                   |
  | 3. if the option is Reset then it will                 |
  |    - test if pfshow was on and turn it back on         |
  * ------------------------------------------------------ */
pfshow:
  if zpfshow = 'OFF' then return
  arg pfkopt
  if pfkopt = 'RESET' then do
    if pfkeys = 'ON' then
    'select pgm(ispopf) parm(FKA,ON)'
  end
  if pfkopt = 'OFF' then do
    'vget (zpfshow)'
    pfkeys = zpfshow
    if pfkeys /= 'OFF' then
    'select pgm(ispopf) parm(FKA,OFF)'
  end
  return

  /* ---------------------------------------- *
  | Common routine for normal (2 line) popup |
  * ---------------------------------------- */
Do_Popup:
  call pfshow 'off'           /* make sure pfshow is off */
  'Control Display Lock'
  'Addpop row(4) column(12)'
  'Display Panel(zigipop)'
  'Rempop'
  call pfshow 'reset'         /* restore pfshow setting */
  return

do_cmsg:
  do i = 1 to 7
    cmsgd.i = value(cmsg''i)
    cmsgd.i = cmsgd.i' '
  end
  do i = 7 to 1 by -1
    if strip(cmsgd.i) /= null then leave
  end
  cmsgd.0 = i
  file = 'cmsg'random(999)
  fdd  = file
  if sysvar('syspref') = null
  then filem = sysvar('sysuid')'.'file
  else filem = file
  file = localrep'/'file
  file = "'"file"'"
  address tso
  'alloc f('fdd') new spa(1,1) tr recfm(f b) lrecl(72) blksize(0)',
    'ds('filem') reuse'
  'execio * diskw' fdd '(finis stem cmsgd.'
  'free  f('fdd')'
  call outtrap 'x.'
  'oput' filem file 'Text'
  'delete' filem
  call outtrap 'off'
  address ispexec
  return

  /* ---------------------------------- *
  | Update stats file after member add |
  * ---------------------------------- */
Git_Add_Member_Stats:
  call pop 'Updating member stats in zigi \ Patience.'
  if defruid /= null then call update_userid
  statfiles = usssafe(omvsfile)
  if dovedir /= 0 then do
  dovedir = subword(dovedir,2)
  cmd = dovedir"getpds -M st="localrep"/"zigirep"/.zigi/"statfiles ,
        "//'"strip(dsname,'B',"'")"'" ,
        '&& cd' localrep'/'zigirep'/.zigi/' ,
        '&& git add' statfiles
  x = docmd(cmd)
  if x > 0 then
    call view_std 'B'
  return
  end
  x = zigistat("'"workdsn"'" ,
    localrep'/'zigirep'/.zigi/'omvsfile 'S')
  x = docmd('cd' localrep'/'zigirep '&& git add .zigi/'statfiles)
  if x > 0 then
    call view_std 'B'
  return

  /* ------------------------------------------------------ *
   | Update the Userid of the Member to the Defined Default |
   * ------------------------------------------------------ */
Update_Userid:
  x = listdsi("'"workdsn"'")
  if sysdsorg /= 'PO' then return
  "LMINIT DATAID(reset) DATASET('"workdsn"')"
  "LMOPEN DATAID("reset") OPTION(INPUT)"
  if zluser /= defruid then
    'LMMSTATS DATAID('reset') Member('member')' zlmmuser(defruid)
  "LMClose Dataid("reset")"
  "LMFree  Dataid("reset")"
  return

  /* -------------------------- *
  | Remove the HLQ for our use |
  * -------------------------- */
Remove_DSN_HLQ: Procedure expose qualignr pdshlq
  arg dsn
  dsn = translate(strip(dsn,'B',"'"),' ','.')
  if qualignr > 0 then
  dsn = subword(dsn,qualignr+1)
  dsn = translate(dsn,'.',' ')
  return dsn

  /* ------------------------- *
  | Make dsn safe for OMVS cp |
  * ------------------------- */
usssafe:
 parse arg safedsn
 if pos('$',safedsn) = 0 then return safedsn
 safe$pos = 1
 do forever
    pos$safe = pos('$',safedsn,safe$pos)
    if pos$safe < 1 then return safedsn
    left$safe = left(safedsn,pos$safe-1)
    right$save = substr(safedsn,pos$safe)
    safedsn = left$safe'\'right$save
    safe$pos = pos$safe + 2
    end
 return safedsn

oldsafe: procedure
  parse arg dsn
  if pos('$',dsn) = 0 then return dsn
  /* Let's not usssafe it twice :) */
  if pos('\$',dsn) > 0 then return dsn
  dsn = strreplace(dsn, '$', '\$')
  return dsn

  /* ------------------------------------------------- *
  |                                                  |
  | String replace routine                           |
  | input string                                     |
  | from string                                      |
  | to string                                        |
  | translate is input to from                       |
  * ------------------------------------------------- */
strreplace: Procedure
  string  = arg(1)
  strfrom = arg(2)
  strto   = arg(3)
  if pos(strfrom,string) = 0 then return string
  newString = ''
  do i = 1 to length(string)
    if substr(string,i,1) /= strfrom
    then newstring = newstring''substr(string,i,1)
    else  newstring = newstring''strto
  end
  return newstring

  /* ----------------------------------------------------- *
  | Get the users current OMVS enviornment for use in the |
  | bpxwunix commands.                                    |
  * ----------------------------------------------------- */
GETENV:

  cmd  = docmdx('env')

  x = bpxwunix(cmd,,env.,se.)

  envc = env.0
  call add_env '_BPX_SHAREAS=MUST'
  call add_env '_BPX_SPAWN_SCRIPT=YES'
  call add_env 'EXPORT _EDC_ADD_ERRORNO2=1'
  call add_env 'HOME='home
  call add_env '_EDC_ZERO_RECLEN=Y'
  call add_env 'ICONV_EBCDIC_ZOS_UNIX=1'
  env.0 = envc
  return

  /* -------------------- *
  | Add info to env stem |
  * -------------------- */
add_env:
  parse arg env_val
  envc = envc + 1
  env.envc = env_val
  return

docmd:
  parse arg cmd
  drop so. se.
  x = bpxwunix(cmd,,so.,se.,env.)
  return x

docmdx:
  /* quircky thing, we need to export HOME as we are
  not running a login shell via bpxwunix */
  parse arg cmdx
  cmd = 'pwd'
  x = bpxwunix(cmd,,ho.,he.)
  home    = strip(ho.1)
  drop so. se.

  Address ISPExec 'vget (gitenv)'
  if gitenv /= null
  then envfile = '.' gitenv ' >/dev/null 2>&1 &&'
  else envfile = null

  /* check for users .profile */
  address syscall 'lstat' "'"home"/.profile'" 'x.'
  if x.0 > 0 then home_profile =  ". "home"/.profile &&"
     else home_profile = null

  rx = 'export HOME='home' && . /etc/profile > /dev/null 2>&1 && ' ,
       home_profile envfile

  x = bpxwunix(c,,o.,e.)
  if o.0 = 1 & o.1 = "f" then do
    rx = rx '. 'home'/.profile > /dev/null 2>&1 && '
  end
  r = rx cmdx
  return r

  /* ----------------------------- *
  | Add record to end of so. stem |
  * ----------------------------- */
Add_so: procedure expose so.
  parse arg text
  c = so.0
  c = c + 1
  so.c = '  '
  c = c + 1
  so.c = text
  so.0 = c
  return

  /* ---------------------------------------------------------- *
  | Generalized routine to view stdout. (so.) or stderr. (se.) |
  | based on the parm passed                                   |
  * ---------------------------------------------------------- */
view_std:
  arg stdopt viewopt
  if stdopt = null then viewopt = 'B'
  if viewopt = null then viewopt = 'B'
  if stdopt = 'X' then stdopt = null
  if datatype(so.0) /= 'NUM' then so.0 = 0
  if datatype(se.0) /= 'NUM' then se.0 = 0
  if viewopt = 'B' then if so.0 + se.0 = 0 then return
  /* ------------------------------- *
  | Randomly define a DDName to use |
  * ------------------------------- */
  dd = 'zd'random(9999)
  /* --------------------------------------- *
  | Get lrecl to determine dcb for temp d/s |
  * --------------------------------------- */
  if stdopt /= 'C' then do
    vlrecl = 0
    do li  = 1 to so.0
      so.li = strip(so.li,'T')
      if length(so.li) > vlrecl then vlrecl = length(so.li)
      if so.li = null then so.li = ' '
    end
    do li  = 1 to se.0
      se.li = strip(se.li,'T')
      if length(se.li) > vlrecl then vlrecl = length(se.li)
      if se.li = null then se.li = ' '
    end
    sec = so.0 + se.0
  end
  else do
    do li = 1 to combine.0
      if length(combine.li) > vlrecl then vlrecl = length(combine.li)
    end
    sec = combine.0
  end
  if vlrecl < 81 then vlrecl = 80
  /* ------------------------------------------ *
  | Allocate a temporary data set for our data |
  * ------------------------------------------ */
  Address TSO
  /* calculate space needed with avg 50 bytes per record */
  prim = (((so.0 + se.0) * 50) % 56000) + 1
  if prim < 2 then prim = 5
  if viewopt = 'V' then do
    if sysvar('syspref') = null then pref = userid()'.'
    else pref = null
    vdsn = pref'work.zigi.gitdata'
  end
  else vdsn = null
  x = listdsi(vdsn)
  if x = 0 then do
    call outtrap 'x.'
    'delete' vdsn
    call outtrap 'off'
  end
  if vdsn /= null then vdsnp = 'da('vdsn') unit(3390)'
  else vdsnp = null
  'Alloc f('dd') new spa('prim','prim') tr reuse' ,
    'recfm(v b) lrecl('vlrecl+4') blksize(0)' vdsnp
  /* ----------------------------- *
  | If stdopt is 'B' then do both |
  * ----------------------------- */
  if stdopt /= 'C' then do
    stdopt = null
    sc = so.0
    do xi = 1 to se.0
      sc = sc + 1
      so.sc = se.xi
    end
    so.0 = sc
  end
  /* ----------------------- *
  | Write out the stem data |
  * ----------------------- */
  if stdopt = 'C' then do
    'Execio * diskw' dd '(finis stem combine.'
    drop combine.
    combine.0 = 0
  end
  if stdopt /= 'C' then do
    if stdopt = null
    then do
      'Execio * diskw' dd '(finis stem so.'
    end
    else do
      'Execio * diskw' dd '(finis stem se.'
    end
  end
  /* -------------------------------------------------- *
  | Access the Temporary Data Set using ISPF           |
  | Library Services.                                  |
  | Then using ISPF Browse service to browse the data. |
  | And use Library Services to Free the Data Set.     |
  * -------------------------------------------------- */
  Address ISPExec
  if sec > 0 then if viewopt = 'B' then do
    'lminit dataid(ddb) ddname('dd')'
    'browse dataid('ddb')'
    'lmfree dataid('ddb')'
  end
  else do
    'view dataset('vdsn')'
    vtitle = null
    'verase vtitle'
  end
  /* ----------------------------- *
  | Last Free the z/OS Allocation |
  * ----------------------------- */
  call outtrap 'x.'
  Address TSO ,
    'Free f('dd')'
  if vdsn /= null then
  Address TSO 'Delete' vdsn
  call outtrap 'off'
  return

Lower: Procedure
  parse arg input
  out = translate(input,"abcdefghijklmnopqrstuvwxyz",,
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
  return out

get_binfiles:
  /* ---------------------------------------------------------\
  | Name:      get_binfiles                                    |
  |                                                            |
  | Function:  Fills the global binfiles. stem with all        |
  |            current repo files that are added as binary.    |
  \---------------------------------------------------------- */
  cmd = 'cd 'localrep'/'zigirep' &&' ,
    'cat -W filecodeset=UTF-8 .gitattributes' ,
    '| grep binary' ,
    '| cut -d" " -f1'
  x = docmd(cmd)
  binfiles. = null
  bc = 0
  do b = 1 to so.0
    if left(strip(so.b),2) = '*.' then iterate
    bc = bc + 1
    binfiles.bc = so.b
  end
  binfiles.0 = bc
  return 0

is_binfile:
  /* ---------------------------------------------------------\
  | Name:      is_binfile                                      |
  |                                                            |
  | Function:  Checks the global binfiles. stem for the        |
  |            provided dataset or dataset/member              |
  \---------------------------------------------------------- */
  parse arg checkForBinFile
  if datatype(binfiles.0) /= 'NUM' then return 0
  do bi = 1 to binfiles.0
    if binfiles.bi = checkForBinFile then return 1
    if right(binfiles.bi,1) = '*' then do
      parse value checkForBinFile with test'/'.
      if left(binfiles.bi,length(binfiles.bi)-2) = test
      then return 1
    end
  end
  return 0

  /* ----------------------------------------- *
  | Get the .zigi/dsn to find file extensions |
  * ----------------------------------------- */
get_dsn_info:
  zdsn. = null
  cmd = 'cat' localrep'/'zigirep'/.zigi/dsn'
  x = bpxwunix(cmd,,s.,e.)
  if x > 0 then return
  do di = 1 to s.0
    zd = word(s.di,1)
    zdsn.zd = word(s.di,6)
    zdsn.0 = zd
  end
  drop s. e.
  return

  /* --------------------  rexx procedure  -------------------- *
  * Name:      LoadISPF                                        *
  *                                                            *
  * Function:  Load ISPF elements that are inline in the       *
  *            REXX source code.                               *
  *                                                            *
  * Syntax:    load_info = loadispf()                          *
  *            rc = dropispf(load_info)                        *
  *                                                            *
  *            The inline ISPF resources are limited to        *
  *            ISPF Messages, Panels, and Skeletons,           *
  *                 CLISTs and EXECs are also supported.       *
  *                                                            *
  *            The inline resources must start in column 1     *
  *            and use the following syntax:                   *
  *                                                            *
  *            >START    used to indicate the start of the     *
  *                      inline data                           *
  *                                                            *
  *            >END    - used to indicate the end of the       *
  *                      inline data                           *
  *                                                            *
  *            Each resource begins with a type record:        *
  *            >type name                                      *
  *               where type is CLIST, EXEC, MSG, PANEL, SKEL  *
  *                     name is the name of the element        *
  *                                                            *
  * Sample usage:                                              *
  *          -* rexx *-                                        *
  *          load_info = loadispf()                            *
  *          ... magic code happens here (your code) ...       *
  *          rc = dropispf(load_info)                          *
  *          exit                                              *
  *          >Start inline elements                            *
  *          >Panel panel1                                     *
  *          ...                                               *
  *          >Msg msg1                                         *
  *          ...                                               *
  *          >End of inline elements                           *
  *                                                            *
  * Returns:   the list of ddnames allocated for use along     *
  *            with the libdef's performed or altlib           *
  *                                                            *
  *            format is ddname libdef ddname libdef ...       *
  *                   libdef may be altlibc or altlibe         *
  *                   for altlib clist or altlib exec          *
  *                                                            *
  * Notes:     Entire routine must be included with REXX       *
  *            exec - inline with the code.                    *
  *                                                            *
  * Comments:  The entire rexx program is processed from the   *
  *            last record to the first to find the >START     *
  *            record at which point all records from that     *
  *            point on are processed until the >END           *
  *            statement or the end of the program is found.   *
  *                                                            *
  *            It is *strongly* suggested that the inline      *
  *            elements be at the very end of your code so     *
  *            that the search for them is faster.             *
  *                                                            *
  *            Inline ISPTLIB or ISPLLIB were not supported    *
  *            because the values for these would have to be   *
  *            in hex.                                         *
  *                                                            *
  * Author:    Lionel B. Dyck                                  *
  *                                                            *
  * History:                                                   *
  *            01/09/19 - Include DROPISPF routine             *
  *            08/29/17 - Fixup static values that were vars   *
  *            05/31/17 - Change default directory count       *
  *            12/09/16 - update for add_it routine            *
  *            05/10/16 - correction for clist and exec        *
  *            04/19/16 - bug correction                       *
  *            06/04/04 - Enhancements for speed               *
  *            08/05/02 - Creation                             *
  *                                                            *
  * ---------------------------------------------------------- *
  * Disclaimer: There is no warranty, either explicit or       *
  * implied with this code. Use it at your own risk as there   *
  * is no recourse from either the author or his employeer.    *
  * ---------------------------------------------------------- */
LoadISPF: Procedure

  parse value "" with null kmsg kpanel kskel first returns ,
    kclist kexec
  /* ------------------------------------------------------- *
  * Find the InLine ISPF Elements and load them into a stem *
  * variable.                                               *
  *                                                         *
  * Elements keyword syntax:                                *
  * >START - start of inline data                           *
  * >CLIST name                                             *
  * >EXEC name                                              *
  * >MSG name                                               *
  * >PANEL name                                             *
  * >SKEL name                                              *
  * >END   - end of all inline data (optional if last)      *
  * ------------------------------------------------------- */
  last_line = sourceline()
  do i = last_line to 1 by -1
    line = sourceline(i)
    if translate(left(line,6)) = ">START " then leave
  end
  rec = 0
  /* --------------------------------------------------- *
  * Flag types of ISPF resources by testing each record *
  * then add each record to the data. stem variable.    *
  * --------------------------------------------------- */
  do j = i+1 to last_line
    line = sourceline(j)
    if translate(left(line,5)) = ">END "   then leave
    if translate(left(line,7)) = ">CLIST " then kclist = 1
    if translate(left(line,6)) = ">EXEC "  then kexec  = 1
    if translate(left(line,5)) = ">MSG "   then kmsg   = 1
    if translate(left(line,7)) = ">PANEL " then kpanel = 1
    if translate(left(line,6)) = ">SKEL "  then kskel  = 1
    rec  = rec + 1
    data.rec = line
  end

  /* ----------------------------------------------------- *
  * Now create the Library and Load the Member(s)         *
  * ----------------------------------------------------- */
  Address ISPExec
  /* ----------------------------- *
  * Assign dynamic random ddnames *
  * ----------------------------- */
  clistdd = "lc"random(999)
  execdd  = "le"random(999)
  msgdd   = "lm"random(999)
  paneldd = "lp"random(999)
  skeldd  = "ls"random(999)

  /* ---------------------------------------- *
  *  LmInit and LmOpen each resource library *
  * ---------------------------------------- */
  if kclist <> null then do
    call alloc_dd clistdd
    "Lminit dataid(clist) ddname("clistdd")"
    "LmOpen dataid("clist") Option(Output)"
    returns = strip(returns clistdd 'ALTLIBC')
  end
  if kexec <> null then do
    call alloc_dd execdd
    "Lminit dataid(exec) ddname("execdd")"
    "LmOpen dataid("exec") Option(Output)"
    returns = strip(returns execdd 'ALTLIBE')
  end
  if kmsg <> null then do
    call alloc_dd msgdd
    "Lminit dataid(msg) ddname("msgdd")"
    "LmOpen dataid("msg") Option(Output)"
    returns = strip(returns msgdd 'ISPMLIB')
  end
  if kpanel <> null then do
    call alloc_dd paneldd
    "Lminit dataid(panel) ddname("paneldd")"
    "LmOpen dataid("panel") Option(Output)"
    returns = strip(returns paneldd 'ISPPLIB')
  end
  if kskel <> null then do
    call alloc_dd skeldd
    "Lminit dataid(skel) ddname("skeldd")"
    "LmOpen dataid("skel") Option(Output)"
    returns = strip(returns skeldd 'ISPSLIB')
  end

  /* ----------------------------------------------- *
  * Process all records in the data. stem variable. *
  * ----------------------------------------------- */
  do i = 1 to rec
    record = data.i
    recordu = translate(record)
    if left(recordu,5) = ">END " then leave
    if left(recordu,7) = ">CLIST " then do
      if first = 1 then call add_it
      type = "Clist"
      first = 1
      parse value record with x name
      iterate
    end
    if left(recordu,6) = ">EXEC " then do
      if first = 1 then call add_it
      type = "Exec"
      first = 1
      parse value record with x name
      iterate
    end
    if left(recordu,5) = ">MSG " then do
      if first = 1 then call add_it
      type = "Msg"
      first = 1
      parse value record with x name
      iterate
    end
    if left(recordu,7) = ">PANEL " then do
      if first = 1 then call add_it
      type = "Panel"
      first = 1
      parse value record with x name
      iterate
    end
    if left(recordu,6) = ">SKEL " then do
      if first = 1 then call add_it
      type = "Skel"
      first = 1
      parse value record with x name
      iterate
    end
    /* --------------------------------------------*
    * Put the record into the appropriate library *
    * based on the record type.                   *
    * ------------------------------------------- */
    Select
      When type = "Clist" then
      "LmPut dataid("clist") MODE(INVAR)" ,
        "DataLoc(record) DataLen(255)"
      When type = "Exec" then
      "LmPut dataid("exec") MODE(INVAR)" ,
        "DataLoc(record) DataLen(255)"
      When type = "Msg" then
      "LmPut dataid("msg") MODE(INVAR)" ,
        "DataLoc(record) DataLen(80)"
      When type = "Panel" then
      "LmPut dataid("panel") MODE(INVAR)" ,
        "DataLoc(record) DataLen(80)"
      When type = "Skel" then
      "LmPut dataid("skel") MODE(INVAR)" ,
        "DataLoc(record) DataLen(80)"
      Otherwise nop
    end
  end
  if type <> null then call add_it
  /* ---------------------------------------------------- *
  * Processing completed - now lmfree the allocation and *
  * Libdef the library.                                  *
  * ---------------------------------------------------- */
  if kclist <> null then do
    Address TSO,
      "Altlib Act Application(Clist) File("clistdd")"
    "LmFree dataid("clist")"
  end
  if kexec <> null then do
    Address TSO,
      "Altlib Act Application(Exec) File("execdd")"
    "LmFree dataid("exec")"
  end
  if kmsg <> null then do
    "LmFree dataid("msg")"
    "Libdef ISPMlib Library ID("msgdd") Stack"
  end
  if kpanel <> null then do
    "Libdef ISPPlib Library ID("paneldd") Stack"
    "LmFree dataid("panel")"
  end
  if kskel <> null then do
    "Libdef ISPSlib Library ID("skeldd") Stack"
    "LmFree dataid("skel")"
  end
  return returns

  /* --------------------------- *
  * Add the Member using LmmAdd *
  * based upon type of resource *
  * --------------------------- */
Add_It:
  Select
    When type = "Clist" then
    "LmmAdd dataid("clist") Member("name")"
    When type = "Exec" then
    "LmmAdd dataid("exec") Member("name")"
    When type = "Msg" then
    "LmmAdd dataid("msg") Member("name")"
    When type = "Panel" then
    "LmmAdd dataid("panel") Member("name")"
    When type = "Skel" then
    "LmmAdd dataid("skel") Member("name")"
    Otherwise nop
  end
  type = null
  return

  /* ------------------------------ *
  * ALlocate the temp ispf library *
  * ------------------------------ */
Alloc_DD:
  arg dd
  Address TSO
  if pos(left(dd,2),"lc le") > 0 then
  "Alloc f("dd") unit(sysda) spa(5,5) dir(5)",
    "recfm(v b) lrecl(255) blksize(32760)"
  else
  "Alloc f("dd") unit(sysda) spa(5,5) dir(5)",
    "recfm(f b) lrecl(80) blksize(23440)"
  return

  /* --------------------  rexx procedure  -------------------- *
  * Name:      DropISPF                                        *
  *                                                            *
  * Function:  Remove ISPF LIBDEF's and deactivate ALTLIB's    *
  *            that were created by the LoadISPF function.     *
  *                                                            *
  * Syntax:    rc = dropispf(load_info)                        *
  *                                                            *
  * Author:    Janko                                           *
  *                                                            *
  * History:                                                   *
  *            06/02/25 - Update test for Co:Z getpds          *
  *            12/05/18 - Creation                             *
  * ---------------------------------------------------------- */
DropISPF: Procedure
  arg load_info
  Address ISPEXEC
  do until length(load_info) = 0
    parse value load_info with dd libd load_info
    if left(libd,6) = "ALTLIB" then do
      if libd = "ALTLIBC" then lib = "CLIST"
      else lib = "EXEC"
      Address TSO,
        "Altlib Deact Application("lib")"
    end
    else "libdef" libd
    address tso "free f("dd")"
  end
  return 0

  /* ----------------------------------------------------- *
   | If the encoding ISPF variable is not set then get the |
   | repository default encoding from the .gitattributes   |
   * ----------------------------------------------------- */
Get_Default_Codepage:
  cmd = 'cd' omvsfs '&&' ,
    'cat -W filecodeset=UTF-8,pgmcodeset=IBM-1047 .gitattributes' ,
    "| grep 'zos-working-tree-encoding'"
  x = bpxwunix(cmd,,s.,e.)
  encoding = null
  do i = 1 to s.0
    if pos('zos-working-tree-encoding',s.i) = 0 then iterate
    parse value s.i with .'zos-working-tree-encoding='encoding .
    return
  end
  if encoding = null then
  encoding = 'IBM-1047'
  return

Check_for_CoZ:
  /* ----------------------- *
  | Check for getpds/putpds |
  * ----------------------- */
  enhanced_cp = 1
  x = listdsi('NOCOZ' 'FILE')
  if sysreason /= 2 then do
    enhanced_cp = 0
    dovedir     = 0
    dovestat    = null
    'vput (dovedir dovestat) shared'
    return
  end
  if enhanced_cp = 1 then do
  x = docmd('command -v getpds')
  if x = 0
     then do
       enhanced_cp = 1
       dovetail_dir = so.1
       lp = lastpos('/',dovetail_dir,length(dovetail_dir)-1)
       dovetail_dir = left(dovetail_dir,lp)
     end
  end
    else enhanced_cp = 0
  dovedir = enhanced_cp dovetail_dir
  dovestat    = 'Co:Z active'
  'vput (dovedir dovestat) shared'
  return

/*   Start of inline ISPF Panels - do NOT use REXXFORM option CI
>Start
>Panel zgopt
)Attr
_ type(input) hilite(uscore) caps(on) intens(low) just(left)
)Body Window(43,6)
+
+Enter Git Option:_opt+(A, AC, ACP, or O)
+
+View Log:_z+%Y+or%N+
+
+Press%Enter+to Continue, or%F3+to Cancel.
)Init
 .zvars = '(zglogo)'
 &zwinttl = 'zigi Git Option'
 .help = zgopth
)Proc
ver (&opt,nb,list,A,AC,ACP,O)
ver (&zglogo,nb,list,Y,N)
)End
>Panel zgopth
)Attr
)Body Window(45,4)
+ZG Options:  %A+  Git Add only
+             %AC+ Git Add and Commit
+             %ACP+Git Add, Commit, and Push
+             %O+  Open the Repo in Zigi
)Init
 &zwinttl = 'zigi Git Option Tutorial'
)Proc
)End
>Panel zgtbl
)Attr
_ type(input) hilite(uscore) caps(on) intens(low) just(left)
$ type(output) caps(off)
] type(output) caps(off) intens(low)
} type(output) caps(off) intens(low) just(right)
@ type(text) caps(off) intens(high) color(white) hilite(uscore)
)Body Window(64,15) expand(\\)
+
%Command ===>_zcmd       \ \ %Scroll ===>_zscr+
+
+Selection:%A+Add%AC+Add/Commit%ACP+Add/Commit/Push%O+Open zigi
+
%    @Repository             Category        Last Date  +
)Model
_z  +$z                  +  ]z             +}z          +
)Init
&zwinttl = 'Update Git Repository'
&zscr = CSR
.help = zgtblh
.zvars = '(zsel zigirep zigicat zigidate)'
)Proc
Ver (&zsel,list,A,AC,O,ACP)
)End
>Panel zgtblh
)Attr
)Body Window(47,7)
+Select the Repository for this Dataset using
+one of these ZG options:
+
+      %A+  Git Add only
+      %AC+ Git Add and Commit
+      %ACP+Git Add, Commit, and Push
+      %O+  Open the Repo in Zigi
)Init
 &zwinttl = 'zigi Git Option Tutorial'
)Proc
)End
>Panel zgcom
)Attr
_ type(input) hilite(uscore) caps(off) intens(low) just(left)
)Body Window(68,11)
+
+Enter Commit Message:
_cmsg1                                                            +
_cmsg2                                                            +
_cmsg3                                                            +
_cmsg4                                                            +
_cmsg5                                                            +
_cmsg6                                                            +
_cmsg7                                                            +
+
+Press%Enter+to Continue, or%F3+to Cancel.
)Init
&zwinttl = 'zigi Commit Message'
)Proc
ver (&cmsg1,nb)
)End
>Panel zigipop
)Attr
 $ type(output) caps(off)
)Body Window(54,4)
+
  $zs1
  $zs2

)Init
 &zwinttl = 'zigi Status Popup'
)Proc
)end
/* -------------------------------------------------------- */
/* zigi - the z/OS ISPF Git Interface                       */
/* Copyright (C) 2020 GPL V3 - Henri Kuiper and Lionel Dyck */
/* -------------------------------------------------------- */
>Exec zigistat
  /* --------------------  rexx procedure  -------------------- *
  | Name:      zigistat                                        |
  |                                                            |
  | Function:  Collect or Compare the ISPF Stats for all       |
  |            members in a PDS                                |
  |                                                            |
  | Syntax:    x=zigistat(dsname filepath option)              |
  |                                                            |
  |            dsname is the z/OS dataset name to work with    |
  |                                                            |
  |            filepath is the OMVS file where the stats are   |
  |            stored and consists of:                         |
  |                localdir/repodir/.ZIGI/filename             |
  |                filename is the OMVS file that represents   |
  |                the z/OS PDS dataset name                   |
  |                                                            |
  | Options:   C - compare stats                               |
  |            S - save stats                                  |
  |            U - update stats to those saved                 |
  |                used when creating/refreshing datasets      |
  |                                                            |
  | Vars:      statmems ispf variable for selective update     |
  |                                                            |
  | Usage                                                      |
  |   Notes: Subroutine of ZIGI                                |
  |          Returns string of members changed                 |
  |                                                            |
  | Dependencies:                                              |
  |          ISPF services                                     |
  |                                                            |
  | Return:                                                    |
  |          0 - stats saved or stats applied                  |
  |          8 - no dsname provided                            |
  |         12 - no filepath provided                          |
  |         16 - no option provided                            |
  |         20 - stats file in /.zigi missing                  |
  |     string - string of members with different stats        |
  |                                                            |
  | Author:    Lionel B. Dyck                                  |
  |                                                            |
  | History:  (most recent on top)                             |
  |            04/25/22 TPM - Add 2 dropped statements         |
  |                           (LBD - my bad)                   |
  |            03/23/22 TPM - list of repo files not in PDS    |
  |                           merged by LBD                    |
  |            03/07/22 LBD - Update usssafe routine tests     |
  |            03/05/22 LBD - Update usssafe routine for #     |
  |            03/04/22 LBD - Add ISPF Stats if PDS member     |
  |                           does not have them               |
  |            03/03/22 LBD - Correct debugfil variable        |
  |            02/15/22 LBD - Correct if no Dovetail           |
  |            02/07/22 LBD - Fix stats if NOCOZ               |
  |            12/18/21 LBD - Correct dsorg/recfm test         |
  |            10/18/21 LBD - Correctly tag stats file         |
  |            10/08/21 LBD - Check for background             |
  |            08/18/21 LBD - Correct AMBLIST for Link and     |
  |                           Add AMBLIST analysis popups      |
  |            08/16/21 LBD - Align amblist (lmod) file        |
  |                         - Support PDSE lmod libraries      |
  |            08/04/21 LBD - Use encoding to tag stats file   |
  |            08/02/21 LBD - Correct use of dovedir variable  |
  |                         - use AMBLIST for load libraries   |
  |            07/26/21 LBD - Fix allmems missing one member   |
  |            06/03/21 LBD - Change SHAREAS to REQUIRED       |
  |            05/29/21 LBD - Clean up environment setup       |
  |            05/26/21 LBD - Use dovetail getpds for stats    |
  |            05/18/21 LBD - More popups with info and fix    |
  |                           allmems variables setup          |
  |            05/06/21 LBD - Multiple allmems variables       |
  |            10/25/20 LBD - Improve usssafe routine          |
  |            09/27/20 LBD - Compare stats improved           |
  |            08/14/20 LBD - Don't update if readonly repo    |
  |            06/19/20 LBD - Ignore LMOD aliases as the main  |
  |                           lmod will have them included     |
  |            06/16/20 LBD - Use DEFRUID if it exists         |
  |            06/09/20 LBD - Bypass stat update for lmod      |
  |            05/08/20 LBD - Support Load Libraries           |
  |            01/08/20 LBD - Selecitve stat update if statmems|
  |            01/05/20 LBD - Correct special chars in filepath|
  |                           using usssafe routine            |
  |            11/22/19 LBD - If a member has no stats - add   |
  |            11/18/19 LBD - Many fixes and add Debug         |
  |            11/15/19 LBD - Creation                         |
  |                                                            |
  | ---------------------------------------------------------- |
  |    ZIGI - the z/OS ISPF Git Interface                      |
  |    Copyright (C) 2020-2021 - Henri Kuiper and Lionel Dyck  |
  |                                                            |
  |    This program is free software: you can redistribute it  |
  |    and/or modify it under the terms of the GNU General     |
  |    Public License as published by the Free Software        |
  |    Foundation, either version 3 of the License, or (at     |
  |    your option) any later version.                         |
  |                                                            |
  |    This program is distributed in the hope that it will be |
  |    useful, but WITHOUT ANY WARRANTY; without even the      |
  |    implied warranty of MERCHANTABILITY or FITNESS FOR A    |
  |    PARTICULAR PURPOSE.  See the GNU General Public License |
  |    for more details.                                       |
  |                                                            |
  |    You should have received a copy of the GNU General      |
  |    Public License along with this program.  If not, see    |
  |    <https://www.gnu.org/licenses/>.                        |
  * ---------------------------------------------------------- */
zigistat:

  /* --------------- *
  | Define defaults |
  * --------------- */
  parse value '' with null string m. rx allmems codep
  zdd = 'ZS'time('s')

  /* ---------------------------------- *
   | Check for Background of Foreground |
   * ---------------------------------- */
   if sysvar('sysenv') = 'FORE'
      then background = 0
      else background = 1

  /* --------------------------------- *
  | Check for parms and return if not |
  * --------------------------------- */
  parse arg dsn filepath opt
  if dsn      = null then return 8
  if filepath = null then return 12
  if opt      = null then return 16
  opt         = translate(opt)   /* make upper case */

  /* ---------------------------------------- *
  | Check for ZIGIDEBG DD for debug purposes |
  * ---------------------------------------- */
  x = listdsi('ZIGIDEBG' 'FILE')
  if x > 0 then if sysreason = 3
  then zigidebg = 1
  else zigidebg = 0

  Address ISPExec
  'vget (debugfil defruid readonly dovedir encoding)'
  parse value encoding with .'-'codep .
  if codep = null then codep = 1047

  call getenv

  x = debug('start of zigistat with option:' opt)

  /* --------------------------------------- *
  | If option C or U then read in the stats |
  | - check if stats member exists rc=16    |
  | - read into stem stats.                 |
  * --------------------------------------- */
  if pos(opt,'C U') > 0 then do
    x = debug('Checking stats file' filepath)
    x = check_stats_file(filepath)
    rc = x
    x = debug('Checking stats file complete')
    if rc > 0 then return x
    x = debug('Reading the ISPF stats file')
    drop stats.
    cmd = 'cat' usssafe(filepath)
    x = bpxwunix(cmd,,stats.,se.)
    do i = 1 to stats.0
      stats.i = translate(stats.i,' ','0D'x)
    end
    x = debug('Reading complete')
  end

  /* ------------------ *
  * Define ISPF Dataid *
  * ------------------ */
  Address ISPExec

  /* ---------------------------------- *
  | Get dataset recfm (check for lmod) |
  * ---------------------------------- */
  x = listdsi(dsn)

  /* ------------ *
  * Set defaults *
  * ------------ */
  x = debug('Collecting stats for all members for:' dsn)
  parse value null with member mem. ,
    ZLCDATE ZLMDATE ZLVERS ZLMOD ZLMTIME ZLCNORC,
    ZLINORC ZLMNORC ZLUSER ,
    zlcnorce zlinorce zlmnorce ,
    zlsize zlamod zlrmode zlattr zlalias zlssi
  mem.0  = 0
  if defruid = null
  then newuid = sysvar('sysuid')
  else newuid = defruid

  zs1 = 'Collecting statistics for:'
  zs2 = dsn
  zs3 = null
  zs4 = null
  call do_popup4

  /* ----------------------- *
  * Now process all members *
  * ----------------------- */
  if sysdsorg = 'PO' & sysrecfm = 'U'
  then do
       zs3 = 'Collecting Load Module Information'
       call do_popup4
       Address TSO
       x = get_loadlib(dsn)
       Address ISPExec
       end
  else if sysdsorg = 'PO' then do
    if dovedir = 0 then do
      "LMINIT DATAID(STATUS) DATASET("dsn")"
      "LMOPEN DATAID("STATUS") OPTION(INPUT)"
      do forever
        "LMMLIST Dataid("status") OPTION(LIST) MEMBER(MEMBER)" ,
          "STATS(YES)"
        /* --------------------------------- *
        * If RC 4 or more leave the do loop *
        * --------------------------------- */
        if rc > 3 then leave
        /* -------------------------------- *
        | Check if no stats then add them. |
        * -------------------------------- */
        if sysrecfm /= 'U' then
        if zlcdate = null then
        if readonly = 0 then do
          'LMMSTATS DATAID('status') Member('member')' zlmmuser(newuid)
          "LMMFind DATAID("status") Member("member") STATS(YES)"
        end
        /* ------------------------------ *
        * Add each member info to a stem *
        * ------------------------------ */
        c = mem.0 + 1
        if sysrecfm /= 'U'
        then mem.c = strip(member ,
          ZLCDATE  ZLMDATE  ZLVERS ZLMOD ZLMTIME ZLCNORC ,
          ZLINORC ZLMNORC ZLUSER ,
          zlcnorce zlinorce zlmnorce)
        else if strip(zlalias) = null then do
          mem.c = strip(member ,
            zlsize zlamod zlrmode zlattr zlalias zlssi)
        end
        else c = c - 1
        mem.0 = c
        if strip(zlalias) = null then
        if opt = 'C' then allmems = allmems member
        if c//100 = 0 then do
          zs3 = 'Processing count:' c
          call do_popup4
        end
      end

      /* ------------------------- *
      * Close and Free the Dataid *
      * ------------------------- */
      "LMClose Dataid("status")"
      "LMFree  Dataid("status")"
    end
    else do
      dovedir = subword(dovedir,2)
      cmd = usssafe(dovedir"getpds -M st=- //"strip(dsn,'B',"'"))
      drop mem. se.
      x = debug('Get ISPF Stats using getpds:' cmd)
      x = bpxwunix(cmd,,mem.,se.,env.)
      do mi = 1 to mem.0
        allmems = allmems word(mem.mi,1)
      end
    end
  end
  x = debug('Stat collection complete.')

  zs1 = 'Collection complete.'
  call do_popup4

  /* ----------------------------------------------- *
  | Process the data based on the provided options: |
  |                                                 |
  |    C - compare stats                            |
  |    S - save stats                               |
  |    U - update stats to those saved              |
  |        used when creating/refreshing datasets   |
  * ----------------------------------------------- */
  Select
    /* ----------------------------------------------------- *
    | Save all stats for all members in the active dataset. |
    | - data will be saved to /.zigi/filename               |
    * ----------------------------------------------------- */
    When opt = 'S' then do
      x = debug('Saving stats begins to:' filepath)
      x = bpxwunix('rm' usssafe(filepath),,so.,se.)
      call write_stats
      cmd = 'chtag -c' codep usssafe(filepath)
      x = bpxwunix(cmd,,so.,se.)
      x = debug('Saving stats completed.')
      return 0
    end
    /* ---------------------------------------------------------- *
    | Update ISPF Stats:                                         |
    |  - all members in the ZIGI stats member will have their    |
    |    ispf stats updated to reflect the saved stats           |
    |  - Use statmems ispf var for selective stat updates        |
    |  - new members will not be updated as we don't know about  |
    |   them                                                     |
    |  - members with no stats will have stats added if they are |
    |    in the saved stats member                               |
    * ---------------------------------------------------------- */
    When opt = 'U' then do
      if readonly = 1 then return 0
      if sysrecfm /= 'U' then do
        x = debug('Performing ISPF Stats file update for:' dsn)
        'vget (statmems)'
        if statmems /= null then do
          x = debug('Update Members:' statmems)
        end
        "LMINIT DATAID(zstats) DATASET("dsn")"
        "LMOPEN DATAID("zstats") OPTION(INPUT)"
        do i = 1 to stats.0
          parse value stats.i with member ZLCDATE ZLMDATE ZLVERS ZLMOD ,
            ZLMTIME ZLCNORC ZLINORC ZLMNORC ZLUSER ZLCNORCE ,
            ZLINORCE ZLMNORCE .
          if statmems /= null then
          if wordpos(member,statmems) = 0 then iterate
          if zlcdate = null then ,
            'LMMSTATS DATAID('zstats') Member('member')' ,
             zlmmuser(sysvar(sysuid))
          else ,
            'LMMSTATS DATAID('zstats') MEMBER('member') VERSION('zlvers')' ,
            'MODLEVEL('zlmod') CREATED('zlcdate') MODDATE('zlmdate')' ,
            'MODTIME('zlmtime') INITSIZE('zlinorc')' ,
            'MODRECS('zlmnorc')' zlmmuser(zluser)
        end
        "LMClose Dataid("zstats")"
        "LMFree  Dataid("zstats")"
        x = debug('ISPF Stats file update complete.')
        return 0
      end
    end
    /* ----------------------------------------------------------- *
    | Compare ISPF stats.                                         |
    |                                                             |
    | Comparison will be from the active datasets ISPF stats with |
    | the saved stats found in ISPF stats file in /.zigi          |
    |                                                             |
    | If a member is in the active but not in the saved list then |
    | it will be added to the returned string.                    |
    |                                                             |
    | If a members saved stats do not match the active stats then |
    | it will be added to the returned string.                    |
    * ----------------------------------------------------------- */
    When opt = 'C' then do
      x = debug('ISPF Stats comparison starting.')
      zs1 = 'Begin comparing stats'
      call do_popup4
      /* 1st setup the saved stem for easy comparison */
      do i = 1 to stats.0
        parse value stats.i with savedmem cd md . . mt . . . uid .
        m.savedmem = strip(cd md left(mt,5) uid)
      end
      /* now compare active to saved */
      do i = 1 to mem.0
        if i//100 = 0 then do
          zs3 = 'Checked' i 'members of' mem.0
          call do_popup4
        end
        parse value mem.i with actmem cd md . . mt . . . uid .
        data = strip(cd md left(mt,5) uid)
        if m.actmem = null
        then string = string actmem
        else if data /= m.actmem then string = string actmem
        if datatype(uid) /= 'CHAR' then data = null
        if strip(data) = null then call update_member_ispf_stats
      end
      zs3 = 'Completed - building member list.'
      call do_popup4
      allmemsc = 0
      allmems = strip(allmems)

      /* From TPM */
      /* now that allmems has been populated, and before we start cutting */
      /* it up to store ISPF variable versions, identify and store a list */
      /* of the names of any repo directory files not found in the list.  */

      parse var filepath pfx '/.zigi' sfx
      repo_dir = pfx || sfx

      cmd = 'ls -l' repo_dir
      x = bpxwunix(cmd,,ro.,se.,env.)

      repo@nf = ''

      do n = 1 to ro.0
        if words(ro.n) < 3 then iterate n

        repo_mem = word(ro.n,words(ro.n))
        if wordpos(repo_mem,allmems) = 0 then repo@nf = repo@nf repo_mem
        end

      repo@nfc = 0

      if repo@nf <> '' then do
        if length(repo@nf) < 32000 then do
          repo@nfc = 1
          repo@nf1 = strip(repo@nf)
          'VPUT (REPO@NF1)'
          end

        else do forever
          repo@nfc = repo@nfc + 1
          if length(repo@nf) > 32000 then
            lp = lastpos(' ',repo@nf,length(repo@nf)-32000)
          else lp = 0

          if lp > 0 then do
            interpret 'repo@nf'repo@nfc '=' substr(repo@nf,lp)
            repo@nf = strip(left(repo@nf,lp-1))
            end
          else do
            interpret 'repo@nf'repo@nfc '= strip(repo@nf)'
            repo@nf = null
            end

          'VPUT (REPO@NF'repo@nfc')'
          if strip(repo@nf) = null then leave
          end
        end          /* end if repo@nf <> '' */

      'VPUT (REPO@NFC)'

      if length(allmems) < 32000
      then do
        allmemsc = allmemsc + 1
        interpret 'allmems'allmemsc '= allmems'
        'vput (allmems'allmemsc')'
      end
      else do forever
        allmemsc = allmemsc + 1
        if length(allmems) > 32000
        then lp = lastpos(' ',allmems,length(allmems)-32000)
        else lp = 0
        if lp > 0
        then do
          interpret 'allmems'allmemsc '=' substr(allmems,lp)
          allmems = left(allmems,lp-1)
        end
        else do
          interpret 'allmems'allmemsc '= allmems'
          allmems = null
        end
        'vput (allmems'allmemsc')'
        if strip(allmems) = null then leave
      end
      'vput (allmemsc)'
      x = debug('ISPF Stats comparison complete:' string)
      return string
    end
    Otherwise nop  /* should never get here */
  end

Update_Member_ISPF_Stats:
    "LMINIT DATAID(zstats) DATASET('"sysdsname"')"
    "LMOPEN DATAID("zstats") OPTION(INPUT)"
    parse value mem.actmem with cdt mdt mtm uid
    if uid /= null then
    'LMMSTATS DATAID('zstats') Member('actmem') Created('cdt')',
           'Moddate('mdt') Modtime('mtm')' zlmmuser(uid)
    else
    'LMMSTATS DATAID('zstats') Member('actmem')' zlmmuser(userid())
    "LMClose Dataid("zstats")"
    "LMFree  Dataid("zstats")"
   return

  /* -------------------------------------------- *
  | Check to see if the provided filepath exists |
  | rc 0 it does                                 |
  | rc 20 it does not                            |
  * -------------------------------------------- */
Check_Stats_File:
  address syscall 'lstat' filepath 'file.'
  if file.0 = 0 then do
    ADDRESS ISPExec
    return 20
  end
  else return 0

  /* ----------------------------------------------------- *
  | Get the users current OMVS enviornment for use in the |
  | bpxwunix commands.                                    |
  * ----------------------------------------------------- */
GETENV:
  cmd = 'pwd'
  omvsenv.1 = '_BPX_SHAREAS=MUST'
  omvsenv.0 = 1
  x = bpxwunix(cmd,,so.,se.,omvsenv.)
  home    = strip(so.1)

  x = debug('Starting collection of env variables')

  cmd  = docmdx('env')

  rc = bpxwunix(cmd,,env.,se.,omvsenv.)
  envc = env.0
  call add_env '_BPX_SHAREAS=MUST'
  call add_env '_BPX_SPAWN_SCRIPT=YES'
  call add_env 'EXPORT _EDC_ADD_ERRNO2=1'
  call add_env '_EDC_ZERO_RECLEN=Y'
  env.0 = envc

docmdx:
  /* quircky thing, we need to export HOME as we are
  not running a login shell via bpxwunix */
  parse arg cmd
  drop o. se.
  if gitenv /= null
  then envfile = '.' gitenv ' >/dev/null 2>&1 &&'
  else envfile = null

  /* check for users .profile */
  address syscall 'lstat' "'"home"/.profile'" 'x.'
  if x.0 > 0 then home_profile =  ". "home"/.profile &&"
  else home_profile = null

  rx = 'export HOME='home' && . /etc/profile > /dev/null 2>&1 && ' ,
    home_profile envfile
  r = rx ' ' cmd
  return r

  /* -------------------- *
  | Add info to env stem |
  * -------------------- */
add_env:
  parse arg env_val
  envc = envc + 1
  env.envc = env_val
  return

docmd:
  parse arg cmd
  drop so. se.
  x = bpxwunix(cmd,,so.,se.,env.)
  return x

  /* ----------------------------- *
  | Write out the ISPF Stats file |
  * ----------------------------- */
Write_Stats:
  call syscalls 'ON'
  address syscall
  /* Fill dsn file with the comments */
  /* look like the 'open' command does the escaping for us... */
  fpok = strreplace(filepath,'\$', '$')
  'open' fpok O_rdwr+O_creat+O_trunc 660
  if retval = -1 then do
    Address ISPExec
    zs1 = "Something bad when creating"
    zs2 = filepath
    zs4 = 'Press F3 to close this popup and exit.'
    parse value '' with zs3
    call do_popup4
    'close' fd
    call syscalls 'OFF'
    return
  end
  fd = retval
  do is = 1 to mem.0
    call write_fd mem.is
  end
  'close' fd
  call syscalls 'OFF'
  Address ISPExec
  lp = lastpos('/',filepath)
  chpath = left(filepath,lp)
  chfile = substr(filepath,lp+1)
  x = docmd('cd' chpath '&& chtag -tc' encoding chfile)
  return

  /* ----------------------------------- *
  | Routine to write out a line of data |
  * ----------------------------------- */
Write_FD:
  parse arg string
  string = string || ESC_N
  'write' fd 'string' length(string)
  return

  /* ----------------------------------- *
  | Issue popup - turn off pfshow if on |
  * ----------------------------------- */
Do_Popup4:
  if background = 1 then do
     if strip(zs1) /= null then say zs1
     if strip(zs2) /= null then say zs2
     if strip(zs3) /= null then say zs3
     if strip(zs4) /= null then say zs4
     return
     end
  if address() /= 'ISPEXEC' then do
     poptso = 1
     Address ISPExec
     end
  else poptso = 0
  call pfshow 'off'           /* make sure pfshow is off */
  'Control Display Lock'
  'Addpop row(4) column(6)'
  'Display Panel(zigipop4)'
  'Rempop'
  call pfshow 'reset'         /* restore pfshow setting */
  if poptso = 1 then Address TSO
  return

  /* -------------------------------- *
  | routine to turn off pfshow if on |
  * -------------------------------- */
pfshow:
  if zpfshow = 'OFF' then return
  arg pfkopt
  if pfkopt = 'RESET' then do
    if pfkeys = 'ON' then
    'select pgm(ispopf) parm(FKA,ON)'
  end
  if pfkopt = 'OFF' then do
    'vget (zpfshow)'
    pfkeys = zpfshow
    if pfkeys /= 'OFF' then
    'select pgm(ispopf) parm(FKA,OFF)'
  end
  return

debug:
  if zigidebg  = 1 then do
    parse arg msg
    msg = Date() Time()' : 'msg
    c = 'echo "'msg'" >>' debugfil
    x = bpxwunix(c,,dso.,dse.)
  end
  return 0

usssafe:
  parse arg safe_command
  safe_ret = 1
  if pos('\$',safe_command) > 0 then safe_ret = 0
  if pos('\#',safe_command) > 0 then safe_ret = 0
  if safe_ret = 0 then return safe_command
  if pos('$',safe_command)  > 0 then safe_ret = 1
  if pos('#',safe_command)  > 0 then safe_ret = 1
  if safe_ret = 0 then return safe_command
  safe$pos = 1
  do forever
    pos$safe = pos('$',safe_command,safe$pos)
    if pos$safe < 1 then leave
    left$safe = left(safe_command,pos$safe-1)
    right$save = substr(safe_command,pos$safe)
    safe_command = left$safe'\'right$save
    safe$pos = pos$safe + 2
  end
  safe$pos = 1
  do forever
    pos$safe = pos('#',safe_command,safe$pos)
    if pos$safe < 1 then return safe_command
    left$safe = left(safe_command,pos$safe-1)
    right$save = substr(safe_command,pos$safe)
    safe_command = left$safe'\'right$save
    safe$pos = pos$safe + 2
  end
  return safe_command

STRREPLACE:
  ORIGINAL = ARG(1)
  OLDTXT = ARG(2)
  NEWTXT = ARG(3)
  /* YOU CAN CHANGE THE BELOW KEY (TMPTXT), WHICH IS USED AS A TEMPORARY
  POINTER TO IDENTIFY THE TEXT TO BE REPLACED */
  TMPTXT = '6A53CD2EW1F'
  NEWSTR = ORIGINAL
  DO WHILE POS(OLDTXT,NEWSTR) > 0
    NEWSTR = SUBSTR(NEWSTR, 1 , POS(OLDTXT,NEWSTR)-1) ||,
      TMPTXT || SUBSTR(NEWSTR, POS(OLDTXT,NEWSTR) + LENGTH(OLDTXT))
  END
  DO WHILE POS(TMPTXT,NEWSTR) > 0
    NEWSTR = SUBSTR(NEWSTR, 1 , POS(TMPTXT,NEWSTR)-1) ||,
      NEWTXT || SUBSTR(NEWSTR, POS(TMPTXT,NEWSTR) + LENGTH(TMPTXT))
  END
  RETURN NEWSTR

Get_LoadLib:
  arg lm_dsname

  drop mem.
  oc = 0

  if sysvar('syspref') /= ''
  then syspds = sysvar("syspref")".z"date("J")
  else syspds = sysvar("sysuid")".z"date("J")

  call outtrap 'x.'
  'free f(sysin sysprint syslib)'
  call outtrap 'off'

  cc.1 = ' LISTIDR OUTPUT=ALL'
  cc.0 = 1
  cal = null

  call outtrap 'x.'
  "delete '"syspds"'"
  call outtrap 'off'

  'Alloc f(syslib) ds('lm_dsname') shr reuse'
  'Alloc f(sysprint) unit(sysallda) spa(900,1500) tr new reuse' ,
    "ds('"syspds"')"
  'Alloc f(sysin) unit(sysallda) spa(1,1) tr recfm(f b) lrecl(80)' ,
    'blksize(80) new reuse'
  'Execio * diskw sysin (finis stem cc.'
  drop cc.

  address Link 'amblist'

  'free f(sysprint)'

  zs3 = 'AMBList completed - Filtering now.'
  call do_popup4

  /* -------------------------------------- *
  | Escape any $ found in the dataset name |
  * -------------------------------------- */
  if pos('$',syspds) > 0 then
  do forever
    if pos('\$',syspds) > 0 | pos('$',syspds) = 0 then leave
    p = pos('$',syspds)
    ld = left(syspds,p-1)
    rd = substr(syspds,p+1)
    syspds = ld'\$'rd
  end

  grep_string = 'MEMBER|PRODUCED'

  /* --------------------------------------------- *
  | Create OMVS supported format for dataset name |
  * --------------------------------------------- */
  dsn = '"//'||"'"syspds"'"||'"'

  /* ----------------- *
  | Drop results stem |
  * ----------------- */
  drop results.

  /* ---------------------------------------------------- *
  | Invoke BPXWUNIX                                      |
  | 1st to cat (copy) the z/OS dataset into the pipe (|) |
  | and 2nd to grep (search) the results for the string  |
  | with the results going into the results. stem        |
  | and errors into the e. stem.                         |
  * ---------------------------------------------------- */
  x = bpxwunix('cat' dsn "| grep -E -i '"grep_string"'",,results.,e.)

  'Free  f(syslib)'
  'Alloc f(sysin) ds(*) reuse'
  'Alloc f(sysprint) ds(*) reuse'

  zs3 = 'Analyzing the filtered AMBLIST data.'
  zs4 = results.0 'records to process.'
  call do_popup4

  do lmi = 1 to results.0
    if word(results.lmi,1) = 'MEMBER' then do
      member = left(word(results.lmi,3),8)
    end
    if subword(results.lmi,2,2) = 'PROGRAM OBJECT' then do
       time = word(results.lmi,15)
       parse value word(results.lmi,13) with dmon'/'day'/'year
       day   = date('d',year''dmon''day,'s')
       year = right(year,2)
       cal  = year''right(day+1000,3)
       end
    if word(results.lmi,8) = 'BINDER' & word(results.lmi,19) = 'AT' then do
      day = word(results.lmi,15)
      year = substr(word(results.lmi,18),3,2)
      time = left(word(results.lmi,20),8)
      cal  = year''day
    end
    if word(results.lmi,7) = 'LINKAGE' & word(results.lmi,10) = 'AT' then do
      day = word(results.lmi,15)
      year = substr(word(results.lmi,18),3,2)
      time = left(word(results.lmi,20),8)
      cal  = year''day
    end
    if cal <> '' then do
      oc = oc + 1
      mem.oc = left(member,8) cal time
      mem.0 = oc
        if opt = 'C' then allmems = allmems member
        if oc//100 = 0 then do
          zs3 = 'Processing count:' oc
          Address ISPExec
          call do_popup4
          Address TSO
        end
      cal = ''
    end
  end

  return 0
>End    End of inline ISPF Panels */
