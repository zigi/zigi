  /* --------------------  rexx procedure  ------------------- */
  ver = 'v3r20'
  /*Name:      ZIGI  (z ISPF Git Interface)                    |
  |                                                            |
  | Function:  ISPF Interface to Git for source code           |
  |            management                                      |
  |                                                            |
  | Syntax:    ex 'zigi.exec(zigi)'                            |
  |                                                            |
  |            or to restore the splash screen                 |
  |            ex 'zigi.exec(zigi)' 'S'                        |
  |                                                            |
  |            or to start with a specific repository          |
  |            ex 'zigi.exec(zigi)' 'repo-name'                |
  |                                                            |
  | NOTE:      ZIGI MUST NEVER be started under the ZIGI       |
  |            ISPF Applications ID unless the libdef and      |
  |            altlibs are done prior to starting.             |
  |                                                            |
  | Dependencies:                                              |
  |            1. Requires the z/OS port of GIT be installed   |
  |            2. Git setup in /etc/profile or ~/.profile      |
  |                                                            |
  | Authors:   Henri Kuiper                                    |
  |            Lionel B. Dyck                                  |
  |                                                            |
  | Contributors:                                              |
  |           FM  - Filipe Meireles                            |
  |                                                            |
  | History:  (most recent on top, see git log for full info)  |
  |                                                            |
  |            04/02/24 - Version 3.20                         |
  |                     - remove zos-working-tree-encoding     |
  |                       =BINARY as not needed(breaks zot)    |
  |                     - Update all iconv use to use          |
  |                       /bin/iconv                           |
  |            02/03/24 - Version 3.19                         |
  |                     - Fix grep in a pds to use pds member  |
  |                     - Honor F3 on Config (zigiset) panel   |
  |                     - Honor umask                          |
  |                     - update get_binfiles to ignore . #    |
  |                     - Update .gitattribute update routine  |
  |                       when adding binary elements          |
  |            06/15/23 - Version 3.18                         |
  |                     - Add env ICONV_EBCDIC_ZOS_UNIX=1      |
  |                     - Remove -m from git log               |
  |                     - New PRIM command GITEnv              |
  |                     - Add REGEN option to SSH key panel    |
  |                     - Check for invalid stats record and   |
  |                       ignore stat reset                    |
  |                     - Update for SET Rename HLQ to update  |
  |                       .gitattributes and .zigi/dsn         |
  |            03/02/23 - Version 3.17                         |
  |                     - new /ENVR start parm to blank git env|
  |                     - new /ENV start parm to reset git env |
  |                     - when setting up .gitconfig change    |
  |                       defaultBranch to main                |
  |                     - Fixup Remote info for git 2.39+      |
  |                     - Move splash bypass option            |
  |                     - Correct bugs in grep viewing         |
  |                     - Save version for panel titles        |
  |                     - Fix for subdirectories               |
  |                     - Fix for pds member untracked         |
  |                     - Speed up history extract             |
  |                       remove cat > ...                     |
  |                     - Correct file extract encoding        |
  |                     - Use default edit panel for           |
  |                       history viewing                      |
  |            01/15/23 - Version 3.16                         |
  |                         - Allow / on command lines as alias|
  |                           of O to display prompt popup     |
  |                         - Enable View for OMVS files if    |
  |                           Browse requested but untagged    |
  |                         - Enable Edit/View for OMVS files  |
  |                           if untagged as ASCII             |
  |                         - LBD Allow AA for AddAll and      |
  |                               AD for AddDSN                |
  |                         - LBD For getpds add chtag for stat|
  |                         - LBD Add fetch all for merge diff |
  |                         - LBD Fix merge - use origin/xxx   |
  |                         - LBD Check for ahead status       |
  |                         - LBD Improve check after Merge    |
  |                         - LBD History Compare Edit support |
  |                         - LBD Fix view_std lrecl           |
  |                         - LBD Allow deleting remote branch |
  |                         - LBD Support / in branch names    |
  |                         - LBD Fix History Date (DEV s/b    |
  |                           DEC) - fat fingers               |
  |                         - LBD Add History Compare (Z)      |
  |                           to compare current to history    |
  |                         - LBD Use git show for history     |
  |                           show and replace (no more stash) |
  |            08/24/22 - Version 3.15                         |
  |                         - LBD Fix BLame (mem var) issue    |
  |                         - LBD Use ISPF LMMREN to rename    |
  |                           a PDS Member                     |
  |                         - LBD Add BLame line command       |
  |                         - LBD Allow F3 on Connect prompt   |
  |                         - LBD Fix encoding/tag for README  |
  |                         - LBD Display Pull report          |
  |                         - LBD Add -S D (shared) on putpds  |
  |                         - LBD chtag mixed error            |
  |                         - LBD Fix repo connect display     |
  |                           panel syntax                     |
  |                         - LBD Correct test for PDS mbrs    |
  |                           if they have a suffix in git     |
  |                         - LBD Add SET option to prompt on  |
  |                           repository exit                  |
  |                         - LBD If show status requested     |
  |                           don't if clean.                  |
  |                         - LBD On TBCreate replace blanks   |
  |                           with underscores                 |
  |                         - Support E(dit) selection for     |
  |                           OMVS files                       |
  |            05/10/22 - HK/LBD - Version 3.14                |
  |                         - Some fixes for non-dovetail      |
  |                           setups (HK)                      |
  |                         - Improve Co:Z detection and debug |
  |                         - Do not show status on open of new|
  |                         - Add Show Git Status on repo open |
  |                         - Do not set cp -X -I if not PDS   |
  |                         - Honor users codepage (encoding)  |
  |                         - Fix add of dsn with #'s          |
  |                         - Improve History date/time sort   |
  |                         - Correct NOCOZ check              |
  |                         - Update encoding var to remove 0D |
  |                         - getpds/putpds cleanup            |
  |                         - Correct Commit add process       |
  |                         - Correct Grep error on non-zOS    |
  |                         - Fix usssafe for cp and fix tags  |
  |                         - If PDS member changed to Binary  |
  |                           update the PDS member type to B  |
  |                         - Pass codep to zigigeni           |
  |            03/07/22 LBD - Fix localdir after member rm     |
  |                         - Clean up usssafe                 |
  |                         - After member remove update repo  |
  |                           status message                   |
  |                         - After dataset remove update repo |
  |                           status message                   |
  |            03/06/22 HK  - Fix some nasty bugs :)           |
  |            03/04/22 LBD - Add optional Add to Commit       |
  |                         - Add # to usssafe                 |
  |            03/03/22 LBD - Correct ISPF Stats on Edit       |
  |                         - Correct undo if member is #...   |
  |                         - Correct debugfil name            |
  |            02/15/22 LBD - Correct if no Dovetail           |
  |            02/03/22 LBD - Correct dsnvalid test for blank  |
  |            02/01/22 LBD - Correct Dataset add stats        |
  |                           if no Dovetail                   |
  |            01/30/22 HK  - Fix ZIGISTAT not found when      |
  |                           creating a new repo              |
  |            01/12/22 LBD - If history fails report it       |
  |                         - Change history extract to use    |
  |                           stash push/pop with checkout     |
  |                           or no stash if nothing changed   |
  |                         - Check status on Stash request    |
  |                           and bypass if nothing changed    |
  |            12/07/21 LBD - Clean up do_history list         |
  |            12/06/21 LBD - Prevent adding empty PDS datasets|
  |                         - Correct zerrhm panel name        |
  |            11/24/21 LBD - Clean up codep (codepage) from   |
  |                           .gitattributes                   |
  |            11/19/21 LBD - Correct getpds tag check         |
  |                         - Require git version 2.26 or newer|
  |            11/09/21 LBD - Correct member delete process    |
  |                           on repo open                     |
  |            10/25/21 LBD - Correct tag on new members       |
  |            10/23/21 LBD - Improved File Tagging            |
  |                           using default encoding charset   |
  |            08/16/21 LBD - Corrections for detected deleted |
  |                           PDS members                      |
  |            08/04/21 LBD - Corrections for add tagging      |
  |                           to use usssafe                   |
  |            06/15/21 LBD - Enable Add-Binary (AB) of        |
  |                           RECFM=V with warning.            |
  |            06/07/21 LBD - Use zigiemmd (edit macro) for    |
  |                           all .md files and PDS members    |
  |                           with a md suffix.                |
  |            06/05/21 LBD - Refine Commit Prompt             |
  |            06/03/21 LBD - Add tbsave after tbdelete (SP)   |
  |                         - Change SHAREAS to REQUIRED       |
  |                         - Change COMMIT processing         |
  |            06/01/21 LBD - Add edit macro for readme.md     |
  |                           edit with md syntax tips         |
  |            05/31/21 LBD - On clone make hlq default to     |
  |                           users prefix or userid           |
  |                         - New READme command to add/edit   |
  |                           a README.md file in a repo       |
  |            05/28/21 LBD - Correct filename with suffix     |
  |                           after Edit                       |
  |            05/27/21 LBD - Ignore missing home/.profile for |
  |                           environment variables            |
  |            05/26/21 LBD - Exploit getpds during check      |
  |                         - other small cleanup              |
  |            05/18/21 LBD - Improve environment variable     |
  |                           setup with improved env file     |
  |                           support.                         |
  |            05/15/21 LBD - Pass environment to ZIGIGCMD     |
  |            05/11/21 LBD - Fix for checking for updates     |
  |            05/06/21 SP  - Fix allmems 32k limit            |
  |                         - add -A to git add .              |
  |            04/16/21 SP  - Update USSSAFE routine to prevent|
  |                           duplication of escapes '\'       |
  |                           thx to Spiridopoulos             |
  |            04/13/21 LBD - Change from ISPTABL to ISPPROF   |
  |                         - add ussafe on change tag         |
  |            04/10/21 LBD - Add year variable for splash     |
  |            03/29/21 LBD - Add Control Errors Return        |
  |            03/17/21 LBD - Correct omvs directory returns   |
  |            03/07/21 LBD - Correct tbsort for repo table    |
  |            02/09/21 LBD - Change ADDALL to 'git add .'     |
  |            02/08/21 LBD - Fix broken Debug initialization  |
  |                         - Fix rm of missing pds member     |
  |                         - Clean up tables after CHECK      |
  |            02/06/21 LBD - Add Copy popup for changed PS    |
  |            02/05/21 LBD - Improve dsnvalid routine to fix  |
  |                           repo delete processing of z/os   |
  |                         - Test for and prevent Adding      |
  |                           a RECFM=V Binary dataset as      |
  |                           they are unsupported by cp       |
  |            01/24/21 LBD - Correct bug 391 commiting updates|
  |                           of .gitattributes on add         |
  |            01/12/21 LBD - Correct stat handling for LMODs  |
  |            01/11/21 LBD - Correct git clean check (FM)     |
  |                         - Clean up History if none         |
  |                         - Correct History Recovery after   |
  |                           dsnvalid changes                 |
  |                         - Correct History Recover of PS    |
  |            01/09/21 LBD - small corrections identified by  |
  |                           Filipe: save_dsninfo ignore all  |
  |                           files with / and git_add_member  |
  |                           correct use of extensions        |
  |            01/08/21 LBD - Verify usssafe is used for copy  |
  |                         - Add DIFF command                 |
  |                         - Fix detection of changed PS d/s  |
  |            01/07/21 LBD - Correct bug with file extnsions  |
  |                         - Prevent updating .zigi/dsn with  |
  |                           member info (ab)                 |
  |            01/06/21 LBD - Ignore files not in .zigi/dsn    |
  |                           for z/OS consideration           |
  |            12/07/20 LBD - Correct setting -T               |
  |                         - Correct stats on add for recfm=U |
  |            11/20/20 LBD - Small fixes in many areas        |
  |            11/19/20 LBD - Use -T for cp default            |
  |                         - Add check for NOCOZ DD to bypass |
  |                           Dovetail getpds/putpds           |
  |                         - Pass dovetail state in ispf var  |
  |            11/13/20 LBD - Add Read Only flag to ZIGIINFO   |
  |            11/12/20 LBD - Option to keep .git files on repo|
  |                           delete (only remove from zigi)   |
  |                         - New CONNECT command to add an    |
  |                           existing ZIGI formatted git      |
  |                           repository.                      |
  |            11/03/20 FM  - Correct file tag on git add      |
  |                     LBD - Update for new dovetail syntax   |
  |            10/27/20 LBD - Clean up confirm mem delete      |
  |            10/25/20 LBD - Improved usssafe routine         |
  |            10/14/20 LBD - Make GREP panel a popup w/help   |
  |            10/10/20 LBD - Correct incorrect member untrack |
  |                         - Correct undo with putpds cmd     |
  |                         - Correct branch change detect of  |
  |                           added/removed elements           |
  |            09/27/20 LBD - Add SHAREAS=YES to all bpxwunix  |
  |                         - Correct .gitignore for memstat   |
  |            09/26/20 LBD - Add debug for all commands       |
  |                         - Support for Dovetail enhanced    |
  |                           getpds and putpds to replace cp  |
  |            09/23/20 LBD - Refresh repository view after    |
  |                           adding dataset(s)                |
  |                         - Correct Git Ignore detection     |
  |            09/21/20 LBD - Add status of [  ] Git Ignore    |
  |                         - Add PDS mem option I to gitignore|
  |                         - Add PDS mem option AF to git     |
  |                           add -f (force)                   |
  |            09/17/20 LBD - When testing table state if 0    |
  |                           rows then return                 |
  |            09/16/20 LBD - Remove %b from history log       |
  |            09/08/20 LBD - After commit bypass remote chk   |
  |            09/07/20 LBD - Experimental exits               |
  |            09/06/20 LBD - Remove calls to work/update after|
  |                           PDS member update                |
  |            08/24/20 LBD - Correct Del Repo processing      |
  |            08/23/20 LBD - On ADDDSN if ignore is 0 allow   |
  |                           changing HLQ while in table      |
  |                         - Correctly detected Added if 0    |
  |                         - Make remove from repo clearer    |
  |            08/16/20 LBD - On Clone if non-zigi bypass      |
  |                           gitattributes and .zigi create   |
  |            08/15/20 LBD - Refine z/OS replace prompt       |
  |                         - On stash pop leave stash table   |
  |            08/14/20 LBD - Support for ReadOnly Repositories|
  |                         - Prompt before full z/OS replace  |
  |            08/08/20 LBD - Allow qualignr of 0              |
  |                         - if file not in new branch do     |
  |                           NOT delete z/OS dataset or mem   |
  |                         - After Merge call update repo     |
  |                         - Generalize get_binfiles          |
  |            08/07/20 LBD - Add pfshow off/reset all pops    |
  |            08/06/20 LBD - Remove redundant repo del code   |
  |            07/29/20 LBD - Add _EDC_ZERO_RECLEN=Y to env.   |
  |            07/25/20 LBD - Correct Stash processing         |
  |            07/24/20 LBD - Set wrap message on zigiprim     |
  |                           and for zigirepo                 |
  |            07/22/20 LBD - Fix merge issue if no deletes    |
  |                           and enable selective replace     |
  |                           after merge conflicts resolved   |
  |            07/18/20 LBD - Add Find for History table       |
  |            07/17/20 LBD - Speed up History commit find     |
  |                         - Rewrite History View/Recover     |
  |            07/15/20 LBD - Keep .git/.gitattributes on del  |
  |                           from zigi if omvs retained       |
  |                         - On repo delete option to keep    |
  |                           git directories/files            |
  |            07/14/20 LBD - Fix bug detecting entry updates  |
  |                         - Correct dataset check on branch  |
  |            07/12/20 LBD - Resolve merge deletion issue     |
  |                         - Fix multiple member RM issue     |
  |            07/11/20 LBD - Correct member status after RN   |
  |                         - Correct merge conflict on ispf   |
  |                           stats member (do automatically)  |
  |            07/08/20 LBD - Correct copy after member edit   |
  |            07/07/20 LBD - Ensure status update after A/AB  |
  |                         - Support members w/ext for defurid|
  |            07/06/20 LBD - Correct F3 on Rollback process   |
  |                         - Fix zigirep with reponame        |
  |                           and vice versa                   |
  |            07/05/20 LBD - Fix member delete on pull        |
  |                         - Support Repoistory Name          |
  |                           unique from directory name       |
  |                         - Update Stats after member chg    |
  |                         - For Find use reponame and cat    |
  |                           along with prefix in zigiprim    |
  |            07/04/20 HBK - Fix bug in zigi-flow             |
  |            06/28/20 LBD - After edit use usssafe on cp     |
  |            06/27/20 LBD - Correct check on repo select     |
  |            06/25/20 LBD - Correct .gitattributes update for|
  |                           load library add                 |
  |            06/24/20 LBD - On a branch only update/copy/del |
  |                           changed elements                 |
  |            06/23/20 LBD - Enable Prompt for AB extensions  |
  |            06/20/20 LBD - Add object hash to taglist tag   |
  |            06/19/20 LBD - swap git rm and rm if mbr gone   |
  |            06/18/20 LBD - Correct Extract list and Show    |
  |                         - On Add Dataset copy all using    |
  |                           a single cp if not mixed (t/b)   |
  |                         - On Add Dataset RECFM=U is set    |
  |                           to Binary Load Module on S/A     |
  |            06/17/20 LBD - Backout cp change on add copy    |
  |                         - Add PopUp when Commit starts     |
  |            06/16/20 LBD - Fix SET ID on Commit             |
  |                         - Fix Invalid Selection on PDS List|
  |                         - vput Default UID on Repo Open    |
  |            06/15/20 LBD - Support recovery in mem delete   |
  |                         - enhance repo status info         |
  |                         - Clean up clone time message      |
  |                         - Correct Member list sort date    |
  |            06/14/20 LBD - Add prompt for delete processing |
  |                           if PDS member mia but OMVS not   |
  |            06/13/20 LBD - Replace Extract routines  with   |
  |                           call to zigiextr                 |
  |            06/12/20 LBD - Numerous bug fixes all small     |
  |            06/11/20 LBD - Tag Extract corrections          |
  |            06/10/20 LBD - Speed up bpxwunix with shareas   |
  |            06/08/20 LBD - Fix add member counter           |
  |                         - Add Parse to Arg is_binfile      |
  |                         - Correct is_binfile (procedure)   |
  |            06/07/20 LBD - Correct binfile check (no safe)  |
  |            05/27/20 LBD - Add error messages on browse     |
  |            05/26/20 LBD - Correct RM if untracked          |
  |            05/25/20 LBD - Improve status field for all     |
  |            05/19/20 EJA - Improve status field for PDS     |
  |            05/17/20 LBD - Fix merge resolution stats if    |
  |                           file extensions in use           |
  |                         - Fix current repo multi-select    |
  |                           failure                          |
  |            05/16/20 LBD - Fix last ref date file if hlq    |
  |                           changed on set                   |
  |            05/15/20 LBD - New Z line command repo/pds to   |
  |                           view the omvs directory/file     |
  |            05/15/20 HBK - Fix bug adding with extensions   |
  |            05/10/20 LBD - Fix TagList sort date            |
  |            05/08/20 LBD - Add support for executables      |
  |                           from RECFM=U libraries (-X -I)   |
  |                     HBK - Test for -X/-I support           |
  |                     LBD - On repo delete rm the last       |
  |                           reference file                   |
  |            05/02/20 LBD - Support graph view colors        |
  |            05/01/20 LBD - Fix Stash and Stash Pop issues   |
  |            04/29/20 LBD - Add volser to Add Dsn display    |
  |            04/28/20 LBD - Correct taglist create repo      |
  |                           display                          |
  |                         - Change to routine to set the     |
  |                           sortdate value                   |
  |            04/26/20 LBD - Update SnapShot to allow a null  |
  |                           path to bypass OMVS copy         |
  |                         - Same change for TagList Extract  |
  |            04/25/20 LBD - Add Commit Import command        |
  |            04/23/20 LBD - Fix Locate in Member List        |
  |                         - TagList Extract validate dir     |
  |            04/19/20 LBD - Correct D# bug in Commit table   |
  |            04/18/20 LBD - Remove residual Commit msgs      |
  |            04/16/20 LBD - Colorize ZIGIPRIM columns        |
  |                           white = sorted TURQ = not        |
  |                         - refacrot zigihist routines       |
  |            04/12/20 EJA - Improve overview by using        |
  |                           more function calls              |
  |                           There should be no functional    |
  |                           change                           |
  |            03/30/20 LBD - Enhance RM delete options        |
  |                         - Set version to 2.8               |
  |            03/28/20 LBD - Support PDS member file          |
  |                           extensions                       |
  |            03/18/20 LBD - Refine ref date check            |
  |                         - Bypass update check after repo   |
  |                           is selected.                     |
  |                         - New CHECK command to check       |
  |                           updated datasets.                |
  |            03/17/20 LBD - Improve delete PDS member        |
  |                           detection on PULL                |
  |                         - Bypass update check based on     |
  |                           last reference date of dataset   |
  |            03/15/20 LBD - Detect when PDS members deleted  |
  |                           outside of ZIGI                  |
  |            03/09/20 LBD - Remove unneeded control save/rest|
  |            03/05/20 HBK - Fixed another qualignr 'bug'     |
  |                         - More deletes at remove repo      |
  |            03/04/20 LBD - Jump to Add Dataset after Create |
  |            03/03/20 LBD - Several updates                  |
  |            02/28/20 LBD - Added Convert Repo capability    |
  |            02/27/20 HBK - Added feature 'zigiflow'         |
  |                           Fixed another edge case with $'s |
  |            02/26/20 LBD - Numerous changes to support      |
  |                           Stash processes                  |
  |                         - Fix fetch flag setting           |
  |            02/21/20 LBD - Change Refresh to Replace        |
  |                         - Add Fetch command                |
  |                         - Only fetch 1st time or on demand |
  |            02/15/20 LBD - Remove view_std's where not      |
  |                           worth it (rm/rn) and added msgs  |
  |                         - Change commit to use a table for |
  |                           an unlimited # of message lines  |
  |            02/14/20 LBD - Correctly identify already added |
  |                           datasets during ADDDSN           |
  |            02/13/20 LBD - Enable 2 column sort on Local    |
  |                           Repository and retain sort order |
  |                           for next time ZIGI starts.       |
  |                         - Fix bug with selective OMVS to   |
  |                           z/OS copy during PULL for both   |
  |                           renames and deletes.             |
  |                         - Enable passing a repo name on    |
  |                           start                            |
  |            02/10/20 LBD - Add SortDate for proper sorting  |
  |                         - Add optional tag on commit       |
  |            02/09/20 LBD - Update sort default orders       |
  |                         - add time to zigidate             |
  |                         - save default sort for zigirepo   |
  |            02/08/20 LBD - Test for branch before create    |
  |            02/07/20 LBD - Support Tag/Tagline              |
  |            02/03/20 LBD - Support mixed text/binary pds    |
  |            02/02/20 LBD - Add ADDALL to current repo and   |
  |                           PDS member list commands         |
  |            01/24/20 LBD - Improve RFIND table entry setup  |
  |            01/23/20 LBD - Eliminate use of LISTC for ADDdsn|
  |                           and call ZIGIRCSI                |
  |                         - Add FIND for ADDDSN routine      |
  |                         - Enable RFIND                     |
  |            01/21/20 LBD - Undo now works for PS and PDS    |
  |                         - Correct bug in RM for OMVS file  |
  |                           with blanks in name              |
  |                         - On Pull correctly delete items   |
  |                           that have been removed.          |
  |                         - After Commit if no push and a    |
  |                           Remote issue message to remind   |
  |                           to push.                         |
  |            01/20/20 LBD - Put OMVS files in quotes for     |
  |                           git add                          |
  |                         - Add several binary filetypes     |
  |                           to .gitattributes priming        |
  |            01/19/20 LBD - Add LMFree after every LMClose   |
  |                         - Pass qualignr to zigickot        |
  |                         - Fix qualignr=0 issues            |
  |            01/17/20 LBD - Support Only and Refresh in      |
  |                           Rollback                         |
  |            01/16/20 LBD - Support Recover in History for   |
  |                           individual element               |
  |            01/15/20 LBD - Fix binary PDS member tag -R     |
  |            01/14/20 HBK - Binary support implemented       |
  |                     LBD - Correct selective refresh bug    |
  |            01/13/20 LBD - Implement repository Snapshot    |
  |                         - Change current repo ADD to       |
  |                           ADDDSN                           |
  |            01/12/20 LBD - Always copy PS files and let     |
  |                           git determine any changes        |
  |            01/11/20 LBD - Do git add for stats after PDS   |
  |                           member rm                        |
  |                         - Prompt for OK to delete branch   |
  |            01/10/20 LBD - Correct detection of renames     |
  |                         - fix rename member with specials  |
  |            01/09/20 LBD - Support Repo del of the z/OS     |
  |                           datasets and more confirmation   |
  |            01/08/20 LBD - Update for PDSE generations      |
  |                           at allocation                    |
  |            01/07/20 LBD - Additional debug calls           |
  |                         - debug file name date/time added  |
  |                         - change list debug files from B   |
  |                         - don't copy PS if not new/changed |
  |            01/05/20 LBD - If PDSE then never do full       |
  |                           refresh on a pull                |
  |            01/03/20 LBD - On Pull only refresh updated     |
  |                           datasets and/or members.         |
  |                         - if > 25% members updated in pull |
  |                           then refresh full pds.           |
  |                         - Correct primary panel zcmd for   |
  |                           upper case command, mixed other  |
  |                         - Change sort order if Date to     |
  |                           include Time                     |
  |                         - On Edit_PS use usssafe for cp    |
  |                           on the repository file name      |
  |                         - Bypass update_repo_metadata if   |
  |                           multiple rows selected           |
  |            01/02/20 LBD - For clone/create set sets to null|
  |                         - Add Select command for repo      |
  |            12/26/19 LBD - Change temp dsn suffix: gitdata  |
  |            12/24/19 HBK - Correct URL parse                |
  |                     LBD - Enable O.xxx commands            |
  |            12/23/19 HBK - One more fix for file status     |
  |                     LBD - Use View for DIFF for hilite     |
  |            12/22/19 HBK - Correct stats for subdirectories |
  |            12/15/19 LBD - Add Author  to History display   |
  |            12/14/19 LBD - Improve history log search       |
  |                           using grep                       |
  |            12/13/19 LBD - Add new History selection        |
  |                         - Add incldiff leed-dev            |
  |            12/10/19 LBD - Add FIND/RFIND for Repo table    |
  |                           and in the dataset/file table    |
  |            12/09/19 LBD - Improve OMVS directory support   |
  |            12/07/19 LBD - Implement a git merge conflict   |
  |                           resolution process.              |
  |            12/06/19 LBD - Define top tutorial panel        |
  |            12/04/19 LBD - Support Remove (RM) and          |
  |                           Rename (RN) options              |
  |            11/30/19 LBD - Use Edit and View for OMVS files |
  |                         - Test if Edit OMVS file changed   |
  |            11/27/19 HBK - Check for minimal git version    |
  |            11/27/19 LBD - Translate ' and " from commit    |
  |                           1 line msg.                      |
  |                         - add -i (ignore case) to grep     |
  |                         - in grep dsn allow b/e/v of       |
  |                           omvs files                       |
  |            11/26/19 HBK - Support site profile             |
  |            11/25/19 LBD - Add repository SET for defaults  |
  |                         - Support ROLLBACK of repo         |
  |                         - Enhance GITLOG and GREP          |
  |                         - Update member uids if default id |
  |                           set during commit                |
  |            11/21/19 LBD - Check for ISPTABL and use it     |
  |                           otherwise use ISPPROF for our    |
  |                           table.                           |
  |            11/18/19 LBD - Support F3 in ZIGIOSEL and       |
  |                           skip clone.                      |
  |                         - Replace LMMSTATS with LMMFIND    |
  |                           to get member stats              |
  |                         - Add -v (verbose) where ok        |
  |            11/16/19 LBD - Convert to using zigitstat       |
  |                           to save/update/compare           |
  |                           ispf stats on PDS members.       |
  |            11/13/19 LBD - Enhance the debug routine:       |
  |                           Return a return code             |
  |                           check for ZIGIDEBG DD enable     |
  |                           log is in users home dir         |
  |            11/11/19 LBD - Add GITHELP as a command from    |
  |                           all panels (except browse)       |
  |            11/10/19 HBK - Fix qualignr edge-cases          |
  |            11/09/19 HBK - My history keeps dissapearing    |
  |                           see git :)                       |
  |            11/06/19 LBD - Numerous changes including       |
  |                           - Improve bpxwunix performance   |
  |                             by using an env stem           |
  |                           - fix lrecl for browse reports   |
  |                           - other bug fixes and cleanup    |
  |            11/02/19 LBD - Add shorten ZIGIREPO panel       |
  |                           ZIGIREPS if Short command used   |
  |            10/31/19 LBD - Various Fixes :)                 |
  |            10/29/19 LBD - Add MultiDCB Support             |
  |            10/24/19 HBK - Also source ~/.profile if exists |
  |            10/24/19 LBD - Change 2 routines to procedure   |
  |                         - Add Commit message               |
  |            10/21/19 LBD - Use PARSE SOURCE for hlq         |
  |            10/20/19 HBK - Fix LMM things :)                |
  |            10/19/19 LBD - Better prefix, scrolling etc.    |
  |            10/17/19 HBK - Add back LMM, cleanup code       |
  |            09/30/19 HBK - Major rewrite :)                 |
  |            07/24/19 HBK - Some git functions               |
  |            06/15/19 HBK - Autofind git binary              |
  |            06/14/19 LBD - Major updates                    |
  |            06/12/19 LBD - Major updates                    |
  |            06/11/19 LBD - Creation                         |
  |                                                            |
  | ---------------------------------------------------------- |
  |    ZIGI - the z/OS ISPF Git Interface                      |
  |    Copyright (C) 2020-2023 - Henri Kuiper and Lionel Dyck  |
  |                                                            |
  |    This program is free software: you can redistribute it  |
  |    and/or modify it under the terms of the GNU General     |
  |    Public License as published by the Free Software        |
  |    Foundation, either version 3 of the License, or (at     |
  |    your option) any later version.                         |
  |                                                            |
  |    This program is distributed in the hope that it will be |
  |    useful, but WITHOUT ANY WARRANTY; without even the      |
  |    implied warranty of MERCHANTABILITY or FITNESS FOR A    |
  |    PARTICULAR PURPOSE.  See the GNU General Public License |
  |    for more details.                                       |
  |                                                            |
  |    You should have received a copy of the GNU General      |
  |    Public License along with this program.  If not, see    |
  |    <https://www.gnu.org/licenses/>.                        |
  * ---------------------------------------------------------- */
  parse arg start_option

  parse value '' with null repo_ztdsels fetch_flag dovetail_dir codep ,
                      dovestat created reset_env

  /* ------------------------------------------ *
  | ISPExec is our default host environment    |
  * ------------------------------------------ */
  Address ISPExec
  'Control Errors Return'

  /* ============================================================== */
  /* ======== main flow          ================================== */
  /* ============================================================== */

  call init_ispf
  call display_splash
  call enable_rfind
  call init_git
  call init_repo

  /* ------------------------------------------ *
  | Handle zigiprim panel                       |
  * ------------------------------------------ */
  do forever
     check_flag = 1
     'vget (showst) profile'
     show_status = showst
    /* repo was not specified on start command ? */
    if szcmd = null then do
      call display_zigiprim
      /* end selected, exit ZIGI */
      if result > 4 then leave
    end

    /* repo was specified on start command, bypass panel ? */
    if szcmd /= null then do
      zcmd = szcmd
      szcmd = null
    end

    /* uppercase translate the command part of the zcmd, leaving rest asis */
    zcmd = strip(translate(word(zcmd,1)) subword(zcmd,2))

    /* turn L(ocate) into F(ind) */
    if word(zcmd,1) = 'L' then
    zcmd = 'F' subword(zcmd,2)

    /* --------------------------------- *
    | Show popup with valid menu options |
    * --------------------------------- */
    if abbrev('O',word(zcmd,1),1) = 1 then call display_zigioprm
    if zcmd = '/' then call display_zigioprm

    /* ------------------------ *
    | Select a repo by command |
    * ------------------------ */
    if abbrev('SELECT',word(zcmd,1),1) = 1 then call handle_zigiprim_select

    /* -------------- *
    | Process a Find |
    * -------------- */
    if zcmd = 'RFIND' then do
      zcmd = 'FIND' fstring
      rfs  = rowcnt
    end
    else rfs = 0
    if abbrev('FIND',word(zcmd,1),1) = 1 then call handle_zigiprim_find

    parse value '' with fulldsn dsn defcpush defruid
    /* Get the row after the clear to get variables */
    'tbget zigirepo'
    if defcpush = 'Y' then zpush = 'Y'
    else zpush = 'N'

    /* -------------------------------- *
    | Define Set as an alias of Config |
    * -------------------------------- */
    if abbrev('SET',zcmd,2) = 1 then zcmd = 'CONFIG'

    /* handle remaining primairy commands */
    if zcmd /= null then
    Select
      When abbrev('GITENV',zcmd,4) = 1 then call handle_gitenv
      When abbrev('GITINFO',zcmd,4) = 1 then call display_gitinfo
      When abbrev('CONNECT',zcmd,2) = 1 then call handle_zigiprim_connect
      When abbrev('CREATE',zcmd,2) = 1 then call handle_zigiprim_create
      When abbrev('CLONE',zcmd,2) = 1 then call handle_zigiprim_clone
      When abbrev('CONFIG',zcmd,2) = 1 then call handle_zigiprim_config
      When abbrev('GITHELP',word(zcmd,1),4) = 1 then
      Address TSO '%githelp' subword(zcmd,2)
      When abbrev('LOCAL',zcmd,2) = 1 then call handle_zigiprim_local
      When abbrev('SORT',word(zcmd,1),2) = 1 then call handle_zigiprim_sort
      When abbrev('SSH',zcmd,2) = 1 then call handle_zigiprim_ssh
      When zcmd = 'VIEWD' then call view_debug
      Otherwise do
        rc = zigiexit(1 zcmd)
        if rc >= 12 then
        if zcmd /= null then do
          zerrsm = 'Unknown'
          zerrlm = zcmd 'is not a recognized command.'
          'setmsg msg(isrz003)'
        end
      end
    end

    /* handle line commands */
    if zsel = '/' then do
      call pfshow 'off'           /* make sure pfshow is off */
      'Addpop row(4) column(6)'
      'Display Panel(zigirprm)'
      'rempop'
      call pfshow 'reset'         /* restore pfshow setting */
    end

    if zsel /= null then
    Select
      When zsel = 'I' then call handle_zigiprim_lcmd_i
      When zsel = 'S' then call select_repo
      When zsel = 'V' then
      'SELECT PGM(ISRDSLST) PARM(UDL' localrep'/'zigirep') SUSPEND'
      When zsel = 'D' then call handle_zigiprim_lcmd_d
      Otherwise do
        zerrsm = 'Unknown'
        zerrlm = zsel 'is not a recognized command.'
        'setmsg msg(isrz003)'
      end
    End
  end

Done:
  if rtbl_open = 1 then
  'tbend' rtbl
  'tbclose zigirepo'

  /* ----------------------------------------------------------- *
  | If the ZIGIDEBG DD was present and the debugging was in use |
  | then display a list of debug files using the UDList (3.17)  |
  | utility.                                                    |
  * ----------------------------------------------------------- */
  if zigidebg = 1 then
  if zigidebg_use = 1 then do
    "Select Pgm(isrdslst) Parm(UDL ~/zigidebug*) SUSPEND"
  end
  Exit 0

  /* ============================================================== */
  /* ======== main initialization functions       ================= */
  /* ============================================================== */

init_repo:
  /* ---------------------------------------- *
  | Open (or create and open) the Repo Table |
  * ---------------------------------------- */
  isptabl = 'ISPPROF'
  'TBOpen zigirepo Library('isptabl') Write Share'
  if rc > 0 then do
    if rc = 8 then call create_zigirepo
    if rc > 8 then do
      'setmsg msg(isrz003)'
    end
  end

  /* --------------------------------------------- *
  | Test to see if the ZIGIREPO table is for V2R0 |
  | and if not upgrade it.                        |
  * --------------------------------------------- */
  call test_repo_table_state

  repo_top = 1
  'tbtop zigirepo'
  'vget (defrsort srr src srp srl) profile'
  if words(defrsort) = 2 then defrsort = 'zigirep,c,a'
  if defrsort = null then defrsort = 'zigirep,c,a'
  'vput (defrsort) profile'
  'TBSort zigirepo Fields('defrsort')'
  parse value '' with zsel szcmd
  if start_option /= null
  then if translate(start_option) /= 'S' then
  szcmd = 'S' start_option

  /* Panel for when there are no repos in profile yet */
  'TBStats zigirepo rowcurr('tr')'
  if tr = 0 then do
    call pfshow 'off'           /* make sure pfshow is off */
    'Addpop row(4) column(6)'
    'Display Panel(zigi1st)'
    'rempop'
    call pfshow 'reset'         /* restore pfshow setting */
  end
  Return

  /* ------------------------------ *
  | Populate the SortDate variable |
  * ------------------------------ */
set_sortdate:
  sortdate = date('b')''right(time('s')+100000,5)
  return

  /* ---------------------------- *
   | Display ZIGI/Git Information |
   * ---------------------------- */
display_gitinfo:
  x = bpxwunix('df -k' zigigitl,,so.,se.)
  gitzfs = word(so.2,2)
  gitzfs = strip(translate(gitzfs,' ','()'))
  call pfshow 'off'           /* make sure pfshow is off */
  'addpop row(4)'
  'display panel(zigiginf)'
  'rempop'
  call pfshow 'reset'         /* restore pfshow setting */
  return

  /* ------------------------------------------- *
  | Handle zigiprim panel primary command O      |
  * ------------------------------------------- */
display_zigioprm:
  parse value '' with findstr selfind
  if pos('.',zcmd) > 0 then
  parse value zcmd with x'.'zcmd
  call pfshow 'off'           /* make sure pfshow is off */
  'Addpop row(4) column(6)'
  'Display Panel(zigioprm)'
  'rempop'
  call pfshow 'reset'         /* restore pfshow setting */
  if findstr /= null
  then zcmd = 'F' findstr
  if selfind /= null
  then zcmd = 'S' selfind
  Return

  /* ------------------------------------------- *
  | Display zigiprim panel                       |
  * ------------------------------------------- */
display_zigiprim:
  parse value '' with zsel row readonly
  fetch_flag = 0
  zigpass = 'PASSTHRU'
  'vput (zigpass) shared'
  'TBTop zigirepo'
  'tbskip zigirepo number('repo_top')'
  localrep = null
  'vput (localrep) shared'
  'tbdispl zigirepo panel(zigiprim)'
  trc = rc
  zigpass = null
  'vput (zigpass) shared'
  if trc > 4 then Return trc

  if ztdsels = 0 then
  if pnsdef = 'P' then do
    if row = 0 then zcmd = 'O'
    if row > 0 then zsel = '/'
  end

  repo_top = ztdtop
  if row = 0 then zsel = null
  if row <> null then
  if row > 0 then do
    'TBTop zigirepo'
    'TBSkip zigirepo Number('row')'
  end
  Return

  /* ---------------------------------------------------------- *
  | See if we have git installed, have a public key, have a    |
  | correct env and have user.name and user.email set          |
  * ---------------------------------------------------------- */
init_git:
  /* ------------------------------------ *
  | define our working default variables |
  * ------------------------------------ */
  zhtop = 'ZIGIHINT'
  zerrhm   = 'zigih000'
  zerralrm = 'NO'
  zerrtp   = 'NOTIFY'
  zs1 = 'Preparing the ZIGI environment for use'
  zs2 = 'Please standby'
  call do_popup

  /* See if we've a custom env file in profile already */
  'vget (gitenv) profile'
  call getenv

  keyfile = home'/.ssh/id_rsa.pub'
  rtbl = 'ZIGL'random(9999)
  rtll = 'ZIGM'random(9999)
  rtbb = 'ZIGB'random(9999)
  rtbl_open = 0
  rtll_open = 0
  combine.0 = 0
  zigi_offline = 0

  /* ------------------------------------ *
  | Let's try to find git.               |
  * ------------------------------------ */
  zs1 = 'Checking if you have git installed'
  zs2 = 'Please standby'
  call do_popup

  x   = docmd('command -v git')

  x = so.0
  if so.0 > 0 then do
    zigigitl = strip(so.x)
    'vput (zigigitl) profile'
  end
  else do
    'vget (gitenv) profile'
    x = handle_gitenv()
    if gitenv_rc > 0 then exit 0
    if so.0 = 0 then do
      /* Nope that file is not correct. removing from profile */
      zs1 = "The env file ("gitenv") does not point me to"
      zs2 = "git :( Please rerun ZIGI and specify a valid"
      zs3 = "environment file."
      zs4 = 'Press Enter to exit and try again.'
      call do_popup4p
      parse value '' with zs3
      'verase (gitenv) profile'
      exit(0)
    end
  end

  x = docmd('git --version')
  required_version = '2.26'
  x = so.0
  parse var so.x 'git' 'version' version'_'subversion
  gitver = version
  'vput (gitver) shared'
  version = strip(version,'B')
  if version < required_version then do
    zs1 = "Your git version is not at the minimum required level"
    zs2 = "Your level    : "version
    zs3 = "Required level: "required_version
    zs4 = 'Press Enter to exit and install the correct version.'
    call do_popup4p
    exit 8
  end
  /* ------------------------------------------ *
  | Check for GIT Userid and if not found      |
  | then prompt for it along with a GIT E-Mail |
  | Find the SSH key and if not there generate |
  * ------------------------------------------ */
  zs1 = 'Checking for user.name and user.email'
  zs2 = 'Please standby'
  call do_popup
  x = docmd('git config --global user.name')
  if x = 0 then do
    x = so.0
    zigiuid = so.x
  end
  else do
    zigiuid = null
  end
  x = docmd('git config --global user.email')

  if x = 0 then do
    x = so.0
    zigimail = so.x
  end
  else do
    zigimail = null
  end
  cmd = 'cat 'home'/.ssh/id_rsa.pub'
  x = docmd(cmd)
  if x > 0 then do
     no_key = 1
     call do_keygen
     call handle_zigiprim_ssh
     end
  old_zigiuid = zigiuid
  old_zigimail = zigimail

  'vget (mgen extfile exitp showst) profile'
  if pos(extfile,'YN') = 0 then do
    extfile = 'N'
    'vput (extfile) profile'
  end
  if pos(exitp,'YN') = 0 then do
    exitp = 'N'
    'vput (exitp) profile'
  end

  Select
    When mgen = null then hit = 0
    when zigiuid = null then hit = 0
    when zigimail = null then hit = 0
    Otherwise hit = 1
  end
  do forever
    if hit = 1 then leave
    sl = mgen()
    'Display Panel(zigiset)'
    if rc > 0 then leave
    'vput (mgen showst exitp extfile) profile'
    call update_config
    if zigiuid /= null
    then if zigimail /= null
    then if zigissh /= null
    then do forever
      zcmd = null
      'Display Panel(zigisshk)'
      if rc > 0 then do
        hit = 1
        leave
      end
    end
  end

  Return

  /* ---------------------------------------------------------- *
  | Enable RFIND (Repeat Find) by adding an RFIND entry to the |
  | active site command table with a symbolic that will be     |
  | changed to PASSTHRU prior to each TBDISPL and back to null |
  | after. This allows RFIND to be passed to our applicaiton.  |
  * ---------------------------------------------------------- */
enable_rfind:

  zctverb  = "RFIND"
  zcttrunc = 0
  zctact   = "&ZIGPASS"
  zctdesc  = "RFIND for ZIGI Dialog"
  'vget (zsctpref)'
  if zsctpref = null
  then zsctpref = 'ISP'
  ctab = zsctpref'cmds'
  'tbtop' ctab
  'tbscan' ctab 'arglist(zctdesc) condlist(EQ) Next'
  if rc > 0 then 'tbadd' ctab
  zigpass = null
  'vput (zigpass)'
  Return

  /* ----------------------------------------------------- *
  | Display and handle the splash screen                  |
  * ----------------------------------------------------- */
display_splash:
  /* ---------------------------------------------------------------- *
  | Running under the ZIGI ISPF Application ID so let's do some work |
  * ---------------------------------------------------------------- */
  parse value '' with zcmd zsel
  year = word(date('n'),3)
  zigtitle = '(ZIGI' ver')'
  'vput (zigtitle ver) shared'
  'vget (bypass pnsdef) profile'
  if pnsdef = null then do
    pnsdef = 'S'
    'vput (pnsdef) profile'
  end
  if translate(start_option) = 'S' then bypass = 'N'
  if bypass /= 'Y' then do
    'display panel(zigispls)'
    if rc = 8 then exit
    'vput (bypass) profile'
    if bypasso /= 'Y' then
    if bypass = 'Y' then do
      zs1 = 'The splash screen will no longer display per your request.'
      zs2 = ' '
      zs3 = 'Start ZIGI with a parm of S to restore.'
      zs4 = '--- Press Enter to continue.'
      call do_popup4p
    end
  end
  Return

  /* ----------------------------------------------------- *
  | Initialize the ispf environment and make sure we      |
  | are running under the ZIGI applid                     |
  * ----------------------------------------------------- */
init_ispf:
  'vget (zapplid)'

  /* ----------------------------------------------------- *
  | Get the Active HLQ for use with the ALTLIB and LIBDEF |
  | of the ZIGI libraries.                                |
  | 1st Get the active exec library or dd                 |
  * ----------------------------------------------------- */
  parse source TSO Type exec_name DDName exec NameO Env Addr Token
  if exec = '?' then do
    x = listdsi(ddname 'FILE')
    exec = sysdsname
  end
  /* ------------------------------------------ *
  | Now extract the HLQ for the Panels Library |
  * ------------------------------------------ */
  zigihlq = translate(exec,' ','.')
  zigihlq = subword(zigihlq,1,words(zigihlq)-1)
  zigihlq = translate(zigihlq,'.',' ')
  /* ---------------------------------------------- *
  | Fully qualify the EXEC and PANELS library dsns |
  * ---------------------------------------------- */
  exec = "'"exec"'"
  panels = "'"zigihlq".PANELS'"

  /* ----------------------------------------------------------- *
  | Check for running under the ZIGI ISPF application ID and if |
  | not then recurse into it.                                   |
  * ----------------------------------------------------------- */
  if zapplid <> "ZIGI" then do
    Address ISPExec
    /* ---------------------------------------- *
    | If panels/exec then libdef and/or altlib |
    | but only if not under ZIGI applid.       |
    * ---------------------------------------- */
    if panels /= null then
    'libdef ispplib dataset id('panels') stack'
    if exec /= null then
    Address TSO 'altlib act application(exec) dataset('exec')'
    /* --------------------------------------- *
    | Make sure we are under the ZIGI applid  |
    * --------------------------------------- */
    "Select CMD("exec_name start_option") Newappl(ZIGI) Passlib scrname(ZIGI)"
    if panels /= null then
    'libdef ispplib'
    if exec /= null then
    Address TSO 'altlib deact application(exec)'
    exit 0
  end
  zigpass = null
  'vput (zigpass) shared'

  /* ----------------------------- *
   | Check for /ENV startup option |
   * ----------------------------- */
   if translate(start_option) = '/ENV' then do
      reset_env = 1
      start_option = null
      end

  /* ------------------------------ *
   | Check for /ENVR startup option |
   * ------------------------------ */
   if translate(start_option) = '/ENVR' then do
      gitenv = null
      'verase (gitenv) profile'
      start_option = null
      end

  parse value '' with null rx save_zigirep fulldsn cltime
  cscnt = 0
  cdrcnt = 0
  return

Init_Debug:
  /* ---------------------------------------- *
  | Check for ZIGIDEBG DD for debug purposes |
  * ---------------------------------------- */
  x = listdsi('ZIGIDEBG' 'FILE')
  if x > 0 then if sysreason = 3 then do
    zigidebg = 1
    ztime = time()
    ztime = left(ztime,2)''substr(ztime,4,2)''substr(ztime,7,2)
    debugfil = home'/zigidebug.d'date('j')'.t'ztime
    Address ISPExec ,
    'vput (debugfil)'
  end
  else zigidebg = 0
  Return

  /* ------------------------------------- *
  | Select the Current Repository Routine |
  * ------------------------------------- */
Select_Repo:
  zigidate = date('n')
  call set_sortdate
  call get_default_codepage
  'tbmod zigirepo order'
  x = debug('Getting binfiles:' reponame)
  drop binfiles.
  call get_binfiles
  x = debug('Got 'binfiles.0' binfiles')
  x = debug('Selecting repo:' reponame)
  'vput (defruid)'
  call Work_With_Repo
  x = debug('Return from repo:' reponame)
  Return

  /* ------------------------------ *
  | Create the ZIGIREPO ISPF Table |
  * ------------------------------ */
Create_zigirepo:
  "TBCreate zigirepo Keys(zigikey)",
    "Names(zigirep localrep pdshlq qualignr zigidate defcpush" ,
    " sortdate defruid zigicat branch remote1 reponame)",
    'Library('isptabl') Write Share Replace'
  'vget (defrsort srr src srp srl) profile'
  if defrsort /= null then
  'TBSort zigirepo Fields('defrsort')'
  'TBSAVE zigirepo REPLCOPY LIBRARY('isptabl')'
  return

  /* ============================================================== */
  /* ======== zigiprim handling support functions ================= */
  /* ============================================================== */

  /* ------------------------------------------ *
  | Handle zigiprim panel linecommand i         |
  * ------------------------------------------ */
handle_zigiprim_lcmd_i:
  call pfshow 'off'           /* make sure pfshow is off */
  readonly = check_read_only()
  if readonly = 1
  then zro = 'Yes'
  else zro = 'No'
  'addpop row(3) column(1)'
  'display panel(zigiinfo)'
  'rempop'
  call pfshow 'reset'         /* restore pfshow setting */
  zsel = null
  Return

  /* ------------------------------------------ *
  | Handle zigiprim panel linecommand d         |
  * ------------------------------------------ */
handle_zigiprim_lcmd_d:
  readonly = check_read_only()
  parse value '' with delcz delcg delco delcf delzd delgit
  call pfshow 'off'           /* make sure pfshow is off */
  'Addpop row(3) column(10)'
  'Display panel(zigidelc)'
  drc = rc
  'rempop'
  call pfshow 'reset'         /* restore pfshow setting */
  if drc = 0 & delcf = 'Y' then do
    'tbdelete zigirepo'
    'TBSave zigirepo replcopy library('isptabl')'
    if delgit = 'N' then do
      cmd = 'cd 'localrep'/'zigirep' && rm -rf .git .gitattributes .zigi'
      x = docmd(cmd)
      if x = 0 then do
        zerrsm = 'Deleted.'
        delcz = 'Repo removed from ZIGI, .zigi files deleted.'
        delcg = 'Git files removed.'
        del_refd = zigirefd(localrep'/'zigirep pdshlq 1 'D')
      end
    end
    if readonly = 1 then delzd = 'Y'
    if delzd = 'N' then do
      delzd = 'The z/OS datasets have been deleted.'
      address syscall 'readdir' localrep'/'zigirep d.
      do id = 1 to d.0
        if left(d.id,1) = '.' then iterate
        deldsn = Add_DSN_HLQ(word(d.id,1))
        if dsnvalid(deldsn) = 'NO' then iterate
        call outtrap 'x.'
        address tso 'delete' deldsn
        call outtrap 'off'
      end
    end
    else delzd = 'The z/OS datasets were NOT deleted.'
    if delco = 'N' then do
      cmd = 'cd' localrep' && rm -rf 'zigirep
      x = docmd(cmd)
      delco = 'The local repository has been deleted from OMVS.'
    end
    else delco = 'The local repository was NOT deleted from OMVS.'
    zerrlm = left(delcz,76) left(delcg,76) left(delco,76) ,
      left(localrep'/'zigirep,76) left(delzd,76)
    'setmsg msg(isrz003)'
  end
  else do
    zerrsm = 'Retained.'
    zerrlm = 'The local repository was NOT deleted from ZIGI, from' ,
      'OMVS' localrep'/'zigirep', or from z/OS.'
    'setmsg msg(isrz003)'
  end
  Return

  /* ------------------------------------------ *
  | Handle zigiprim panel primary command ssh   |
  * ------------------------------------------ */
handle_zigiprim_ssh:
  do forever
    zcmd = null
    'display panel(zigisshk)'
    if rc > 0 then leave
    if abbrev('REGEN',zcmd,3) = 1 then do
       'addpop'
       'display panel(zigikgen)'
       krc = rc
       'rempop'
       if krc > 0 then do
          zerrsm = 'Cancelled.'
          zerrlm = 'Regeneration of the SSH Keys cancelled.'
          'setmsg msg(isrz003)'
          end
       else if kgen = 'Y'
            then call build_ssh
       end
  end
  Return

  /* ------------------------------------------ *
  | Handle zigiprim panel primary command sort  |
  * ------------------------------------------ */
handle_zigiprim_sort:
  zcmd = translate(zcmd)
  defrsort = null
  parse value zcmd with . skey sopt skey2 sopt2
  if skey = null then do
    call pfshow 'off'           /* make sure pfshow is off */
    'Addpop row(4) column(6)'
    'Display Panel(zigipsrt)'
    'Rempop'
    call pfshow 'reset'         /* restore pfshow setting */
  end
  if sopt = '' then
  if lsopt = 'A' then sopt = 'D'
  else sopt = 'A'
  select
    when abbrev('REPOSITORY',skey,1) = 1 then
    skey = 'zigirep'
    when abbrev('CATEGORY',skey,1) = 1 then
    skey = 'zigicat'
    when abbrev('PREFIX',skey,1) = 1 then
    skey = 'pdshlq'
    when abbrev('LAST',skey,1) = 1 then
    skey = 'sortdate'
    when abbrev('DATE',skey,1) = 1 then
    skey = 'sortdate'
    otherwise skey = 'zigirep'
  end
  select
    when abbrev('REPOSITORY',skey2,1) = 1 then
    skey2 = 'zigirep'
    when abbrev('CATEGORY',skey2,1) = 1 then
    skey2 = 'zigicat'
    when abbrev('PREFIX',skey2,1) = 1 then
    skey2 = 'pdshlq'
    when abbrev('LAST',skey2,1) = 1 then
    skey2 = 'sortdate'
    when abbrev('DATE',skey2,1) = 1 then
    skey2 = 'sortdate'
    otherwise nop
  end
  if pos('zigirep',skey skey2)  > 0
  then srr = 'white'
  else srr = 'blue'
  if pos('zigicat',skey skey2)  > 0
  then src = 'white'
  else src = 'blue'
  if pos('pdshlq',skey skey2)   > 0
  then srp = 'white'
  else srp = 'blue'
  if pos('sortdate',skey skey2) > 0
  then srl = 'white'
  else srl = 'blue'
  if left(sopt,1) = 'D' then sopt = 'D'
  else sopt = 'A'
  if skey2 /= null then do
    if left(sopt2,1) = 'D' then sopt2 = 'D'
    else sopt2 = 'A'
  end
  defrsort = skey',c,'sopt
  if skey2 /= null then
  defrsort = defrsort','skey2',c,'sopt2
  'tbsort zigirepo fields('defrsort')'
  lsopt = sopt
  'vput (defrsort srr src srp srl) profile'
  Return

  /* ------------------------------------------ *
  | Handle zigiprim panel primary command local |
  * ------------------------------------------ */
handle_zigiprim_local:
  if zigtitle = 'Offline'
  then do
    zigtitle = '(ZIGI' ver')'
    zigi_offline = 0
  end
  else do
    zigtitle = 'Offline'
    zigi_offline = 1
  end
  'vput (zigtitle)'
  Return

  /* ------------------------------------------- *
  | Handle zigiprim panel primary command clone  |
  * ------------------------------------------- */
handle_zigiprim_clone:
  encoding = null
  call Clone_Repo
  zsel = null
  Return

  /* ------------------------------------------- *
  | Handle zigiprim panel primary command config |
  * ------------------------------------------- */
handle_zigiprim_config:
  do forever
    zcmd = null
    'vget (mgen pnsdef showst bypass) profile'
    sl = mgen()
    'display panel(zigiset)'
    if rc > 4 then do
       'vget (mgen pnsdef showst bypass) profile'
       return 8
       end
    'vput (mgen pnsdef showst bypass) profile'
    call update_config
    if rc = 0 | rc = 8 then leave
  end
  Return

  /* -------------------------------------------- *
  | Handle zigiprim panel primary command connect |
  * -------------------------------------------- */
handle_zigiprim_connect:
  x = Connect_Repo()
  crflag = 1
  if x = 0 then do
    zcmd = null
    call work_with_repo
    zsel = null
  end
  Return

  /* ------------------------------------------- *
  | Handle zigiprim panel primary command create |
  * ------------------------------------------- */
handle_zigiprim_create:
  x = Create_Repo()
  crflag = 1
  created = 1
  if x = 0 then do
    zcmd = 'ADDDSN'
    call work_with_repo
    zsel = null
  end
  Return

  /* ------------------------------------------- *
  | Handle zigiprim panel primary command find   |
  * ------------------------------------------- */
handle_zigiprim_find:
  fstring = translate(word(zcmd,2))
  zcmd = null
  find = null
  fwrap = 0
  if fstring = null then do
    call pfshow 'off'           /* make sure pfshow is off */
    'Addpop row(4) column(6)'
    'Display Panel(zigifind)'
    drc = rc
    'rempop'
    call pfshow 'reset'         /* restore pfshow setting */
    if drc > 0 then find = null
    fstring = find
  end
  if fstring /= null then do
    rowcnt = 0
    'tbtop zigirepo'
    if rfs > 0 then do
      'tbskip zigirepo number('rfs')'
      rowcnt = rfs
    end
    do forever
      'tbskip zigirepo'
      if rc > 0 then do
        if rfs > 0 then do
          rfs = 0
          'tbtop zigirepo'
          'tbskip zigirepo'
          rowcnt = 0
          fwrap = 1
        end
        else do
          zerrsm = 'Not Found'
          zerrlm = fstring 'not found.'
          'setmsg msg(isrz003)'
          Return
        end
      end
      rowcnt = rowcnt + 1
      'tbget zigirepo'
      if pos(fstring,translate(reponame pdshlq zigicat)) > 0 then do
        repo_top = rowcnt
        if fwrap = 1
        then zerrsm = 'Wrapped.'
        else zerrsm = 'Found.'
        zerrlm = fstring 'found in row' rowcnt + 0
        'setmsg msg(isrz003)'
        Return
      end
    end
  end
  Return

  /* ------------------------------------------- *
  | Handle zigiprim panel primary command select |
  * ------------------------------------------- */
handle_zigiprim_select:
  x = debug('Selecting repo via command:'zcmd)
  zerrsm = null
  fstring = word(zcmd,2)
  zcmd = null
  if fstring = null then do
    call pfshow 'off'           /* make sure pfshow is off */
    'addpop row(3) column(4)'
    'display panel(zigisel)'
    drc = rc
    'rempop'
    call pfshow 'reset'         /* restore pfshow setting */
    if fstring = null then drc = 4
    if drc > 0 then  do
      zerrsm = 'Canceled.'
      zerrlm = 'Select canceled.'
      'setmsg msg(isrz003)'
    end
  end
  if zerrsm = null then do
    'tbtop zigirepo'
    do forever
      'tbskip zigirepo'
      if rc > 0 then do
        zerrsm = 'Not Found'
        zerrlm = fstring 'repository not found. Verify the spelling and' ,
          'case.'
        'setmsg msg(isrz003)'
        return
      end
      if translate(fstring) /= translate(reponame) then iterate
      'tbget zigirepo'
      if defcpush = 'Y' then zpush = 'Y'
      else zpush = 'N'
      zcmd = null
      call select_repo
      parse value '' with zsel zcmd
      return
    end
  end
  Return

  /* ============================================================== */
  /* ======== repo handling      ================================== */
  /* ============================================================== */

  /* --------------------------------- *
  | Work with the selected repository |
  * --------------------------------- */
Work_With_Repo:
  arg wwr_opt

  /* -------------------------------------------------- *
  | WWR_init will also call update_metadata             |
  | check command will call work_with_repo recursively  |
  | with check_flag = 1 to force recheck of ispf dsns   |
  | If called with option then init and then return     |
  * -------------------------------------------------- */
  call WWR_init
  if wwr_opt /= null then return
  /* -------------------------------- *
  | Process the Repository Data Sets |
  * -------------------------------- */
  do forever
    x = WWR_display_zigirepo()
    if x > 3 then do
       'tbend' rtbl
       return
       end
    repo_ztdsels = ztdsels
    drop so. se.
    zigi_changed = 0

    /* translate primary command to upper case */
    zcmd = translate(zcmd)

    call WWR_handle_options

    /* -------------- *
    | Process a Find |
    * -------------- */
    if zcmd = 'RFIND' then do
      zcmd = 'FIND' fstring
      rfs  = rowcnt
    end
    else rfs = 0
    if abbrev('FIND',word(zcmd,1),1) = 1 then call WWR_handle_find

    if abbrev('FLOW',word(zcmd,1),2) = 1 then call WWR_handle_flow

    /* handle other zcmds */
    if zcmd /= null then
    Select
      When abbrev('CHECK',zcmd,3) = 1 then do
        call WWR_handle_check
        return
      end
      When abbrev('BRANCH',zcmd,2) = 1 then call WWR_handle_branch
      When abbrev('CONVREPO',zcmd,4) = 1 then call WWR_handle_convrepo
      When abbrev('GITINFO',zcmd,4) = 1 then call display_gitinfo
      /* ----------------- *
      | Git command prompt |
      * ------------------ */
      When abbrev('GITCMD',zcmd,4) = 1 then call do_gcmd
      When abbrev('GITHELP',word(zcmd,1),4) = 1 then
      Address TSO '%githelp' subword(zcmd,2)
      When abbrev('GITLOG',zcmd,2) = 1 then call do_gitlog
      When abbrev('DIFF',word(zcmd,1),1) = 1 then call WWR_handle_diff
      When abbrev('INFO',zcmd,2) = 1 then call WWR_handle_info
      When abbrev('SET',zcmd,1) = 1 then call do_rset
      /* ---------------------------- *
      | View (UDList) the repository |
      * ---------------------------- */
      When abbrev('VIEW',zcmd,1) = 1 then
      'SELECT PGM(ISRDSLST) PARM(UDL' localrep'/'zigirep') SUSPEND'
      When abbrev('MERGE',zcmd,2) = 1 then call WWR_handle_merge
      When abbrev('NETWORK',zcmd,2) = 1 then call WWR_handle_network
      When abbrev('PUSH',zcmd,2) = 1 then call WWR_handle_push
      When abbrev('PULL',zcmd,3) = 1 then call WWR_handle_pull
      When abbrev('FETCH',zcmd,2) = 1 then call WWR_handle_fetch
      When abbrev('README',zcmd,4) = 1 then do
        call WWR_handle_readme
        call WWR_handle_check
        return
        end
      When abbrev('REPLACE',zcmd,3)  = 1 then call WWR_handle_replace
      When abbrev('EXTRACT',zcmd,2)  = 1 then call WWR_handle_extract
      When abbrev('STASH',zcmd,4)    = 1 then call stash_it
      When abbrev('SNAPSHOT',zcmd,2) = 1 then call WWR_handle_snapshot
      When abbrev('TAG',zcmd,2)      = 1 then call WWR_handle_tag
      When abbrev('TAGLIST',zcmd,2)  = 1 then call do_taglist
      When zcmd = 'AD'                   then call WWR_handle_adddsn
      When zcmd = 'ADS'                  then call WWR_handle_adddsn
      When abbrev('ADDDSN',zcmd,4)   = 1 then call WWR_handle_adddsn
      When zcmd = 'AA'                   then call WWR_handle_addall
      When abbrev('ADDALL',zcmd,3)   = 1 then call WWR_handle_addall
      When abbrev('STATUS',zcmd,2)   = 1 then call do_status
      When abbrev('GREP',zcmd,2)     = 1 then call WWR_handle_grep
      When abbrev('COMMIT',zcmd,3)   = 1 then call do_commit
      When abbrev('REMOTE',zcmd,3)   = 1 then call WWR_handle_remote
      When abbrev('FLOWSEL',zcmd,5)  = 1 then call WWR_handle_flowsel
      When abbrev('FLOWGO',zcmd,5)   = 1 then call WWR_handle_flowgo
      When abbrev('FLOWEND',zcmd,5)  = 1 then call WWR_handle_flowend
      When zcmd = 'STASHL' then call stash_list
      when zcmd = 'VIEWD' then call view_debug
      Otherwise do
        rc = zigiexit(2 zcmd)
        if rc >= 12 then
        do
          zerrsm = 'Unknown'
          zerrlm = zcmd 'is not a recognized command.'
          'setmsg msg(isrz003)'
        end
      end
    end

    if zsel = '/' then do
      call pfshow 'off'           /* make sure pfshow is off */
      'Addpop row(3) column(4)'
      'Display Panel(zigirrep)'
      'rempop'
      call pfshow 'reset'         /* restore pfshow setting */
    end

    /* flag for USS file or ZOS dataset */
    zosflg = 1
    if filetype = '(D)' then do
      if zsel = 'B' then zsel = 'S'
      if zsel = 'V' then zsel = 'S'
    end

    /* -------------------------------- *
    | Handle the linecommands           |
    * -------------------------------- */
    if zsel = 'E' then zsel = 'S'
    if zsel /= null then
    Select
      when zsel = 'D'  then call WWR_handle_lcmd_d
      When zsel = 'H'  then call WWR_handle_lcmd_h
      When zsel = 'B'  then call WWR_handle_lcmd_b
      When zsel = 'BL' then call WWR_handle_lcmd_bl
      When zsel = 'V'  then call WWR_handle_lcmd_v
      When zsel = 'RN' then call WWR_handle_lcmd_rn
      When zsel = 'RM' then call WWR_handle_lcmd_rm
      When zsel = 'S' & left(fulldsn,1) /= "'" then
      call WWR_handle_lcmd_s_omvs
      When zsel = 'S' & zosflg = 1 then
      call WWR_handle_lcmd_s_mvs
      When zsel = 'A' then
      call WWR_handle_lcmd_a
      When zsel = 'U' then call WWR_handle_lcmd_u
      When zsel = 'Z' then call WWR_handle_lcmd_z
      Otherwise do
        zerrsm = 'Invalid.'
        zerrlm = zsel 'is not a valid selection value. Review the' ,
          'ISPF Tutorial using F1 for available line selection' ,
          'options.'
        'setmsg msg(isrz003)'
      end
    end
    if zigi_changed = 1 then
    if ztdsels = 1 then do
      'tbend' rtbl
      rtbl_open = 0
      zigi_changed = 0
      call update_status
      call work_with_repo
      return
    end
  end
  if zigi_changed = 1 then call work_with_repo
  return

  /* ============================================================== */
  /* ======== repo handling support functions ===================== */
  /* ============================================================== */

WWR_init:
  parse value '' with dsn dsnstat zsel
  list_top = 0
  crflag = 0
  remc = 'NO'
  x = debug('Working with Repo:' zigirep)
  readonly = check_read_only()
  'vput (readonly) shared'
  call get_dsn_info
  call update_repo_metadata
  if cltime /= null then do
    zerrsm  = 'Clone:' cltime
    zerrlm  = left('Cloning completed for:' zigirep,76) ,
      'Total time to clone was:' cltime
    'setmsg msg(isrz003)'
    cltime = null
  end
  'vput (localrep zigirep) shared'
  'tbsort' rtbl 'Fields(dsn,c,a)'
  'tbtop' rtbl
  repo_ztdsels = 0
  rtop = 0
  repo_save = 0
  Return

WWR_display_zigirepo:
  parse value '' with zsel row
  check_flag = 0
  ztdsels = repo_ztdsels
  if zcmd /= 'ADDDSN' then do
    parse value '' with zsel zcmd row zcmd
    if ztdsels > 1
    then 'TBdispl' rtbl
    else do
      zigpass = 'PASSTHRU'
      'vput (zigpass) shared'
      'tbtop' rtbl
      'tbskip' rtbl 'Number('rtop')'
      'TBdispl' rtbl 'Panel(zigirepo)'
      rtop = ztdtop
    end
    trc = rc
    result = trc
    zigpass = null
    'vput (zigpass) shared'
    if trc > 4 then do
       if exitp = 'N' then return trc
       call pfshow 'off'           /* make sure pfshow is off */
       answer = null
       'Addpop row(6) column(16)'
       'Display Panel(zigiextp)'
       prc = rc
       'Rempop'
       call pfshow 'reset'         /* restore pfshow setting */
       if prc = 0 then return trc
       end
  end
  Return 0

WWR_handle_options:
  /* if no row selected and point of shoot default is P */
  /* show options panel or select pointed row and show  */
  /* options for that row                               */
  if ztdsels = 0 then
  if pnsdef = 'P' then do
    if row = 0 then zcmd = 'O'
    if row > 0 then zsel = '/'
  end

  if row = 0 then zsel = null
  if row <> null then
  if row > 0 then do
    "TBTop " rtbl
    "TBSkip" rtbl "Number("row")"
  end

  if pos('.',zcmd) > 0 then
  parse value zcmd with x'.'zcmd
  if pos(zcmd,'O/') > 0 then do
    call pfshow 'off'           /* make sure pfshow is off */
    'Addpop row(2)'
    'Display Panel(zigiorep)'
    'rempop'
    call pfshow 'reset'         /* restore pfshow setting */
  end
  Return

WWR_handle_find:
  fstring = translate(word(zcmd,2))
  zcmd = null
  find = null
  rwrap = 0
  if fstring = null then do
    call pfshow 'off'           /* make sure pfshow is off */
    'Addpop row(4) column(6)'
    'Display Panel(zigifind)'
    drc = rc
    'rempop'
    call pfshow 'reset'         /* restore pfshow setting */
    if drc > 0 then find = null
    fstring = find
  end
  rowcnt = 0
  'tbtop' rtbl
  if rfs > 0 then do
    'tbskip' rtbl 'number('rfs')'
    rowcnt = rfs
  end
  do forever
    'tbskip' rtbl
    if rc > 0 then do
      if rfs > 0 then do
        rfs = 0
        'tbtop' rtbl
        'tbskip' rtbl
        rowcnt = 0
        rwrap = 1
      end
      else do
        zerrsm = 'Not Found'
        zerrlm = fstring 'not found.'
        'setmsg msg(isrz003)'
        leave
      end
    end
    rowcnt = rowcnt + 1
    'tbget' rtbl
    if pos(fstring,translate(fulldsn)) > 0 then do
      rtop = rowcnt
      if rwrap = 0
      then zerrsm = 'Found.'
      else zerrsm = 'Wrapped.'
      zerrlm = fstring 'found in row' rowcnt '-' fulldsn
      'setmsg msg(isrz003)'
      leave
    end
  end
  Return

  /* -------- *
  | zigiFlow |
  * -------- */
WWR_handle_flow:
  if readonly = 1 then do
    zerrsm = 'Invalid.'
    zerrlm = 'Flow is not supported for ReadOnly Repositories.'
    'setmsg msg(isrz003)'
    return
  end
  call pfshow 'off'           /* make sure pfshow is off */
  'addpop row(3) column(4)'
  'display panel(zigiflow)'
  drc = rc
  'rempop'
  call pfshow 'reset'         /* restore pfshow setting */
  if drc > 0 then zcmd = null
  Return

WWR_handle_check:
  check_flag = 1
  call work_with_repo
  zsel = null
  Return

  /* -------------------------------- *
  | Branch dialog - create or change |
  * -------------------------------- */
WWR_handle_branch:
  if readonly = 1 then do
    zerrsm = 'Invalid.'
    zerrlm = 'Branching is not supported for ReadOnly Repositories.'
    'setmsg msg(isrz003)'
    return
  end
  x = check_clean()
  if x = 'NO' then do
    zs1 = 'Cannot checkout branch as it is not clean.'
    zs2 = 'Use the Status command and fix then try again.'
    call pfshow 'off'           /* make sure pfshow is off */
    'Addpop row(4) column(8)'
    'Display Panel(zigipop)'
    'Rempop'
    call pfshow 'reset'         /* restore pfshow setting */
    return
  end
  if words(save_zigirep) > 0 then do
    zerrsm = 'Invalid.'
    zerrlm = 'Branch is not supported in subdirectories.'
    'setmsg msg(isrz003)'
  end
  else call Branch_it
  Return

  /* ----------------------- *
  | Convert a non-ZIGI Repo |
  * ----------------------- */
WWR_handle_convrepo:
  parse value '' with zcmd ans
  'display panel(zigivcnv)'
  drc = rc
  if ans /= 'Y' then drc = 4
  if drc > 0 then do
    zerrsm = 'Canceled.'
    zerrlm = 'Conversion canceled.'
    'setmsg msg(isrz003)'
  end
  else do
    if branch = 'master' then do
      convdir = localrep'/'zigirep
      cmd = 'cd' convdir '&& git checkout -b zigi-master'
      x = docmd(cmd)
    end
    call convert_repo
    x = docmd(cmd)
    defcpush = 'N'
    call work_with_repo
  end
  Return

  /* ------------------------------------ *
  | Process the git diff command request |
  * ------------------------------------ */
WWR_handle_diff:
  diff = word(zcmd,2)
  if pos(diff,'12') = 0 then do
    call pfshow 'off'           /* make sure pfshow is off */
    'addpop row(3) column(2)'
    'display panel(zigidiff)'
    'rempop'
    call pfshow 'reset'         /* restore pfshow setting */
  end
  if diff = 1 then gcmd = 'git diff'
  else gcmd = 'git diff --cached'
  cmd = 'cd' localrep'/'zigirep '&&' gcmd
  x = docmd(cmd)
  if so.0 = 0 then do
    zerrsm = null
    zerrlm = 'No differences to display for:' gcmd
    'setmsg msg(isrz002)'
  end
  else call view_std 'B' 'V'
  return

  /* -------------------------------- *
  | View summary info of repository  |
  * -------------------------------- */
WWR_handle_info:
  if readonly = 1
  then zro = 'Yes'
  else zro = 'No'
  call pfshow 'off'           /* make sure pfshow is off */
  'addpop row(3) column(2)'
  'display panel(zigiinfo)'
  'rempop'
  call pfshow 'reset'         /* restore pfshow setting */
  Return

  /* -------------------------------- *
  | Merge a branch into current branch|
  * -------------------------------- */
WWR_handle_merge:
  zerrsm = null
  if readonly = 1 then do
    zerrsm = 'Invalid.'
    zerrlm = 'Merge is not supported for ReadOnly Repositories.'
    'setmsg msg(isrz003)'
    return
  end
  if words(save_zigirep) > 0 then do
    zerrsm = 'Invalid.'
    zerrlm = 'Merge is not supported in subdirectories.'
    'setmsg msg(isrz003)'
  end
  if zerrsm = null then x = Merge_it()
  if x > 0 then return x
  check_flag = 1
  call work_with_repo
  zsel = null
  Return

  /* -------------------------------- *
  | Show the network graph            |
  * -------------------------------- */
WWR_handle_network:
  cmd = 'cd' localdir' && git log --graph --oneline'
  cmd = cmd '--format="%h %<(50,trunc)%f"'
  x = docmd(cmd)
  vtype = 'graph'
  'vput (vtype) shared'
  if so.0 + se.0 > 1
  then call view_std 'B' 'V'
  vtype = null
  'vput (vtype) shared'
  Return

  /* -------------------------------- *
  | Push current branch to origin    |
  * -------------------------------- */
WWR_handle_push:
  if zigi_offline = 0 then call do_push
  else do
    zerrsm = 'Offline.'
    zerrlm = 'Push is not allowed when offline.'
    'Setmsg msg(isrz003)'
  end
  Return

  /* --------------------------------------------------------- *
  | Pull latest version of remote current branch from origin  |
  * --------------------------------------------------------- */
WWR_handle_pull:
  if zigi_offline = 1 then do
    zerrsm = 'Offline.'
    zerrlm = 'Pull is not allowed when offline.'
    'Setmsg msg(isrz003)'
  end
  else do
    call pop 'Pulling from remote'
    /* get the current commit hash */
    cmd = 'cd' localdir '&& git rev-parse HEAD'
    x = docmd(cmd)
    rev_head = so.1    /* save the current commit hash */

    cmd = 'cd' localdir' && git pull -v'
    x = docmd(cmd)
    /* Comment Start
    if x > 0 then call view_std 'B'
       Comment End */
    zerrsm = 'Pull Complete'
    zerrlm = 'The pull request completed. This is the pull report',
       'Close this report with F3 and the z/OS datasets will be',
       'updated.'
    'setmsg msg(isrz003)'
    call view_std 'B'
    parse value '' with pulldsns pullmems. deletes.
    deletes.0 = 0
    pulled = 0
    do pi = 1 to so.0
      if left(so.pi,1) /= ' ' then iterate
      if pos(' changed,',so.pi) > 0 then do
        pullmsg = so.pi
        pulled = 1
        iterate
      end
      if word(so.pi,1) = 'rename' then do
        if pos('/',so.pi) > 0 then do
          parse value so.pi with . dd'/{'dm '=>' nm'}' .
          dc = deletes.0 + 1
          deletes.dc = strip(dd)'/'strip(dm)
          deletes.0 = dc
          if wordpos(dd,pulldsns) = 0 then do
            pulldsns = pulldsns dd
            pullmems.dd = nm
          end
          else pullmems.dd = pullmems.dd nm
        end
        else do
          parse value so.pi with . dd '=>' nd .
          dc = deletes.0 + 1
          deletes.dc = strip(dd)
          deletes.0 = dc
          if wordpos(nd,pulldsns) = 0 then
          pulldsns = pulldsns nd
        end
      end
      if word(so.pi,1) = 'delete' then
      if word(so.pi,2) = 'mode' then do
        delds = word(so.pi,4)
        dhit = 1
        if left(delds,1) = '.' then dhit = 0
        if dhit = 1 then do
          dc = deletes.0 + 1
          if pos('/',delds) > 0 then do
            parse value delds with dd'/'dm
            if pos('.',dm) > 0 then do
              parse value dm with dm'.'.
              delds = dd'/'translate(dm)
            end
          end
          deletes.dc = delds
          deletes.0 = dc
          if pos('/',delds) = 0 then do
            wp = wordpos(delds,pulldsns)
            pulldsns = delword(pulldsns,wp,1)
          end
          else do
            parse value delds with dd'/'dm
            ext = zdsn.dd
            if ext = null
            then wp = wordpos(dm,pullmems.dd)
            else do
              dm = lower(dm'.'ext)
              wp = wordpos(dm,pullmems.dd)
            end
            pullmems.dd = delword(pullmems.dd,wp,1)
          end
        end
      end
      if left(so.pi,5) = 'From' then leave
      pidsn = word(so.pi,1)
      if left(pidsn,1) = '.' then iterate
      parse value pidsn with pidsn'/'pimem
      if wordpos(pidsn,pulldsns) = 0 then do
        pulldsns = pulldsns pidsn
        pullmems.pidsn = pimem
      end
      else pullmems.pidsn = pullmems.pidsn pimem
    end
    /* ------------------------------------------------- *
    | Validate all the Pulldsns and remove if not valid |
    * ------------------------------------------------- */
    do ip = words(pulldsns) to 1 by -1
      w = word(pulldsns,ip)
      if dsnvalid(w) = 'OK' then iterate
      pulldsns = delword(pulldsns,ip,1)
    end
    /* create the ispf variable with member names for
    the dataset using the dataset offset in pulldsns
    for the variable suffix */
    if qualignr = 0
    then delhlq = pdshlq
    else do
      delhlq = translate(pdshlq,' ','.')
      if qualignr /= '*' then
      delhlq = subword(delhlq,1,qualignr)
      delhlq = translate(delhlq,'.',' ')
    end
    do zz = 1 to words(pulldsns)
      zd = word(pulldsns,zz)
      zw = words(pullmems.zd)
      ldsn = "'"delhlq"."zd"'"
      x = listdsi(ldsn "dir")
      /* check if a PDSE and bypass the full Replace or if not
      a PDSE then check of more than 25% of members being
      updated and if so then nullify the member list so a full
      Replace will occur for the dataset */
      if x = 0 then
      if sysmembers /= null then
      if sysadirblk /= 'NO_LIM' then
      if sysmembers/zw < 4 then pullmems.zd = ''
      interpret 'zv'zz '= (pullmems.zd)'
      'vput zv'zz
    end
    if pulldsns /= null then do
      call Replace localrep zigirep pdshlq qualignr pulldsns
      if replace_state = 1 then do
        call reverse_pull
        return
      end
      'Verase pulldsns Both'
      call outtrap 'x.'
      if deletes.0 > 0 then do dc = 1 to deletes.0
        if pos('/',deletes.dc) = 0
        then do
          delds =  "'"pdshlq"."deletes.dc"'"
          dm.dc = delds
          Address TSO 'Delete' delds
          cmd = 'cd' localrep'/'zigirep
          cmd = cmd '&& rm -f' deletes.dc
        end
        else do
          parse value deletes.dc with delds'/'mem
          if pos('.',mem) > 0
          then parse value mem with m'.'.
          else m = mem
          dm.dc = "'"pdshlq"."delds"("m")'"
          call delete_member "'"pdshlq"."delds"'" m
          cmd = 'cd' localrep'/'zigirep'/'delds
          cmd = cmd '&& rm' mem
          x = docmd(cmd)
        end
      end
      call outtrap 'off'
      do id = 1 to deletes.0
        so.id = 'Deleted:' dm.id
      end
      so.0 = deletes.0
      se.0 = 0
      call view_std
      call update_repo_metadata
    end
    else do
      if pulled = 0 then do
        zerrsm = 'Nothing'
        zerrlm = 'Nothing to pull.'
        'setmsg msg(isrz003)'
      end
      else call update_repo_metadata
    end
    if pulled > 0 then do
      zerrsm = 'Successful.'
      zerrlm = left('Pull was a success.',76) pullmsg
      'setmsg msg(isrz003)'
    end
  end
  Return

  /* -------------------------------- *
  | Fetch Remote Repo Updates        |
  * -------------------------------- */
WWR_handle_fetch:
  zs1 = 'Performing the git fetch . . .'
  zs2 = 'Please standby'
  call do_popup
  cmd = 'cd' localrep'/'zigirep
  x = docmd(cmd '&& git fetch && git status')
  fetch_flag = 1
  branch = word(so.1,3)
  if so.0 > 1 then call Update_Status
  else do
    parse value '' with bstat baction
  end
  Return

  /* ------------------------- *
   | Add/Update README.md file |
   * ------------------------- */
WWR_Handle_Readme:
  readme = localdir"/README.md"
  Address ISPExec ,
  'Edit File(readme) macro(zigiemmd)'
  cmd = 'cd' localdir '&& chtag -tc' encoding 'README.md'
  x = docmd(cmd)
  call view_std 'B' 'V'
  return

  /* -------------------------------- *
  | Replace z/OS datasets            |
  * -------------------------------- */
WWR_handle_replace:
  if words(save_zigirep) > 0 then do
    zerrsm = 'Invalid.'
    zerrlm = 'Replace is not supported in subdirectories.'
    'setmsg msg(isrz003)'
    return
  end
  if readonly = 1 then do
    zerrsm = 'Invalid.'
    zerrlm = 'Replace is not supported for ReadOnly Repositories.'
    'setmsg msg(isrz003)'
    return
  end
  do
    zcmd = null
    refa = 'NO'
    call pfshow 'off'           /* make sure pfshow is off */
    'Addpop row(4) column(12)'
    'Display Panel(zigipopr)'
    prc = rc
    'Rempop'
    call pfshow 'reset'         /* restore pfshow setting */
    if prc > 0 then refa = 'NO'
    if refa = 'YES' then do
      call Replace localrep zigirep pdshlq qualignr
      if replace_state = 1 then return
      call update_repo_metadata
    end
    else do
      zerrsm = 'Canceled.'
      zerrlm = 'Replace canceled.'
      'setmsg msg(isrz003)'
    end
  end
  Return

  /* -------------------------------- *
  | Extract/Rollback a Commit        |
  * -------------------------------- */
WWR_handle_extract:
  if words(save_zigirep) > 0 then do
    zerrsm = 'Invalid.'
    zerrlm = 'Extract is not supported in subdirectories.'
    'setmsg msg(isrz003)'
  end
  else call do_extract
  Return

  /* -------------------------------- *
  | Snapshot the current repository  |
  * -------------------------------- */
WWR_handle_snapshot:
  do forever
    parse value '' with zcmd path snaphlq gtag sans
    'display panel(zigisnap)'
    if rc > 0 then leave
    call pfshow 'off'           /* make sure pfshow is off */
    'Addpop row(4) column(10)'
    'Display Panel(zigisnpq)'
    drc = rc
    'rempop'
    call pfshow 'reset'         /* restore pfshow setting */
    if drc > 0 then leave
    if sans = 'Y' then do
      cmd = 'cd' localrep'/'zigirep
      cmd = cmd '&& git tag' gtag
      zs1 = 'Performing the git tag'
      zs2 = 'Please standby'
      call do_popup
      x = docmd(cmd)
      if path /= null then do
        zs1 = 'Copying' localrep'/'zigirep
        zs2 = 'To:' path
        call do_popup
        cmd = 'cp -rp' localrep'/'zigirep path
        x = docmd(cmd)
        if x > 0 then call view_std 'B'
        zs1 = 'Performing the cleanup of git files'
        zs2 = 'Please standby'
        call do_popup
        cmd = 'cd' path
        cmd = cmd '&& rm .gitattributes && rm -rf .git && rm -rf .zigi'
        x = docmd(cmd)
        if x > 0 then call view_std 'B'
        /*  create a git log in the snapshot directory */
        cmd = 'cd' localrep'/'zigirep
        cmd = cmd "&& echo 'Git Tag for this Snapshot is:' >" ,
          path'gitlog.txt'
        cmd = cmd '&& git tag -l' gtag '>>' path'gitlog.txt'
        cmd = cmd "&& echo ' ' >>" path'gitlog.txt'
        cmd = cmd "&& echo 'Recent Git Log Entries:' >>" path'gitlog.txt'
        cmd = cmd "&& echo ' ' >>" path'gitlog.txt'
        cmd = cmd '&& git log -n 10'
        cmd = cmd '>>' path'gitlog.txt'
        x = docmd(cmd)
        if x > 0 then call view_std 'B'
      end

      save_hlq = pdshlq
      call Replace localrep zigirep snaphlq '*'
      pdshlq = save_hlq

      /* now view both the omvs directory and snaphlq */
      sans = null
      call pfshow 'off'           /* make sure pfshow is off */
      'Addpop row(4) column(10)'
      'Display Panel(zigisnpr)'
      drc = rc
      'rempop'
      call pfshow 'reset'         /* restore pfshow setting */
      if drc > 0 then sans = 'N'
      if sans = 'N' then do
        zerrsm = 'Completed.'
        zerrlm = 'Snapshot completed - tag:' gtag
        'setmsg msg(isrz003)'
        leave
      end
      if path /= null then
      'SELECT PGM(ISRDSLST) PARM(UDL' path') SUSPEND'
      "SELECT PGM(ISRDSLST) PARM(DSL '"snaphlq"') SUSPEND"
      zerrsm = 'Completed.'
      zerrlm = 'Snapshot completed - tag:' gtag
      'setmsg msg(isrz003)'
      leave
    end
  end
  Return

  /* --------------------------------- *
  | Tag the repo with an annotated tag |
  * --------------------------------- */
WWR_handle_tag:
  parse value '' with tagid tagmsg
  call pfshow 'off'           /* make sure pfshow is off */
  'addpop row(4) column(6)'
  'display panel(zigitag)'
  drc = rc
  'rempop'
  call pfshow 'reset'         /* restore pfshow setting */
  if drc = 0 then do
    if tagmsg = null then
    cmd = 'git tag' tagid
    else cmd = 'git tag -a' tagid '-m "'tagmsg'"'
    cmd = 'cd' localrep'/'zigirep '&&' cmd
    if pos('no remote',remote1) = 0
    then if zigi_offline = 0
    then cmd = cmd '&& git push origin' tagid
    cmd = cmd '&& git show' tagid
    x = docmd(cmd)
    if x = 0 then do
      zerrsm = 'Tagged.'
      zerrlm = tagid 'has been tagged to the current' ,
        'repository.'
      'setmsg msg(isrz003)'
    end
    else call view_std 'B'
  end
  Return

  /* --------------------------------------------------------- *
  | Add a PDS or a Sequential File to "Working Directory"     |
  * --------------------------------------------------------- */
WWR_handle_adddsn:
  if words(save_zigirep) > 0 then do
    zerrsm = 'Invalid.'
    zerrlm = 'ADDDSN is not supported in subdirectories.'
    'setmsg msg(isrz003)'
  end
  else call Add_Dataset
  Return

  /* --------------------------------- *
  | Git add all modified or untracked |
  * --------------------------------- */
WWR_handle_addall:
  x = debug('ADDALL started:' zigirep)
  zs1 = 'Performing Git Add all'
  zs2 = 'Should be quick.'
  call do_popup
  cmd = 'cd' localrep'/'zigirep '&& git add -A .'
  x = docmd(cmd)
  call update_repo_metadata
  zcmd = null
  x = debug('ADDALL completed' zigirep)
  Return

  /* -------------------------------- *
  | GIT GREP                         |
  * -------------------------------- */
WWR_handle_grep:
  parse value  '' with zcmd grepstr grepopt
  grepdir = localrep'/'zigirep
  gds = 'Dataset/File'
  call do_grep grepdir
  Return

  /* -------------------------------- *
  | Add/replace remote URI (origin)  |
  * -------------------------------- */
WWR_handle_remote:
  zcmd = null
  origin = null
  'display panel(zigiremo)'
  if rc > 0 then do
    zerrsm = 'Canceled.'
    zerrlm = 'Remote update canceled.'
    'setmsg msg(isrz003)'
  end
  else do
    'tbmod zigirepo order'
    'TBSAVE zigirepo REPLCOPY LIBRARY('isptabl')'
    parsedURI = parseGitURI(origin)
    parse var parsedURI user host port repo
    if port /= 22 then extrabits = '-p 'port
    else extrabits = null
    cmd = 'touch 'home'/.ssh/known_hosts && '
    cmd = cmd 'if | grep 'host
    cmd = cmd home'/.ssh/known_hosts >/dev/null;'
    cmd = cmd 'then ssh-keyscan 'extrabits' -t rsa,dsa 'host
    cmd = cmd ' 2>/dev/null >> 'home'/.ssh/known_hosts ;'
    cmd = cmd 'fi'
    x = docmd(cmd)
    cmd = 'cd' localrep'/'zigirep
    x = docmd(cmd '&& git remote add origin 'origin)
    call View_std 'B'
    cmd = 'cd' localrep'/'zigirep
    if zigi_offline = 0 then do
      x = docmd(cmd '&& git push -vu origin 'branch)
      call View_std 'B'
      gitcmd = 'git remote -v'
      x = docmd('cd 'localrep'/'zigirep' && 'gitcmd)
      call fix_remote_tab
      if so.0 > 0 then
      parse value so.1 with . (tab) remote1 .
      'tbmod zigirepo order'
      'TBSAVE zigirepo REPLCOPY LIBRARY('isptabl')'
    end
    call update_repo_metadata
  end
  Return

  /* -------------------------------- *
  | Select a zigiflow to work on     |
  * -------------------------------- */
WWR_handle_flowsel:
  x = check_clean()
  if x = 'NO' then do
    zerrsm = 'Not Clean'
    zerrlm = "Can't switch flows in dirty workspace"
    'setmsg msg(isrz003)'
  end
  else do
    call flowselect
  end
  Return

  /* -------------------------------- *
  | Start a zigiflow                 |
  * -------------------------------- */
WWR_handle_flowgo:
  x = check_clean()
  if x = 'NO' then do
    zerrsm = 'Not Clean'
    zerrlm = "Can't start flow in dirty workspace"
    'setmsg msg(isrz003)'
  end
  else do
    call pfshow 'off'           /* make sure pfshow is off */
    'Addpop row(3) column(4)'
    'Display Panel(zigifgo)'
    drc = rc
    'rempop'
    call pfshow 'reset'         /* restore pfshow setting */
    if drc > 0 then do
      zerrsm = 'Canceled.'
      zerrlm = 'FlowGo was canceled.'
      'setmsg msg(isrz003)'
    end
    else do
      cmd = 'cd' localrep'/'zigirep
      cmd = cmd || ' && git checkout master &&'
      cmd = cmd || ' git checkout -b 'flowname
      cmd = cmd || ' && git checkout -b zigiflow-'flowname
      cmd = cmd || ' && git tag 'flowname
      x = docmd(cmd)
      call Replace localrep zigirep pdshlq qualignr
      call update_repo_metadata
    end
  end
  Return

  /* -------------------------------- *
  | Finish a zigiflow                |
  * -------------------------------- */
WWR_handle_flowend:
  /* what flow are we in? */
  cmd = 'cd' localrep'/'zigirep
  cmd = cmd || ' && git rev-parse --abbrev-ref HEAD'
  x = docmd(cmd)
  currbranch = so.1
  if substr(currbranch,1,8) = 'zigiflow' then do
    /* We're in a zigiflow...continue */
    x = check_clean()
    if x = 'NO' then do
      /* working dir not clean. abort */
      zerrsm = 'Not Clean'
      zerrlm = "Can't finish flow. Uncommited changes"
      'setmsg msg(isrz003)'
    end
    else do
      /* all looks good, let's merge to the feature */
      flowname = substr(currbranch,10)
      /* get the commit messages in */
      cmd = 'cd' localrep'/'zigirep
      cmd = cmd || ' && git log --pretty=format:%s'
      cmd = cmd || ' 'flowname'...HEAD'
      x = docmd(cmd)
      m.1 = flowname': '
      do prepcom = 1 to so.0
        cid = prepcom + 1
        m.cid = so.prepcom
      end
      m.0 = cid
      /* execute the merge */
      cmd = 'cd' localrep'/'zigirep
      cmd = cmd || ' && git checkout 'flowname
      cmd = cmd || ' && git merge --squash zigiflow-'flowname
      call pfshow 'off'           /* make sure pfshow is off */
      'Addpop row(3) column(4)'
      'Display Panel(zigifend)'
      drc = rc
      'rempop'
      call pfshow 'reset'         /* restore pfshow setting */
      if drc > 0 then do
        zerrsm = 'Canceled.'
        zerrlm = 'FlowEnd canceled.'
        'Setmsg msg(isrz003)'
      end
      else do
        x = docmd(cmd)
        /* perform the commit */
        call do_commit 'x'
        /* Make sure remote has the new branch */
        cmd = 'cd' localrep'/'zigirep
        cmd = cmd || ' && git push --set-upstream origin '
        cmd = cmd || 'refs/heads/'flowname
        x = docmd(cmd)
        /* delete the work branch */
        cmd = 'cd' localrep'/'zigirep
        cmd = cmd || ' && git branch -D zigiflow-'flowname
        x = docmd(cmd)
        /* Get things updated */
        call update_repo_metadata
        call Replace localrep zigirep pdshlq qualignr
      end
    end
  end
  else do
    /* error for when not in zigiflow */
    zerrsm = 'No zigiflow'
    zerrlm = "You're not working in a zigiflow"
    'setmsg msg(isrz003)'
  end
  Return

  /* -------------------------------- *
  | Show the diff for the file       |
  * -------------------------------- */
WWR_handle_lcmd_d:
  dtest = 0
  if left(fulldsn,1) = "'" then do
    x = listdsi(fulldsn)
    if sysdsorg = 'PO' then do
      zerrlm = 'Diff does not work on Partitioned Datasets'
      zerrsm = 'Error.'
      'setmsg msg(isrz003)'
      dtest = 1
    end
  end
  else if filetype = '(D)' then do
    zerrlm = 'Diff does not work on directories'
    zerrsm = 'Error.'
    'setmsg msg(isrz003)'
    dtest = 1
  end
  if dtest = 0 then do
    cmd = 'cd' localrep'/'zigirep
    x = docmd(cmd ' && git diff 'dsn)
    if so.0 + se.0 > 0
    then call View_std 'X' 'V'
    else do
      zerrsm = 'No Diff'
      zerrlm = 'No differnce found.'
      'Setmsg msg(isrz003)'
    end
  end
  Return

  /* --------------------------------- *
  | git blame                          |
  | Show the revision history for file |
  * --------------------------------- */
WWR_handle_lcmd_bl:
  if left(fulldsn,1) = "'" then do
    x = listdsi(fulldsn)
    if sysdsorg = 'PO' then do
      zerrlm = 'Blame does not work on Partitioned Datasets'
      zerrsm = 'Error.'
      'setmsg msg(isrz003)'
      return
    end
  end
  else mem = null
  if mem /= null then mem = '/'mem
  call do_blame dsn''mem
  Return

  /* -------------------------------- *
  | Show the history for the file    |
  * -------------------------------- */
WWR_handle_lcmd_h:
  htest = 0
  if left(fulldsn,1) = "'" then do
    x = listdsi(fulldsn)
    if sysdsorg = 'PO' then do
      zerrlm = 'History does not work on Partitioned Datasets'
      zerrsm = 'Error.'
      'setmsg msg(isrz003)'
      htest = 1
    end
  end
  if htest = 0 then
  call do_history dsn
  Return

  /* -------------------------------- *
  | Browse the file or list members  |
  * -------------------------------- */
WWR_handle_lcmd_b:
  'control display save'
  if left(fulldsn,1) = "'" then do
    x = listdsi(fulldsn)
    if sysdsorg = 'PO' then do
      'LMInit Dataid(zigdid) Dataset('fulldsn')'
      "Memlist Dataid("zigdid") Default(B)"
      drc = rc
      "LMfree Dataid("zigdid")"
    end
    else do
      'Browse Dataset('fulldsn')'
      drc = rc
    end
  end
  else do
    ofile = localrep'/'zigirep'/'fulldsn
    x = get_fd_date(ofile)
    if ftag = 'untagged'
    then do
        zerrsm = 'View Substituted.'
        zerrlm = 'Browse is not supported for this file so' ,
                 'View has been substituted.'
       'setmsg msg(isrz003)'
       'View File(ofile) ascii'
       end
    else Address TSO 'Obrowse' ofile
    drc = rc
  end
  'control display restore'
  if drc > 0 then 'setmsg msg(isrz003)'
  Return

  /* -------------------------------- *
  | View the file or list members     |
  * -------------------------------- */
WWR_handle_lcmd_v:
  'control display save'
  if left(fulldsn,1) = "'" then do
    x = listdsi(fulldsn)
    if sysdsorg = 'PO' then do
      'LMInit Dataid(zigdid) Dataset('fulldsn')'
      "Memlist Dataid("zigdid") Default(V)"
      "LMfree Dataid("zigdid")"
    end
    else 'View Dataset('fulldsn')'
  end
  else do
    ofile = localrep'/'zigirep'/'fulldsn
    x = get_fd_date(ofile)
    if ftag = 'untagged' then vasc= 'ascii'
    else vasc = null
    'View File(ofile)' vasc
  end
  'control display restore'
  Return

  /* ------------------------ *
  | Rename the element in git|
  | and OMVS and z/OS        |
  * ------------------------ */
WWR_handle_lcmd_rn:
  if readonly = 1 then do
    zerrsm = 'Invalid.'
    zerrlm = 'Rename (RN) is not supported for ReadOnly Repositories.'
    'setmsg msg(isrz003)'
    return
  end
  newdsn = fulldsn
  fulldsnq = fulldsn
  if dsnvalid(fulldsn) = 'OK' then zos = 1
  else zos = 2
  do forever
    call pfshow 'off'           /* make sure pfshow is off */
    'Addpop row(4) column(6)'
    if zos = 1 then
    'display panel(zigirena)'
    else
    'display panel(zigireno)'
    drc = rc
    'rempop'
    call pfshow 'reset'         /* restore pfshow setting */
    if drc > 0 then leave
    if zos = 1 then do
      x = listdsi(newdsn)
    end
    else x = 1
    if x = 0 then do
      zerrsm = 'Error'
      zerrlm = newdsn 'currently exists. Select a different' ,
        'dataset name for the rename operation.'
      'setmsg msg(isrz003)'
    end
    else do
      zs1 = 'Renaming:' fulldsn
      zs2 = 'To:      ' newdsn
      call do_popup
      if left(fulldsn,1) = "'"  /* z/OS rename */
      then Address TSO 'Rename' fulldsn newdsn
      else do
        cmd = 'cd' localrep'/'zigirep
        cmd = cmd '&& mv' '"'fulldsn'" "'newdsn'"'
        x = docmd(cmd)
      end
      cmd = 'cd' localrep'/'zigirep
      zs1 = 'Renaming:' fulldsn
      zs2 = 'To:      ' newdsn
      call do_popup
      if left(fulldsn,1) /= "'"
      then cmd = cmd '&& git mv' '"'fulldsn'" "'newdsn'"'
      else do
        x = listdsi(newdsn)
        oldfile = remove_dsn_hlq(fulldsn)
        newfile = remove_dsn_hlq(newdsn)
        cmd = cmd '&& git mv' oldfile newfile
      end
      x = docmd(cmd)
      if sysdsorg = 'PO' then do
        zs1 = 'Renaming:' '.zigi/'oldfile
        zs2 = 'To:      ' '.zigi/'newfile
        call do_popup
        /* still weird with rename of statsfile? */
        cmd = 'cd' localrep'/'zigirep'/.zigi'
        cmd = cmd '&& git mv' oldfile  newfile
        x = docmd(cmd)
      end
      if x > 0 then
      call view_std 'B'
      'tbdelete' rtbl
      fulldsn = newdsn
      dsn = newfile
      dsnstat = '[R ] Renamed in index'
      'tbadd' rtbl 'Order'
      bstat = 'Changes to be committed:'
      baction = null
      zerrsm = 'Renamed.'
      zerrlm = fulldsns 'has been renamed in ZIGI, git, z/OS, and OMVS.'
      'setmsg msg(isrz003)'
      leave
    end
  end
  Return

  /* -------------------------------- *
  | Remove a Dataset or File         |
  | - git rm -f file                 |
  | - OMVS file just rm -f file      |
  | - PS Dataset                     |
  |   Delete dataset                 |
  |   rm -f file                     |
  | - PDS Dataset                    |
  |   Delete dataset                 |
  |   rm -frv file                   |
  |   rm -f .zigi/file (ispf stats)  |
  |    - git rm -f .zigi/file        |
  * -------------------------------- */
WWR_handle_lcmd_rm:
  if readonly = 1 then do
    zerrsm = 'Invalid.'
    zerrlm = 'Remove (RM) is not supported for ReadOnly Repositories.'
    'setmsg msg(isrz003)'
    return
  end
  rc = confirm_remove(fulldsn)
  rm_msg = null
  if rc > 0 then do
    zerrsm = 'Canceled.'
    zerrlm = 'Removal of' fulldsn 'canceled.'
    'setmsg msg(isrz003)'
  end
  else do
    rtype = null
    localdir =  localrep'/'zigirep
    if left(fulldsn,1) /= "'" then rtype = 'OMVS'
    /* only listdsi on zOs datsets */
    if rtype = null then do
      x = listdsi(fulldsn)
      if rc = 0 & sysdsorg = 'PS' then rtype = 'PS'
      if rc = 0 & sysdsorg = 'PO' then rtype = 'PO'
    end
    if rtype = null then do
      zs1 = fulldsn 'is not recogizned.'
      zs2 = sysmsglvl2
      zs3 = null
      zs4 = 'Press Enter to continue.'
      call do_popup4p
    end
    else Select
      when remq = 'N' then do
        cmd = 'cd' localdir '&& git rm --cached' '"'fulldsn'"'
        x = docmd(cmd,,so.,se.)
        rm_msg = 'the git index.'
      end
      when pos(remq,'OB') > 0 & rtype = 'OMVS' then do
        cmd = 'cd' localdir '&& git rm -rf' '"'fulldsn'"'
        cmd = cmd '&& git add -u'
        x = docmd(cmd,,so.,se.)
        rm_msg = 'OMVS.'
      end
      when pos(remq,'ZOB') > 0 & rtype = 'PS' then do
        if pos(remq,'ZB') > 0 then do
          call outtrap 'x.'
          Address TSO ,
            'Delete' fulldsn
          call outtrap 'off'
          rm_msg = 'z/OS'
        end
        if pos(remq,'OB') > 0 then do
          cmd = 'cd' localdir '&& git rm -rf' dsn
          x = docmd(cmd,,so.,se.)
          cmd = 'cd' localdir '&& rm -rf' dsn
          x = docmd(cmd,,so.,se.)
          if rm_msg /= null
          then rm_msg = rm_msg 'and OMVS.'
          else rm_msg = 'OMVS.'
        end
      end
      when pos(remq,'ZOB') > 0 & rtype = 'PO' then do
        if pos(remq,'ZB') > 0 then do
          call outtrap 'x.'
          Address TSO ,
            'Delete' fulldsn
          call outtrap 'off'
          rm_msg = 'z/OS'
        end
        if pos(remq,'OB') > 0 then do
          cmd = 'cd' localdir '&& git rm -rf' dsn
          cmd = cmd
          x = docmd(cmd,,so.,se.)
          cmd = 'cd' localdir
          cmd = cmd '&& rm -rf' localdir'/.zigi/'dsn
          cmd = cmd '&& rm -rf' localdir'/'dsn
          cmd = cmd
          x = docmd(cmd,,so.,se.)
          if rm_msg /= null
          then rm_msg = rm_msg 'and OMVS.'
          else rm_msg = 'OMVS.'
        end
      end
      Otherwise nop
    end
    dsnstat = '*Removed'
    baction = 'Changes to be committed:'
    'tbmod' rtbl
    if rm_msg /= null then do
      zerrsm = 'Removed.'
      zerrlm = fulldsn 'has been removed from ZIGI, from git, and has' ,
        'been deleted from' rm_msg
      'setmsg msg(isrz003)'
    end
  end
  Return

  /* -------------------------------- *
  | Work with a omvs file from repo   |
  * -------------------------------- */
WWR_handle_lcmd_s_omvs:
  if readonly = 1 then do
    zerrsm = 'Invalid.'
    zerrlm = 'Edit is not supported for ReadOnly Repositories.'
    'setmsg msg(isrz003)'
    return
  end
  zosflg = 0
  ofile = localrep'/'zigirep'/'fulldsn
  cur_date = get_fd_date(ofile)
  if filetype /= '(D)' then do
    'control display save'
    if pos('.MD',translate(ofile)) > 0
       then emac = 'macro(zigiemmd)'
       else emac = null
    if ftag = 'untagged' then emac = emac' ascii'
    'Edit file(ofile)' emac
    'control display restore'
    new_date = get_fd_date(ofile)
    if cur_date /= new_date then
    if ztdsels < 2 then
    call update_repo_metadata
  end
  else do
    save_zigirep = save_zigirep zigirep
    x = debug('Entering subdirectory - save_zigirep:' save_zigirep)
    zigirep = zigirep'/'dsn
    'tbend' rtbl
    rtbl_open = 0
    call work_with_repo
    zigirep = word(save_zigirep,words(save_zigirep))
    save_zigirep = delword(save_zigirep,words(save_zigirep))
    x = debug('Return from subdirectory - save_zigirep:' save_zigirep)
    'tbend' rtbl
    rtbl_open = 0
    call work_with_repo 'x'
  end
  Return

  /* -------------------------------- *
  | Work with a mvs dataset from repo |
  * -------------------------------- */
WWR_handle_lcmd_s_mvs:
  dhit = 1
  call outtrap 'x.'
  if sysdsn(fulldsn) /= 'OK' then dhit = 0
  call outtrap 'off'
  if dhit = 0 then do
    zerrsm = 'Error'
    zerrlm = fulldsn 'does not exist. This should not have happened.' ,
      'Somehow it may have been deleted.'
    'Setmsg msg(isrz003)'
  end
  else do
    'control display save'
    call work_with_repo_file
    'control display restore'
  end
  Return

  /* -------------------------------- *
  | Add repo item to staging area    |
  * -------------------------------- */
WWR_handle_lcmd_a:
  call git_add
  zigi_changed = 1
  Return

  /* -------------------------------- *
  | Un-Modify entire dataset         |
  * -------------------------------- */
WWR_handle_lcmd_u:
  if dsnvalid(fulldsn) = 'NO' then do
    zerrsm = 'Invalid.'
    zerrlm = 'Undo is only valid on a PDS member and not on an OMVS file.'
    'setmsg msg(isrz003)'
    return
  end
  x = listdsi(fulldsn)
  if sysdsorg = 'PS' then call do_undo 'D'
  else do
    zerrsm = 'Invalid.'
    zerrlm = 'Undo is not valid on a complete PDS - Select the PDS' ,
      'and use Undo on the invididual members.'
    'setmsg msg(isrz003)'
  end
  Return

  /* -------------------------------- *
  | View the OMVS file or directory. |
  * -------------------------------- */
WWR_handle_lcmd_z:
  fdsn = localrep'/'zigirep'/'dsn
  'control display save'
  'View file(fdsn)'
  'control display restore'
  return

  /* ============================================================== */
  /* ======== repo file handling ================================== */
  /* ============================================================== */

  /* ---------------------------------------- *
  | Process the selected dataset (PDS or PS) |
  * ---------------------------------------- */
Work_with_repo_file:
  remc = 'NO'
  x = debug('Working with Repo File:' zigirep'/'dsn)
  x = listdsi(fulldsn)
  if sysdsorg /= 'PS' then do
    zs1 = 'Building list of library status....'
    zs2 = 'Patience . . .'
    call do_popup
  end
  /* Determine if the repo item is a PDS or a flat-file */
  if sysdsorg = 'PS' then
  call edit_ps
  else do
    call WWRF_build_member_table
    /* ---------------------------------- *
    | Process the Member list until done |
    * ---------------------------------- */
    save_rtll = 0
    zigi_changed = 0
    save_ztdsels = ztdsels
    extens = zdsn.dsn
    'vput (extens)'
    Do Forever
      if rtll_open = 0 then leave
      call WWRF_display_zigilist
      if result > 4 then leave

      call WWRF_handle_options

      if zcmd /= null then
      Select
        When abbrev('ADDALL',zcmd,2) = 1 then call WWRF_handle_addall
        When abbrev('COMMIT',zcmd,3) = 1 then call WWRF_handle_commit
        When abbrev('GITHELP',word(zcmd,1),4) = 1 then
        Address TSO '%githelp' subword(zcmd,2)
        When abbrev('GITCMD',zcmd,4) = 1 then
        'Select cmd(%zigigcmd)'
        When abbrev('GITLOG',zcmd,2) = 1 then call do_gitlog
        When abbrev('GREP',zcmd,2) = 1 then do
          gds = 'PDS Member'
          call do_grep localdir'/'dsn
        end
        When abbrev('STATUS',zcmd,2) = 1 then call do_status
        When abbrev('RESET',zcmd,2) = 1 then call do_resetid
        When abbrev('SORT',word(zcmd,1),2) = 1 then call do_lsort
        When abbrev("LOCATE",translate(word(zcmd,1)),1) = 1 then
        call WWRF_handle_locate
        when zcmd = 'VIEWD' then call view_debug
        Otherwise do
          zerrsm = 'Unknown'
          zerrlm = zcmd 'is not a recognized command.'
          'setmsg msg(isrz003)'
        end
        zsel = null
        zcmd = null
      end

      if zsel = '/' then do
        call pfshow 'off'           /* make sure pfshow is off */
        'Addpop row(4) column(6)'
        'Display Panel(zigirlst)'
        'rempop'
        call pfshow 'reset'         /* restore pfshow setting */
      end

      /* handle line commands */
      if zsel /= null then do
        if zsel = 'E' then zsel = 'S'
        Select
          When zsel = 'B'  then call WWRF_handle_lcmd_b
          When zsel = 'BL' then call do_blame dsn'/'mem
          When zsel = 'V'  then call WWRF_handle_lcmd_v
          When zsel = 'S'  then call WWRF_handle_lcmd_s
          When zsel = 'H' then call do_history dsn'/'mem
          When zsel = 'RN' then call WWRF_handle_lcmd_rn
          When zsel = 'RM' then call WWRF_handle_lcmd_rm
          when zsel = 'A' then do
            /* -------------------------------- *
            | Add member of PDS to staging area|
            * -------------------------------- */
            call git_add_member
            zigi_changed = 1
          end
          when zsel = 'AB' then call WWRF_handle_lcmd_ab
          when zsel = 'AF' then do
            call git_add_member 'F'
            zigi_changed = 1
          end
          when zsel = 'I'  then call WWRF_handle_lcmd_i
          When zsel = 'U' then call do_undo 'M'
          When zsel = 'D' then call WWRF_handle_lcmd_d
          When zsel = 'Z' then call WWRF_handle_lcmd_z
          Otherwise do
            zerrsm = 'Invalid.'
            zerrlm = zsel 'is not a valid selection value. Review the' ,
              'ISPF Tutorial using F1 for available line selection' ,
              'options.'
            'setmsg msg(isrz003)'
          end
        end
      end
    end
  end
  ztdsels = save_ztdsels
  zsel = null
  return

  /* ============================================================== */
  /* ======== repo file handling support functions ================ */
  /* ============================================================== */

WWRF_build_member_table:
  /* Do this if it's a PDS */
  localdir = localrep'/'zigirep
  'TBCreate' rtll 'Keys(mem) Names(memstat zlcnorc' ,
    'zlmdate zlmtime zluser mtype zlm4date)',
    'replace NoWrite'
  rtll_open = 1
  /* --------------------- *
   | usssafe required here |
   * --------------------- */
  cmd = 'ls -laT' localrep'/'zigirep'/'usssafe(dsn)
  x = bpxwunix(cmd,,root.,re.,env.)
  address ispexec
  "LMINIT DATAID(DID) Dataset("fulldsn")"
  "LMOPEN DATAID("did")"
  cmd = 'cd' localrep'/'zigirep
  x = docmd(cmd '&& git status --porcelain')
  file_ext = zdsn.dsn
  file_extl = length(file_ext)
  dstat = dsnstat

  call get_ignored
  memstat = null

  do bmi = 1 to root.0
    if left(root.bmi,1) = ' ' then iterate
    if word(root.bmi,1) = 'total' then iterate
    do
      mem = word(root.bmi,12)
      gi_mem = mem
      if file_ext /= null then
      if right(mem,file_extl) = file_ext then do
        parse value mem with mem'.'.
        mem = translate(mem)
      end
      else iterate
      memstat = null
      if word(root.bmi,2) = 'binary'
      then mtype = 'B'
      else mtype = 'T'
      do ii = 1 to so.0
        /* see if we have this file in git status */
        stat = substr(so.ii,1,2)
        memstat = null
        if pos('R',stat) = 0
        then thepath = word(so.ii,2)
        else thepath = word(so.ii,4)
        parse var thepath FOLDER"/"MEMBER
        if zdsn.dsn /= null then do
          parse value member with member'.' .
          member = translate(member)
        end
        if folder /= dsn then do
          stat = null
          iterate
        end
        if mem /= MEMBER then do
          stat = null
          iterate
        end
        if mem = MEMBER then do
          memstat = porcelain(stat)
          if FOLDER = "./" & stat = "??" then
             memstat = '[??] Untracked'
          leave
        end
      end
    end

    statc = check_ignore(dsn'/'gi_mem)
    if statc /= 0 then memstat = '[  ] Git Ignored'

    if stat = '??' then
       memstat = '[??] Untracked'

    /* ------------------------------------------------------- *
    |  The files in OMVS have some chars changed due to cp -M |
    |  So we fix the name before we save to table :)          |
    * ------------------------------------------------------- */
    /* ----------------------------------------------- *
    | Now get ISPF stats for each member for the list |
    * ----------------------------------------------- */
    "LMMFind DATAID("did") Member("mem") STATS(YES)"
    'tbadd' rtll
  end
  "LMCLOSE DATAID("did")"
  "LMFREE DATAID("did")"
  'tbsort' rtll 'Fields(mem,c,a)'
  Return

WWRF_display_zigilist:
  parse value '' with zsel zcmd row
  ztdsels = save_rtll
  if ztdsels > 1 then
  'tbdispl' rtll
  else do
    zigi_changed = 0
    'tbtop' rtll
    'tbskip' rtll 'number('list_top')'
    'TBdispl' rtll 'Panel(zigilist)'
  end
  if rc > 4 then do
    panel_rc = rc
    if rtll_open = 1 then
    'tbend' rtll
    list_top = 0
    rtll_open = 0
    Return panel_rc
  end
  Return 0

WWRF_handle_options:
  /* Make sure we edit (and copy) right dataset when we have
  a prefix set */
  list_top = ztdtop
  save_rtll = ztdsels
  edsn = strip(fulldsn,'B',"'")

  if ztdsels = 0 then
  if pnsdef = 'P' then do
    if row = 0 then zcmd = 'O'
    if row > 0 then zsel = '/'
  end

  if row = 0 then zsel = null
  if row <> null then
  if row > 0 then do
    'TBTop' rtll
    'TBSkip' rtll 'Number('row')'
  end
  if pos('.',zcmd) > 0 then
  parse value zcmd with x'.'zcmd
  lstloc = null
  if pos(zcmd,'/O') > 0 then do
    zcmd = null
    call pfshow 'off'           /* make sure pfshow is off */
    'Addpop row(4) column(6)'
    'Display Panel(zigiolst)'
    'rempop'
    call pfshow 'reset'         /* restore pfshow setting */
  end
  Return

WWRF_handle_addall:
  'tbtop' rtll
  x = debug('ADDALL started:' zigirep)
  do forever
    'tbskip' rtll
    if rc > 0 then leave
    hit = 0
    if pos('Untracked',memstat) > 0 then hit = 1
    if pos('[M',memstat) > 0 then hit = 1
    if pos('M]',memstat) > 0 then hit = 1
    if hit = 0 then iterate
    zs1 = 'Adding' mem
    zs2 = 'Making it ready to Commit'
    call do_popup
    call git_add_member
  end
  call git_add_member_stats
  zcmd = null
  x = debug('ADDALL completed:' zigirep)
  Return

WWRF_handle_commit:
  zsel = null
  call do_commit
  call work_with_repo_file
  Return

WWRF_handle_locate:
  if words(zcmd) = 1 then do
    call pfshow 'off'           /* make sure pfshow is off */
    'addpop row(3) column(4)'
    'display panel(zigilocq)'
    drc = rc
    'rempop'
    call pfshow 'reset'         /* restore pfshow setting */
    if drc > 0 then return
    zcmd = 'L' filter
  end
  mem = translate(word(zcmd,2))
  zcmd = null
  'tbtop' rtll
  'tbsarg' rtll
  'tbscan' rtll 'arglist(mem) position(scanrow) condlist(ge)'
  if rc = 0 then do
    save_top = scanrow
    zerrsm = null
    zerrlm = mem 'was found in row' scanrow + 0
    'Setmsg msg(isrz003)'
    ztdsels = 1
    list_top = scanrow
  end
  else do
    zerrsm = null
    zerrlm = word(zcmd,2) 'was not found'
    'Setmsg msg(isrz003)'
  end
  Return

  /* -------------------------------- *
  | Browse PDS member or PS dataset  |
  * -------------------------------- */
WWRF_handle_lcmd_b:
  'control display save'
  x = listdsi(fulldsn)
  edsn = strip(fulldsn,'B',"'")
  r = dsn
  if sysdsorg = 'PS'
  then "Browse Dataset('"edsn"')"
  else "Browse Dataset('"edsn"("mem")'"
  brc = rc
  'control display restore'
  if brc > 0 then 'setmsg msg(isrz003)'
  Return

  /* -------------------------------- *
  | View PDS member or PS dataset    |
  * -------------------------------- */
WWRF_handle_lcmd_v:
  x = listdsi(fulldsn)
  edsn = strip(fulldsn,'B',"'")
  r = dsn
  if is_binfile(dsn'/'mem) = 1 then do
    zerrsm = 'Invalid'
    zerrlm = 'Unable to View a binary dataset.'
    'setmsg msg(isrz003)'
    return
  end
  'control display save'
  if sysdsorg = 'PS'
  then "View Dataset('"edsn"')"
  else "View Dataset('"edsn"("mem")'"
  'control display restore'
  Return

  /* -------------------------------- *
  | Edit PDS member or PS dataset    |
  * -------------------------------- */
WWRF_handle_lcmd_s:
  if readonly = 1 then do
    zerrsm = 'Invalid.'
    zerrlm = 'Edit is not supported for ReadOnly Repositories.'
    'setmsg msg(isrz003)'
    return
  end
  x = listdsi(fulldsn)
  edsn = strip(fulldsn,'B',"'")
  r = dsn
  eok = 1
  if is_binfile(dsn'/'mem) = 1 then do
    zerrsm = 'Invalid'
    zerrlm = 'Unable to Edit a binary dataset.'
    'setmsg msg(isrz003)'
    eok = 0
    zsel = null
  end
  if eok = 1 then do
    'control display save'
    if translate(zdsn.dsn) = 'MD'
       then emac = 'macro(zigiemmd)'
       else emac = null
    if sysdsorg = 'PS'
    then "Edit Dataset('"edsn"')" emac
    else "Edit Dataset('"edsn"("mem")')" emac
    erc = rc
    'control display restore'
  end
  else erc = 1
  if erc = 0 then
     call copy_pds_mem
  Return

Copy_PDS_Mem:
    m = strip(mem)
    if zdsn.dsn /= null
    then m = lower(m)'.'zdsn.dsn
    m = m
    e = edsn
    r = dsn
    /* Binary v1, check if PDS is a bin, then copy binary */
    binopt = null
    if is_binfile(dsn'/*') = 1 then
       binopt = '-B'
    if binfile = null then
    if is_binfile(dsn'/'mem) = 1 then
       binopt = '-B'
    /* Check if a Load Library and update binary option variable */
    cplmod = null
    if sysrecfm = 'U' then
    if sysdsorg = 'PO' then do
      binopt = null
      cplmod = '-X -I'
    end
    if sysdsorg = 'PS' then do
      copycmd = "//'"e"'"
      r = r'/'
    end
    if sysdsorg = 'PO' then do
      if pos('.',m) > 0
         then parse value m with mc'.' .
         else mc = m
      copycmd = "//'"e"("mc")'"
      r = r'/'m
    end
    if strip(binopt cplmod) = null
    then binopt = '-T'
    copycmd = '"'copycmd'"'
    copycmd = "cp "binopt cplmod" -U -v" copycmd" "localrep"/"zigirep
    copycmd = copycmd || "/"r
    x = do_copy(copycmd)
    if x > 0 then call view_std 'B'
    if strip(binopt''cplmod) /= '-T' then do
      tagcmd = 'chtag -b 'localrep'/'zigirep'/'r
      x = docmd(tagcmd)
    end
    call update_mem_ispf_stats r mem
    call update_mem_status r mem
     zigi_changed = 1
  Return

Update_Mem_ISPF_Stats:
    "LMINIT DATAID(zstats) DATASET("fulldsn")"
    "LMOPEN DATAID("zstats") OPTION(INPUT)"
    'LMMSTATS DATAID('zstats') Member('mem')'
    'LMMFIND  DATAID('zstats') Member('mem') Stats(yes)'
    "LMClose Dataid("zstats")"
    "LMFree  Dataid("zstats")"
   return

Update_mem_status:
  /* r = dsn/mem */
  parse arg ums_file ums_mem
  cmd = 'cd' localrep'/'zigirep
  cmd = cmd '&& git status --porcelain' ums_file
  x = docmd(cmd)
  if so.0 = 1 then do
    memstat = porcelain(left(so.1,2))
    s_mem = mem
    mem = ums_mem
    'tbmod' rtll
    mem = s_mem
  end

  /* fixup dsn status */
  dsnstat = fixup_dsn_status(memstat dsnstat)
  'tbmod' rtbl

  if enhanced_cp = 0 then do
      x = zigistat(fulldsn localrep'/'zigirep'/.zigi/'dsn 'S')
      end
  else do
    uscmd = localrep'/'zigirep'/.zigi/'dsn fulldsn
    call update_stats uscmd
  end
  cmd = 'cd' localrep'/'zigirep
  cmd = cmd '&& git add .zigi/'dsn
  x = docmd(cmd)
  return

FixUp_DSN_Status:
  mstat = memstat
  parse value mstat with '['mstat']' .
  parse value dstat with '['dstat']' .
  if pos(']',memstat) = 0 then return dsnstat
  if pos(']',dsnstat) = 0 then do
    dstat = memstat
    return dstat
  end
  if left(dstat,1) = ' ' then
  dstat = overlay(left(mstat,1),dstat,1,1)
  if right(dstat,1) = ' ' then
  dstat = overlay(right(mstat,1),dstat,2,1)
  return porcelain(dstat)

  /* ------------------- *
  | reName a PDS Member |
  * ------------------- */
WWRF_handle_lcmd_rn:
  if readonly = 1 then do
    zerrsm = 'Invalid.'
    zerrlm = 'Rename (RN) is not supported for ReadOnly Repositories.'
    'setmsg msg(isrz003)'
    return
  end
  do forever
    newmem = mem
    call pfshow 'off'           /* make sure pfshow is off */
    'Addpop row(4) column(6)'
    'display panel(zigirenm)'
    drc = rc
    'rempop'
    call pfshow 'reset'         /* restore pfshow setting */
    if drc > 0 then leave
    newdsn = "'"strip(fulldsn,'B',"'")"("newmem")'"
    call outtrap 'x.'
    rc = sysdsn(newdsn)
    call outtrap 'off'
    if rc = 'OK' then do
      zerrsm = 'Error'
      zerrlm = newmem 'currently exists. Select a different' ,
        'member name for the rename operation.'
      'setmsg msg(isrz003)'
    end
    else do
     /* ----------------------------------- *
      | Use ISPF Services for Member Rename |
      * ----------------------------------- */
      Address ISPEXEC
      "LMINIT DATAID(STATUS) DATASET("fulldsn") ENQ(SHRW)"
      "LMOPEN DATAID("STATUS") OPTION(output)"
      'lmmren dataid('status') member('mem') newname('newmem')'
      "LMClose Dataid("status")"
      "LMFree  Dataid("status")"

      if zdsn.dsn /= null then do
        rnmem = lower(mem)'.'zdsn.dsn
        rnnewmem = lower(newmem)'.'zdsn.dsn
      end
      else do
        rnmem = mem
        rnnewmem = newmem
      end
      cmd = 'cd' localrep'/'zigirep'/'dsn
      cmd = cmd '&& git mv' rnmem rnnewmem
      x = docmd(cmd)
      call view_std 'B'
      'tbdelete' rtll
      mem = newmem
      'tbadd' rtll 'Order'
      zerrsm = 'Renamed.'
      zerrlm = mem 'has been renamed in ZIGI, git, z/OS, and OMVS.'
      'setmsg msg(isrz003)'
      call update_mem_status dsn'/'rnnewmem mem
      leave
    end
  end
  Return

  /* --------------------------------- *
  | Remove a PDS member from the Repo |
  * --------------------------------- */
WWRF_handle_lcmd_rm:
  if readonly = 1 then do
    zerrsm = 'Invalid.'
    zerrlm = 'Remove (RM) is not supported for ReadOnly Repositories.'
    'setmsg msg(isrz003)'
    return
  end
  rmdir = localrep'/'zigirep'/'dsn
  call outtrap 'x.'
  rdsn = strip(fulldsn,'B',"'")
  rdsn = "'"rdsn"("mem")'"
  rc = confirm_remove(rdsn)
  if rc = 0 then do
    Address TSO ,
      'Delete' rdsn
    call outtrap 'off'
    if zdsn.dsn /= null then do
      rmem = lower(mem)'.'zdsn.dsn
    end
    else rmem = mem
    m = rmem
    xldir = rmdir
    cmd = 'cd' xldir
    if pos('??',memstat) = 0
    then cmd = cmd '&& git rm -f "'m'"'
    else cmd = cmd '&& rm -f' m
    x = docmd(cmd,,so.,se.)
    memstat = '*Removed'
    'tbmod' rtll
    zerrsm = 'Removed.'
    zerrlm = m 'has been removed from ZIGI, from git, and has' ,
      'been deleted from z/OS and OMVS.'
    'setmsg msg(isrz003)'
    baction = 'Changes to be committed:'
    statfile = translate(strip(fulldsn,'B',"'"),' ','.')
    if qualignr > 0 then
    statfile = subword(statfile,qualignr+1)
    statfile = translate(statfile,'.',' ')
    cmd = 'cd' localrep'/'zigirep'/.zigi/'
    stats = statfile
    if enhanced_cp = 0 then
    x = zigistat(fulldsn localrep'/'zigirep'/.zigi/'stats 'S')
    else do
      uscmd = localrep'/'zigirep'/.zigi/'stats fulldsn
      call update_stats uscmd
    end
    cmd = 'cd' localrep'/'zigirep
    cmd = cmd || '&& git add -v .zigi/'stats
    x = docmd(cmd)
    if x > 0 then call view_std 'B'
    zigi_changed = 1
  end
  else do
    zerrsm = 'Canceled.'
    zerrlm = 'Removal of' rdsn 'canceled.'
    'setmsg msg(isrz003)'
  end
  Return

  /* --------------------------------- *
  | Add member of PDS to staging area |
  | as a binary member and copy/tag it|
  * --------------------------------- */
WWRF_handle_lcmd_ab:
  dsna = translate(strip(fulldsn,'B',"'"),' ','.')
  add_count = 0
  dsnapfx = pdshlq
  sa_dsna = dsna
  dsna = strip(fulldsn,'B',"'")'('mem')'
  call do_add_copy 'binary'
  parse value dsn with dsn'/'mem
  dsna = sa_dsna
  call git_add_member
  zigi_changed = 1
  if zdsn.dsn /= null then
  mem = lower(zdsn.dsn'.'mem)
  mtype = 'B'
  'tbmod' rtll
  r = dsn'/'mem
  if ztdsels < 2 then do
    call get_binfiles
  end
  Return

  /* -------------------------------- *
  | Show the diff for the member     |
  * -------------------------------- */
WWRF_handle_lcmd_d:
  d = dsn
  cmd = 'cd' localrep'/'zigirep'/'d
  m = mem
  if zdsn.dsn /= null then
  m = lower(m)'.'zdsn.dsn
  x = docmd(cmd ' && git diff 'm)
  if so.0 + se.0 > 0
  then call View_std 'X' 'V'
  else do
    zerrsm = 'No Diff'
    zerrlm = 'No differnce found.'
    'Setmsg msg(isrz003)'
  end
  Return

  /* --------------------- *
  | Git Ignore the member |
  * --------------------- */
WWRF_handle_lcmd_i:
  d = dsn
  m = mem
  if zdsn.dsn /= null then
  m = lower(m)'.'zdsn.dsn
  fdsn = d'/'m
  cmd = "echo '"fdsn"' >> "localrep"/"zigirep"/.gitignore"
  x = docmd(cmd)
  call view_std 'B'
  memstat = '[  ] Git Ignored'
  'tbmod' rtll
  return

WWRF_handle_lcmd_z:
  if zdsn.dsn /= null
  then m = lower(mem)'.'zdsn.dsn
  else m = mem
  fdsn = localrep'/'zigirep'/'dsn'/'m
  'control display save'
  'View file(fdsn)'
  'control display restore'
  return

  /* ============================================================== */
  /* ======== generic support functions       ===================== */
  /* ============================================================== */

Setup_Selective_Replace:
  parse arg ssrmsg
  parse value '' with pulldsns pullmems. deletes.
  deletes.0 = 0
  pulled = 0
  ptype = 0
  do pi = 1 to so.0
    so.pi = translate(so.pi,' ','05'x)
    if word(so.pi,1) = 'Removing' then do
      if left(w,1) = '.' then iterate
      dc = deletes.0 + 1
      deletes.dc = w
      deletes.0 = dc
    end
    if word(so.pi,1) = 'deleted:' then do
      if left(w,1) = '.' then iterate
      dc = deletes.0 + 1
      deletes.dc = w
      deletes.0 = dc
      if pos('/',w) > 0 then do
        parse value w with w'/'.
        if wordpos(w,pulldsns) = 0 then
        pulldsns = pulldsns w
      end
    end
    if pos('new file:',so.pi) > 0 then do
      w = word(so.pi,3)
      if left(w,1) = '.' then iterate
      if pos('/',w) > 0 then do
        parse value w with w'/'m
        if wordpos(w,pulldsns) = 0 then
        pulldsns = pulldsns w
        pullmems.w = pullmems.w m
      end
      else if wordpos(w,pulldsns) = 0 then
      pulldsns = pulldsns w
    end
    if pos('modified:',so.pi) > 0 then do
      w = word(so.pi,2)
      if left(w,1) = '.' then iterate
      if pos('/',w) > 0 then do
        parse value w with w'/'m
        if wordpos(w,pulldsns) = 0 then
        pulldsns = pulldsns w
        pullmems.w = pullmems.w m
      end
      else if wordpos(w,pulldsns) = 0 then
      pulldsns = pulldsns w
    end
    if ptype = 1 then do  /* status report */
      if left(so.pi,1) /= ' ' then iterate
      if pos(' changed,',so.pi) > 0 then do
        pullmsg = so.pi
        pulled = 1
        iterate
      end
      if word(so.pi,1) = 'rename' then do
        if pos('/',so.pi) > 0 then do
          parse value so.pi with . dd'/{'dm '=>' nm'}' .
          dc = deletes.0 + 1
          deletes.dc = strip(dd)'/'strip(dm)
          deletes.0 = dc
          if wordpos(dd,pulldsns) = 0 then do
            pulldsns = pulldsns dd
            pullmems.dd = nm
          end
          else pullmems.dd = pullmems.dd nm
        end
        else do
          parse value so.pi with . dd '=>' nd .
          dc = deletes.0 + 1
          deletes.dc = strip(dd)
          deletes.0 = dc
          if wordpos(nd,pulldsns) = 0 then
          pulldsns = pulldsns nd
        end
      end
      if word(so.pi,1) = 'delete' then
      if word(so.pi,2) = 'mode' then do
        delds = word(so.pi,4)
        dhit = 1
        if left(delds,1) = '.' then dhit = 0
        if dsnvalid(delds) = 'NO' then dhit = 0
        if dhit = 1 then do
          dc = deletes.0 + 1
          deletes.dc = delds
          deletes.0 = dc
        end
      end
      if left(so.pi,5) = 'From' then leave
      pidsn = word(so.pi,1)
      if left(pidsn,1) = '.' then iterate
      parse value pidsn with pidsn'/'pimem
      if wordpos(pidsn,pulldsns) = 0 then do
        pulldsns = pulldsns pidsn
        pullmems.pidsn = pimem
      end
      else pullmems.pidsn = pullmems.pidsn pimem
    end
    if ptype = 2 then do  /* stash report */
      w = word(so.pi,1)
      if left(w,1) = '.' then iterate
      if pos('/',w) = 0 then do
        if pos('=>',so.pi) = 0 then do
          if wordpos(w,pulldsns) = 0 then
          pulldsns = pulldsns w
        end
        else do
          parse value so.pi with wd '=>' w
          dc = deletes.0 + 1
          deletes.dc = wd
          deletes.0 = dc
          if wordpos(w,pulldsns) = 0 then
          pulldsns = pulldsns w
        end
      end
      else do
        parse value w with w'/'m
        if pos('{',m) > 0 then do
          parse value m with '{'dm '=>' nm'}' .
          dc = deletes.0 + 1
          deletes.dc = w'/'dm
          deletes.0 = dc
          pullmems.w = pullmems.w nm
          if wordpos(w,pulldsns) = 0 then
          pulldsns = pulldsns w
        end
        else do
          pullmems.w = pullmems.w m
          if wordpos(w,pulldsns) = 0 then
          pulldsns = pulldsns w
        end
      end
    end
  end
  call do_post_pull 'Stash Pop'
  return

Do_Post_Pull:
  if strip(pulldsns) = null then do
    zerrsm = 'Nothing'
    zerrlm = 'No updates to process for' ssrmsg
    'setmsg msg(isrz003)'
    return
  end
  /* ------------------------------------------------- *
  | Validate all the Pulldsns and remove if not valid |
  * ------------------------------------------------- */
  do ip = words(pulldsns) to 1 by -1
    w = word(pulldsns,ip)
    if dsnvalid(w) = 'OK' then iterate
    pulldsns = delword(pulldsns,ip,1)
  end
  /* create the ispf variable with member names for
  the dataset using the dataset offset in pulldsns
  for the variable suffix */
  if qualignr = 0
  then delhlq = pdshlq
  else do
    delhlq = translate(pdshlq,' ','.')
    if qualignr /= '*' then
    delhlq = subword(delhlq,1,qualignr)
    delhlq = translate(delhlq,'.',' ')
  end
  do zz = 1 to words(pulldsns)
    zd = word(pulldsns,zz)
    zw = words(pullmems.zd)
    ldsn = "'"delhlq"."zd"'"
    x = listdsi(ldsn "dir")
    /* check if a PDSE and bypass the full Replace or if not
    a PDSE then check of more than 25% of members being
    updated and if so then nullify the member list so a full
    Replace will occur for the dataset */
    if x = 0 then
    if sysmembers /= null then
    if sysadirblk /= 'NO_LIM' then
    if sysmembers/zw < 4 then pullmems.zd = ''
    interpret 'zv'zz '= (pullmems.zd)'
    'vput zv'zz
  end
  if pulldsns /= null then do
    call Replace localrep zigirep pdshlq qualignr pulldsns
    if qualignr = 0
    then delhlq = pdshlq
    else do
      delhlq = translate(pdshlq,' ','.')
      if qualignr /= '*' then
      delhlq = subword(delhlq,1,qualignr)
      delhlq = translate(delhlq,'.',' ')
    end
    'Verase pulldsns Both'
    call check_for_more_deletes
    call outtrap 'x.'
    if deletes.0 > 0 then
    do dc = 1 to deletes.0
      if pos('/',deletes.dc) = 0
      then do
        delds =  "'"delhlq"."deletes.dc"'"
        dm.dc = delds
        Address TSO 'Delete' delds
        cmd = 'cd' localrep'/'zigirep
        cmd = cmd '&& rm' deletes.dc
        x = docmd(cmd)
      end
      else do
        parse value deletes.dc with delds'/'mem
        mem = strip(mem)
        dm.dc = "'"delhlq"."delds"("mem")'"
        call delete_member "'"delhlq"."delds"'" mem
        cmd = 'cd' localrep'/'zigirep'/'delds
        cmd = cmd '&& rm -f' mem
        x = docmd(cmd)
      end
    end
    call outtrap 'off'
    do id = 1 to deletes.0
      so.id = 'Deleted:' dm.id
    end
    so.0 = deletes.0
    se.0 = 0
    call update_repo_metadata
  end
  if pulled > 0 then do
    zerrsm = 'Successful.'
    zerrlm = left(ssrmsg 'was a success.',76) pullmsg
    'setmsg msg(isrz003)'
  end
  return

  /* ----------------------- *
  | Git Add Dataset Routine |
  * ----------------------- */
git_add:
  zs1 = 'Adding' fulldsn
  zs2 = 'Making it ready to Commit'
  call do_popup
  /* Comment Start
  if left(dsn,1) = "'"
  then d = dsn
  else d = '"'dsn'"'
     Comment End */
  call git_safe_add localrep'/'zigirep dsn
  if dsnvalid(fulldsn) = "OK" then do
    /* Only get the stats if it's a z/OS dataset
    Don't do it for the USS files
    */
    x = listdsi(fulldsn)
    use_enhanced_cp = enhanced_cp
    if sysrecfm = 'U' then use_enhanced_cp = 0
    if x = 0 then do
      if sysdsorg /= 'PS' then do
        statfile = remove_dsn_hlq(fulldsn)
        stats = statfile
        if use_enhanced_cp = 0 then
        x = zigistat(fulldsn localrep'/'zigirep'/.zigi/'stats 'S')
        else do
          uscmd = localrep'/'zigirep'/.zigi/'stats fulldsn
          call update_stats uscmd
        end
        cmd = 'cd' localrep'/'zigirep'/.zigi/'
        x = docmd(cmd '&& git add -v 'stats)
        if x > 0 then call view_std 'B'
      end
    end
  end
  return

  /* ------------------------------------------------- *
  | Stash the current workspace                       |
  | git stash push -u -a -m "date time"               |
  | then                                              |
  | git stash show (to get the affected datasets)     |
  |                                                   |
  | generate a replace based on the affected datasets |
  * ------------------------------------------------- */
Stash_IT:
  if readonly = 1 then do
    zerrsm = 'Invalid.'
    zerrlm = 'STASH is not supported for ReadOnly Repositories.'
    'setmsg msg(isrz003)'
    return
  end
  cmd = 'cd' localrep'/'zigirep '&& git status'
  x = docmd(cmd)
  sol = so.0
  if wordpos('nothing',so.sol) > 0 then do
     zerrsm = 'No Stash.'
     zerrlm = 'Stash will not work with a clean git environment.'
     'setmsg msg(isrz003)'
     return
     end
  stashmsg = null
  call pfshow 'off'           /* make sure pfshow is off */
  'addpop row(3) column(4)'
  'display panel(zigistaq)'
  drc = rc
  'rempop'
  call pfshow 'reset'         /* restore pfshow setting */
  if drc > 0 then do
    zerrsm = 'Canceled.'
    zerrlm = 'Stash canceled.'
    'setmsg msg(isrz003)'
    return
  end
  zs1 = 'Initiating git stash processing.'
  zs2 = 'Please be patient while git does its thing.'
  call pfshow 'off'           /* make sure pfshow is off */
  'addpop row(3) column(4)'
  'control display lock'
  'display panel(zigipop)'
  'rempop'
  call pfshow 'reset'         /* restore pfshow setting */
  cmd = 'cd' localrep'/'zigirep
  cmd = cmd '&& git stash push -a -u -m "'date() time() stashmsg'"'
  cmd = cmd '&& git stash show'
  x = docmd(cmd)
  call view_std 'B'
  deletes.0 = 0
  parse value '' with pulldsns pullmems. renames.
  renames.0 = 0
  dc = 0
  do stashi = 1 to so.0
    if pos('|',so.stashi) = 0 then iterate
    parse value so.stashi with w '|' c
    w = strip(w)
    if left(w,1) = '.' then iterate
    Select
      when pos('->',c) > 0 then do
        if pos('0 bytes',c) > 0 then do
          if pos('/',w) = 0 then do
            cmd = 'cd' localrep'/'zigirep
            cmd = cmd '&& rm' w
            x = docmds(cmd)
          end
          else do
            parse value w with w'/'m
            cmd = 'cd' localrep'/'zigirep'/'w
            cmd = cmd '&& rm' w
            x = docmds(cmd)
            if wordpos(w,pulldsns) = 0 then
            pulldsns = pulldsns w
          end
        end
      end
      when pos('{',w) > 0 then do   /* rename */
        parse value w with w'/'m
        if wordpos(w,pulldsns) = 0 then
        pulldsns = pulldsns w
        parse value m with '{'dm '=>' nm'}' .
        pullmems.w = pullmems.w nm
        rn = renames.0 + 1
        renames.rn = w'/'dm w'/'nm
        renames.0 = rn
      end
      when pos('=>',w) = 0 then do
        if pos('/',w) = 0 then
        if wordpos(w,pulldsns) = 0 then
        pulldsns = pulldsns w
        if pos('/',w) > 0 then do
          parse value w with w'/'m
          if wordpos(w,pulldsns) = 0 then
          pulldsns = pulldsns w
          pullmems.w = pullmems.w m
        end
      end
      when pos('=>',w) > 0 then do   /* Rename */
        parse value w with wd '=>' w
        w = strip(w)
        if pos('/',w) = 0 then
        if wordpos(w,pulldsns) = 0 then
        pulldsns = pulldsns w
        if pos('/',w) > 0 then do
          parse value w with w'/'m
          if wordpos(w,pulldsns) = 0 then
          pulldsns = pulldsns w
          pullmems.w = pullmems.w m
        end
        else do
          rn = renames.0 + 1
          renames.rn = wd w
          renames.0 = rn
        end
      end
      Otherwise nop
    end
  end
  call do_post_pull 'Stash Push/Save'
  do rename_i = 1 to renames.0
    parse value renames.rename_i with newname oldname
    if pos('/',newname) = 0 then do
      call outtrap 'x.'
      address tso ,
        'rename' Add_DSN_HLQ(oldname) Add_DSN_HLQ(newname)
      call outtrap 'off'
    end
    else do
      parse value newname with d'/'m
      newname = Add_DSN_HLQ(d'('m')')
      parse value oldname with d'/'m
      oldname = Add_DSN_HLQ(d'('m')')
      call outtrap 'x.'
      address tso ,
        'rename' Add_DSN_HLQ(oldname) Add_DSN_HLQ(newname)
      call outtrap 'off'
    end
  end
  zerrsm = 'Complete.'
  zerrlm = 'Stash Push (save) completed.'
  'setmsg msg(isrz003)'
  return

  /* ---------------------------------------------------------- *
  | Add_DSN_HLQ take the input dataset name, the active pdshlq |
  | and qualignr. Then returns the fully qualified, in quotes, |
  | dataset name.                                              |
  |                                                            |
  | Calling parm: OMVS-filename HLQ                            |
  | where HLQ is optional and will default to the active       |
  | pdshlq value.                                              |
  * ---------------------------------------------------------- */
Add_DSN_HLQ:
  arg addsn newhlq
  if newhlq = null
  then adwhlq = pdshlq
  else adwhlq = newhlq
  if length(qualignr) = 0 then qualignr = 0
  if datatype(qualignr) /= 'NUM' then qualignr = 0
  if qualignr = 0
  then nhlq = null
  else do
    nhlq = translate(adwhlq,' ','.')
    if qualignr /= '*' then
    nhlq = subword(nhlq,1,qualignr)
    nhlq = translate(nhlq,'.',' ')'.'
  end
  addsn = "'"nhlq""addsn"'"
  return addsn

Remove_DSN_HLQ:
  arg rmdsn
  rmdsn = translate(strip(rmdsn,'B',"'"),' ','.')
  if qualignr > 0 then
  rmdsn = subword(rmdsn,qualignr+1)
  rmdsn = translate(rmdsn,'.',' ')
  return rmdsn

  /* ------------------------------------------------ *
  | Process the stashl (stash list) command:         |
  | - issue git stash list to get a list of stashes  |
  | - display them in a table                        |
  | - selection commands will be:                    |
  |   BRanch - git stash branch-name stash-#   (B)   |
  |     - do a replace for affected datasets         |
  |   DIFF - git stash show # -p (then view)   (D)   |
  |   Remove - git stash drop stash-#          (R)   |
  |   POP  - git stash pop #                   (P)   |
  |   SHOW - git stash show #                  (S)   |
  | - Commands                                       |
  |   CLEAR - git stash clear  (removed ALL stashes) |
  * ------------------------------------------------ */
Stash_List:
  if readonly = 1 then do
    zerrsm = 'Invalid.'
    zerrlm = 'STASHList is not supported for ReadOnly Repositories.'
    'setmsg msg(isrz003)'
    return
  end
  cmd = 'cd' localrep'/'zigirep
  cmd = cmd '&& git stash list'
  x = docmd(cmd)
  hit = 0
  do sti = 1 to so.0
    if left(so.sti,5) /= 'stash' then iterate
    parse value so.sti with stashid':' stashcmt
    if hit = 0 then do
      stab = 'STAB'random(9999)
      'tbcreate' stab 'names(stashid stashcmt) nowrite'
    end
    'tbadd' stab 'order'
    hit = 1
  end
  if hit = 0 then do
    zerrsm = 'Nothing.'
    zerrlm = 'No stashes have been found.'
    'setmsg msg(isrz003)'
    return
  end
  ztop = 1
  ztdsels = 0
  do forever
    zsel = null
    if ztdsels > 1 then do
      'tbdispl' stab
    end
    else do
      'tbtop' stab
      'tbskip' stab 'number(ztop)'
      'tbdispl' stab 'panel(zigistab)'
    end
    if rc > 4 then do
      'tbend' stab
      return
    end
    ztop = ztdtop
    if zcmd = 'CLEAR' then do
      'tbend' stab
      cmd = 'cd' localrep'/'zigirep
      cmd = cmd '&& git stash clear'
      x = docmd(cmd)
      zerrsm = 'Cleared.'
      zerrlm = 'All stashes have been removed from the repository.'
      'setmsg msg(isrz003)'
      return
    end
    if zsel = '/' then do
      call pfshow 'off'           /* make sure pfshow is off */
      'addpop row(3) column(4)'
      'display panel(zigirsth)'
      drc = rc
      'rempop'
      call pfshow 'reset'         /* restore pfshow setting */
      if drc > 0 then zsel = null
    end
    if zsel /= null then
    Select
      When zsel = 'B' then do   /* branch */
        bname = null
        call pfshow 'off'           /* make sure pfshow is off */
        'addpop row(3) column(4)'
        'display panel(zigistbq)'
        drc = rc
        'rempop'
        call pfshow 'reset'         /* restore pfshow setting */
        if drc > 0 then do
          zerrsm = 'Canceled.'
          zerrlm = 'Stash Branch canceled.'
          'setmsg msg(isrz003)'
        end
        else do
          cmd = 'cd' localrep'/'zigirep
          cmd = cmd '&& git stash branch' bname stashid
          x = docmd(cmd)
          call view_std 'B'
          call Setup_Selective_Replace 'Stash Branch'
          'tbdelete' stab
        end
      end
      When zsel = 'P' then do   /* pop */
        abort = 0
        pass = 0
        stash_hit = do_stash_pop()
        if stash_hit = 1 then do
          call pfshow 'off'           /* make sure pfshow is off */
          'Addpop row(3) column(4)'
          'display panel(zigispbd)'
          'rempop'
          call pfshow 'reset'         /* restore pfshow setting */
        end
        else do
          'tbdelete' stab
          call Setup_Selective_Replace 'Stash Pop'
          zerrsm = 'Completed.'
          zerrlm = 'Stash pop processing completed for' stashid
          'setmsg msg(isrz003)'
          zsel = null
          leave
        end
      end
      When zsel = 'R' then do   /* remove/drop */
        cmd = 'cd' localrep'/'zigirep
        cmd = cmd '&& git stash drop' stashid
        x = docmd(cmd)
        call view_std 'B'
        sid = stashid
        'tbdelete' stab
        zerrsm = 'Removed.'
        zerrlm = 'Stash entry removed.' sid
        'setmsg msg(isrz003)'
      end
      When zsel = 'S' then do   /* show */
        cmd = 'cd' localrep'/'zigirep
        cmd = cmd '&& git stash show' stashid
        x = docmd(cmd)
        call view_std 'B'
      end
      When zsel = 'D' then do   /* show diff */
        cmd = 'cd' localrep'/'zigirep
        cmd = cmd '&& git stash show -p' stashid
        x = docmd(cmd)
        call view_std 'B' 'V'
      end
      Otherwise do
        zerrsm = 'Unknown.'
        zerrlm = zsel 'is an unknown line selection - try again.'
        'setmsg msg(isrz003)'
      end
    end
  end /* end of do forever */
  return

Do_Stash_Pop:
  x = git_clean_check()
  if x > 0 then return 1
  cmd = 'cd' localrep'/'zigirep
  cmd = cmd '&& git stash pop' stashid
  zs1 = 'Initiating git stash pop processing.'
  zs2 = 'Please be patient while git does its thing.'
  call pfshow 'off'           /* make sure pfshow is off */
  'addpop row(3) column(4)'
  'control display lock'
  'display panel(zigipop)'
  'rempop'
  call pfshow 'reset'         /* restore pfshow setting */
  xrc = docmd(cmd)
  if xrc > 0 then do
    call view_std 'B'
    Return 1
  end
  return 0

Git_Clean_Check:
  lcmd = 'cd' localrep'/'zigirep
  cmd = lcmd '&& git status -s'
  x = docmd(cmd)
  if so.0 = 0 then return 0
  return 1

  /* -------------------------------------- *
  | Set/Confirm/Change Repository Settings |
  | for Push and Userid Change             |
  * -------------------------------------- */
Do_Rset:
  zcmd = null
  pdshlqn = pdshlq
  hlq_change = 0
  extans = extfile
  zginst = 'N'
  call pfshow 'off'           /* make sure pfshow is off */
  'Addpop row(2) column(4)'
  'Display Panel(zigirset)'
  drc = rc
  'rempop'
  call pfshow 'reset'         /* restore pfshow setting */
  if drc > 0 then return
  if extans /= null then do
    extfile = extans
    'vput (extfile) profile'
  end
  if defcpush = 'Y' then zpush = 'Y'
  else zpush = 'N'

  /* ---------------------------------- *
  | Check for zginstall.rex enablement |
  * ---------------------------------- */
  if zginst = 'Y' then do
    'vput (codep)'
    rc = zigigeni(localrep'/'zigirep)
    cmd = 'cd' localrep'/'zigirep
    cmd = cmd '&& git add zginstall.rex zginstall.readme'
    x = docmd(cmd)
    call view_std 'B'
  end

  /* ------------------------------ *
  | Check for change in HLQ Prefix |
  * ------------------------------ */
  if pdshlqn /= pdshlq then do
    hlq_change = 1
    hlqnw = words(translate(pdshlqn,' ','.'))
    lr = localrep'/'zigirep
    'tbtop' rtbl
    do forever
      'tbskip' rtbl
      if rc > 0 then leave
      if left(fulldsn,1)/= "'" then iterate
      oldfile = fulldsn
      newfile = strip(fulldsn,'B',"'")
      newfile = translate(newfile,' ','.')
      newfile = "'"pdshlqn'.'subword(newfile,hlqnw+1)"'"
      newfile = translate(newfile,'.',' ')
      zs1 = 'Renaming:' oldfile
      zs2 = 'To:      ' newfile
      call do_popup
      Address TSO ,
        'Rename' oldfile newfile
      oldfile = remove_dsn_hlq(oldfile)
      newfile = remove_dsn_hlq(newfile)
      if newfile /= oldfile then do
        zs1 = 'Renaming:' lr'/'oldfile
        zs2 = 'To:      ' lr'/'newfile
        call do_popup
        address syscall 'lstat' lr'/'oldfile s.
        cmd = 'cd' lr
        cmd = cmd '&& git mv' oldfile newfile
        if s.1 = 1 then do
          cmd = cmd '&& cd .zigi'
          cmd = cmd '&& git mv' oldfile newfile
          cmd = cmd "&& sed -i s/"oldfile"/"newfile"/g dsn"
          cmd = cmd "&& sed -i s/"oldfile"/"newfile"/g ../.gitattributes"
        end
        x = docmd(cmd)
        if x > 0 then call view_std 'B'
      end
    end
    x = debug('Calling zigirefd to update last access info.')
    /* Delete the old reference date file */
    x = zigirefd(localrep'/'zigirep pdshlq qualignr 'D')
    /* reset the hlq variable */
    pdshlq = pdshlqn
    /* update/create the last reference date file */
    x = zigirefd(localrep'/'zigirep pdshlq qualignr 'U')
    x = debug('Completed the last access update.')
  end
  'tbmod zigirepo order'
  'TBSAVE zigirepo REPLCOPY LIBRARY('isptabl')'
  if defcpush = 'Y' then zpush = 'Y'
  else zpush = 'N'
  if zginst /= 'N' then do
    zerrsm = 'Updated.'
    zerrlm = 'Repository default actions updates and saved.'
    'setmsg msg(isrz003)'
  end
  if hlq_change = 1 then
  call work_with_repo
  return

  /* --------------------------------------------- *
  | Process Tag List Request with optional create |
  * --------------------------------------------- */
Get_TagList:
  all_tags = null
  cmd = 'cd' localrep'/'zigirep
  cmd = cmd "&& git for-each-ref --format" ,
    "'%(creatordate) %(refname) %(objectname) %(subject)'" ,
    "refs/tags"
  x = docmd(cmd)
  'TBCreate' zcrtbl 'Keys(ctag) Names(cdatetim ctitle chash' ,
    'sortdate sorttime) nowrite share'
  do cri = 1 to so.0
    if left(strip(so.cri),4) = 'refs' then do
      parse value so.cri with ctag ctitle
      cdatetim = 'no date'
      sortdate = 0
      sorttime = 0
    end
    else do
      parse value so.cri with day mm dd time yy gmt ctag chash ctitle
      cdatetim = yy mm dd time
      zd = dd mm yy
      sortdate = dd mm yy
      sortdate = date('b',sortdate,'n')
      sorttime = left(time,2)''substr(time,4,2)
    end
    ctag = translate(ctag,' ','/')
    ctag = word(ctag,3)
    all_tags = all_tags ctag
    chash = left(chash,7)
    'tbadd' zcrtbl
  end
  return

  /* -------------- *
  | Do Tag Summary |
  * -------------- */
Do_TAGLIST:
  zcmd = null
  crcnt = 10
  ocrcnt = 10
  zcrtbl = 'ZT'time('s')
  call get_TAGLIST
  ztdsels = 0
  ztdtop = 1
  tags = null
  'tbsort' zcrtbl 'fields(sortdate,n,d,sorttime,n,d)'
  'tbtop' zcrtbl
  do forever
    zsel = null
    if ztdsels > 1
    then 'tbdispl' zcrtbl
    else do
      'tbtop' zcrtbl
      'tbskip' zcrtbl 'number('ztdtop')'
      'tbdispl' zcrtbl 'panel(zigitagt)'
    end
    if rc > 4 then leave

    if ztdsels = 0 then
    if pnsdef = 'P' then
    if crcnt = ocrcnt then do
      if row = 0 then zcmd = 'O'
      if row > 0 then zsel = '/'
    end

    if pos('.',zcmd) > 0 then
    parse value zcmd with x'.'zcmd

    if pos(zcmd,'O/') > 0 then do
      call pfshow 'off'           /* make sure pfshow is off */
      'Addpop row(4) column(10)'
      'Display Panel(zigiotag)'
      'rempop'
      call pfshow 'reset'         /* restore pfshow setting */
    end

    if zsel = '/' then do
      call pfshow 'off'           /* make sure pfshow is off */
      'Addpop row(3) column(4)'
      'Display Panel(zigirtag)'
      'rempop'
      call pfshow 'reset'         /* restore pfshow setting */
    end

    if row /= null then do
      'tbtop' zcrtbl
      'tbskip' zcrtbl    'number('row')'
    end

    Select
      When abbrev('Replace',word(zcmd,1),1) = 1 then do
        'tbend' zcrtbl
        call get_TAGLIST
      end
      When abbrev('ONLY',word(zcmd,1),1) = 1 then do
        if words(zcmd) = 1 then do
          call pfshow 'off'           /* make sure pfshow is off */
          'addpop row(3) column(4)'
          'display panel(zigionly)'
          drc = rc
          'rempop'
          call pfshow 'reset'         /* restore pfshow setting */
          if drc > 0 then leave
          zcmd = 'O' filter
        end
        'tbtop' zcrtbl
        ohit = 0
        fw = subword(zcmd,2)
        ztdtop = 0
        do forever
          'tbskip' zcrtbl
          if rc > 0 then
          if ohit = 1 then do
            ztdtop = 1
            leave
          end
          if rc > 0 then do
            'tbend' zcrtbl
            call get_TAGLIST
            zerrsm = 'Not Found.'
            zerrlm = fw 'not found in the rollback log.'
            'Setmsg msg(isrz003)'
            ztdtop = 1
            leave
          end
          ztdtop = ztdtop + 1
          if pos(fw,translate(ctag ctitle)) = 0 then 'tbdelete' zcrtbl
          else ohit = 1
        end
      end
      when zsel = 'X' then do
        ext_type = 'T'
        tags = tags chash
        if ztdsels = 1 then
        call do_tag_extract
      end
      when zsel = 'S' then do
        cmd = 'cd' localrep'/'zigirep
        cmd = cmd '&& git show -P' ctag
        x = docmd(cmd)
        call view_std 'B'
      end
      when zsel = 'C' then do
        zcmd  = null
        newbr = null
        rolla = 'Cancel'
        call pfshow 'off'           /* make sure pfshow is off */
        'Addpop row(4) column(12)'
        'Display Panel(zigitagq)'
        prc = rc
        'Rempop'
        call pfshow 'reset'         /* restore pfshow setting */
        if prc > 0 then do
          zerrsm = 'Canceled.'
          zerrlm = 'Create branch canceled.'
          prc = 1
        end
        if prc = 0 then do
          call get_branches
          if wordpos(newbr,all_tags) > 0 then prc = 1
          if prc = 0 then
          do bi = 1 to bl.0
            if newbr = bl.bi then prc = 1
          end
        end
        if prc = 1 then
        if zerrsm = null then do
          zerrsm = 'Invalid.'
          zerrlm = newbr 'branch/tag currently exists - pick a different' ,
            'name for the branch and try again.'
          'setmsg msg(isrz003)'
          prc = 1
          newbr = null
        end
        if prc = 0 then
        if newbr /= null then do
          cmd = 'cd' localrep'/'zigirep
          drop combine.
          combine.0 = 0
          call add_combine cmd
          x = docmd(cmd ' && git checkout' ctag '-b' newbr)
          call add_combine 'git checkout' ctag '-b' newbr
          call combine_msgs
          if left(remote1,1) /= '<' then
          if zigi_offline = 0 then do
            cmd = 'cd' localrep'/'zigirep
            x = docmd(cmd ' && git push origin 'newbr)
            call add_combine 'git push origin' newbr
            branch = newb
            call combine_msgs
          end
          if combine.0 > 0 then call view_std 'C'
          call Replace localrep zigirep pdshlq qualignr
          /* --------------------------------------- *
          | Call work_with_repo with flag to return |
          * --------------------------------------- */
          call work_with_repo 'x'
          leave
        end
        if prc > 0 then do
          'setmsg msg(isrz003)'
          ztdsels = 1
        end
      end
      Otherwise nop
    end
  end
  'tbend' zcrtbl
  drop cr.
  return

Do_Extract:
  zcmd = null
  crcnt = 1000
  ocrcnt = 1000
  zcrtbl = 'ZR'time('s')
  ext_type = 'C'
  call do_extract_log
  ztdsels = 0
  ztdtop = 1
  tags = null
  'tbtop' zcrtbl
  'tbsort' zcrtbl 'fields(cdatetim,c,d)'
  do forever
    zsel = null
    if ztdsels > 1
    then 'tbdispl' zcrtbl
    else do
      'tbtop' zcrtbl
      'tbskip' zcrtbl 'number('ztdtop')'
      'tbdispl' zcrtbl 'panel(zigicomx)'
    end
    if rc > 4 then leave

    if ztdsels = 0 then
    if pnsdef = 'P' then
    if crcnt = ocrcnt then do
      if row = 0 then zcmd = 'O'
      if row > 0 then zsel = '/'
    end

    if zsel = '/' then do
      call pfshow 'off'           /* make sure pfshow is off */
      'Addpop row(4) column(10)'
      'Display Panel(zigicomo)'
      'rempop'
      call pfshow 'reset'         /* restore pfshow setting */
    end

    if pos(zcmd,'/O') > 0 then do
      zcmd = null
      call pfshow 'off'           /* make sure pfshow is off */
      'Addpop row(4) column(6)'
      'Display Panel(zigicomc)'
      'rempop'
      call pfshow 'reset'         /* restore pfshow setting */
    end

    if crcnt /= ocrcnt then do
      ocrcnt = crcnt
      'tbend' zcrtbl
      call do_extract_log
      ztdtop = 1
      zsel = null
      ztdsels = 0
      row = null
    end
    if row /= null then do
      'tbtop' zcrtbl
      'tbskip' zcrtbl    'number('row')'
    end
    Select
      When abbrev('REPLACE',word(zcmd,1),1) = 1 then do
        'tbend' zcrtbl
        call do_extract_log
      end
      When abbrev('ONLY',word(zcmd,1),1) = 1 then do
        if words(zcmd) = 1 then do
          call pfshow 'off'           /* make sure pfshow is off */
          'addpop row(3) column(4)'
          'display panel(zigionly)'
          drc = rc
          'rempop'
          call pfshow 'reset'         /* restore pfshow setting */
          if drc > 0 then leave
          zcmd = 'O' filter
        end
        'tbtop' zcrtbl
        ohit = 0
        fw = subword(zcmd,2)
        ztdtop = 0
        do forever
          'tbskip' zcrtbl
          if rc > 0 then
          if ohit = 1 then do
            ztdtop = 1
            leave
          end
          if rc > 0 then do
            'tbend' zcrtbl
            call do_extract_log
            zerrsm = 'Not Found.'
            zerrlm = fw 'not found in the rollback log.'
            'Setmsg msg(isrz003)'
            ztdtop = 1
            leave
          end
          ztdtop = ztdtop + 1
          if pos(fw,translate(ctitle)) = 0 then 'tbdelete' zcrtbl
          else ohit = 1
        end
      end
      when zsel = 'X' then do
        tags = tags ctag
        if ztdsels = 1 then
        call do_tag_extract
      end
      when zsel = 'S' then do
        zsel = null
        drop so. se.
        cmd = 'cd' localrep'/'zigirep
        cmd = cmd '&& git show -P' ctag
        x = docmd(cmd)
        call view_std 'B' 'V'
      end
      when zsel = 'R' then do
        zcmd  = null
        zsel  = null
        newbr = null
        rolla = 'Cancel'
        call pfshow 'off'           /* make sure pfshow is off */
        'Addpop row(4) column(12)'
        'Display Panel(zigipoph)'
        prc = rc
        'Rempop'
        call pfshow 'reset'         /* restore pfshow setting */
        if prc > 0 then do
          zerrsm = 'Canceled.'
          zerrlm = 'Rollback canceled.'
          'setmsg msg(isrz003)'
          prc = 1
          newbr = null
          return
        end
        call get_branches
        bad = 0
        do bi = 1 to bl.0
          if newbr = bl.bi then bad = 1
        end
        if bad = 1 then do
          zerrsm = 'Invalid.'
          zerrlm = newbr 'branch currently exists - pick a different' ,
            'name for the branch and try again.'
          'setmsg msg(isrz003)'
          prc = 1
          newbr = null
        end
        if prc = 0 then
        if newbr /= null then do
          cmd = 'cd' localrep'/'zigirep
          drop combine.
          combine.0 = 0
          call add_combine cmd
          x = docmd(cmd ' && git checkout -b' newbr ctag)
          call add_combine 'git checkout -b' newbr ctag
          call combine_msgs
          if zigi_offline = 0 then
          if left(remote1,1) /= '<' then do
            cmd = 'cd' localrep'/'zigirep
            x = docmd(cmd ' && git push origin 'newbr)
            call add_combine 'git push origin' newbr
            branch = newb
            call combine_msgs
          end
          if combine.0 > 0 then call view_std 'C'
          call Replace localrep zigirep pdshlq qualignr
          call work_with_repo
        end
        if prc > 1 then do
          zerrsm = 'Canceled.'
          zerrlm = 'Rollback canceled.'
          'setmsg msg(isrz003)'
          ztdsels = 1
        end
        if prc > 1 then leave
      end
      Otherwise nop
    end
  end
  'tbend' zcrtbl
  drop cr.
  return

Do_Extract_Log:
  'TBCreate' zcrtbl 'Keys(ctag) Names(cdatetim ctitle) nowrite share'
  cmd = 'cd' localdir
  if ext_type = 'T' then do
    x = docmd(cmd '&& git log --cc -n' ocrcnt)
    do cri = 1 to so.0
      parse value so.cri with 'refs/tags/'ctag dow mon day time year . ctitle
      mon = wordpos(mon,'Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec')
      cdatetim = year'/'right(mon+100,2)'/'right(day+100,2) time
      'tbadd' zcrtbl
    end
  end
  else do
    x = docmd(cmd "&& git log -n" ocrcnt "--abbrev=commit" ,
      " --pretty=format:'%H    %cd subject:%f'")
    do cri = 1 to so.0
      parse value so.cri with ctag dow mon day time year . 'subject:'ctitle
      ctag = left(ctag,7)
      mon = wordpos(mon,'Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec')
      cdatetim = year'/'right(mon+100,2)'/'right(day+100,2) time
      'tbadd' zcrtbl
    end
  end
  return

  /* ------------------- *
  | Grep the repository |
  * ------------------- */
do_grep:
  parse arg grepdir
  zcmd = null
  do forever
    call pfshow 'off'           /* make sure pfshow is off */
    'Addpop row(4) column(6)'
    'display panel(zigigrep)'
    drc = rc
    'Rempop'
    call pfshow 'reset'         /* restore pfshow setting */
    if drc > 0 then leave
    cmd = 'cd' grepdir
    x = docmd(cmd '&& git grep -i "'grepstr'"')
    select
      when x = 1 then do
        zerrsm = null
        zerrlm = 'grep search found nothing.'
        'setmsg msg(isrz003)'
      end
      when grepopt = 'R' then do
        call View_std 'B'
      end
      when grepopt = 'D' then do
        pdshlqt = translate(pdshlq,' ','.')
        if qualignr > 0 then
        pdshlqt = subword(pdshlqt,1,qualignr)
        pdshlqt = translate(pdshlqt,'.',' ')
        parse value '' with dsntbl gstat
        gcount = 0
        zgreptbl = 'ZG'time('s')
        'TBCreate' zgreptbl 'Keys(gdsn) Names(gstat gcount) nowrite share'
        do si = 1 to so.0
          if left(so.si,1) = '.' then iterate
          mem = null
          parse value so.si with gdsn":" .
          if pos('/',gdsn) > 0 then do
            parse value gdsn with gdsn'/'mem':' .
            if zdsn.gdsn /= null then
            parse value mem with mem'.'.
            if dsnvalid(gdsn) = 'OK'
            then do
                 gdsn = gdsn'('translate(mem)')'
                 end
            else gdsn = gdsn'/'mem
          end
          if left(gdsn,1) /= "'" then
            gdsnt = "'"pdshlqt"."strip(gdsn)"'"
          if lower_check(gdsnt) = 0 then
          if pos('/',gdsnt) = 0 then do
            call outtrap 'x.'
            if sysdsn(gdsnt) = 'OK' then gdsn = gdsnt
            call outtrap 'off'
          end
          if wordpos(gdsn,dsntbl) > 0
          then do
            gcount = gcount + 1
            'tbmod' zgreptbl
          end
          else do
            gcount = 1
            'tbadd' zgreptbl
            dsntbl = dsntbl gdsn
          end
        end
        ztdsels = 0
        ztdtop = 1
        file_changed = 0
        'tbtop' zgreptbl
        'tbsort' zgreptbl 'fields(gdsn,c,a)'
        do forever
          if ztdsels > 1
          then 'tbdispl' zgreptbl
          else do
            'tbtop' zgreptbl
            'tbskip' zgreptbl 'number('ztdtop')'
            'tbdispl' zgreptbl 'panel(zigigrds)'
          end
          if rc > 4 then leave

          if ztdsels = 0 then
          if pnsdef = 'P' then do
            if row = 0 then zcmd = 'O'
            if row > 0 then zsel = '/'
          end

          if zsel = null then iterate
          if row /= null then do
            'tbtop' zgreptbl
            'tbskip' zgreptbl  'number('row')'
          end
          if zsel = '/' then do
            call pfshow 'off'           /* make sure pfshow is off */
            'Addpop row(4) column(6)'
            'Display Panel(zigirgrp)'
            'rempop'
            call pfshow 'reset'         /* restore pfshow setting */
          end
          if zsel = 'S' then zsel = 'E'
          gdsno = gdsn
          if left(gdsn,1) /= "'" then
          if pos('(',gdsn) > 0 then do
             parse value gdsn with wd'('wm')'
             gdsn = "'"pdshlqt"."wd"("translate(wm)")'"
             end
          if gds = 'PDS Member' then do
              parse value fulldsn with "'"wdsn"'"
              gdsn = "'"wdsn"("gdsn")'"
             end
          Select
            When zsel = 'B' then do
              if left(gdsn,1) = "'"
              then do
                'Browse dataset('gdsn')'
                gstat = '*Browse'
              end
              else do
                Address TSO 'OBrowse' grepdir'/'gdsn
                gstat = '*OBrowse'
              end
              gdsn = gdsno
              'tbmod' zgreptbl
            end
            When zsel = 'E' then do
              if left(gdsn,1) = "'"
              then do
                'Edit dataset('gdsn')'
                gstat = '*Edit'
                if rc = 0 then file_changed = 1
              end
              else do
                ofile = grepdir'/'gdsn
                'Edit file(ofile)'
                gstat = '*Edit'
                if rc = 0 then file_changed = 1
              end
              gdsn = gdsno
              'tbmod' zgreptbl
            end
            When zsel = 'V' then do
              if left(gdsn,1) = "'"
              then do
                'View dataset('gdsn')'
                gstat = '*View'
              end
              else do
                ofile = grepdir'/'gdsn
                'View file(ofile)'
                gstat = '*View'
              end
              gdsn = gdsno
              'tbmod' zgreptbl
            end
            Otherwise nop
          end
          zsel = null
        end
        'tbend' zgreptbl
        zsel = null
        if file_changed = 1 then call update_repo_metadata
      end
      otherwise nop
    end
  end
  return

  /* ---------------------- *
  | Display the git Status |
  * ---------------------- */
Do_Status:
  zcmd = null
  cmd = 'cd' localrep'/'zigirep
  x = docmd(cmd '&& git status')
  call view_std
  return

  /* ------------------- *
  | Display the Git Log |
  * ------------------- */
Do_GitLog:
  zcmd = null
  call pfshow 'off'           /* make sure pfshow is off */
  'vget (lcnt logdfrom logdto greplog lbv incldiff) profile'
  if incldiff = null then incldiff = 'N'
  'Addpop row(4) column(6)'
  'Display Panel(zigilog)'
  drc = rc
  'Rempop'
  call pfshow 'reset'         /* restore pfshow setting */
  if drc = 0 then do
    lopts = null
    if incldiff = 'Y' then lopts = '--cc'
    if lcnt /= null then lopts = lopts '-n' lcnt
    if logdfrom /= null then lopts = lopts '--after="'logdfrom'"'
    if logdto   /= null then lopts = lopts '--until="'logdto'"'
    if greplog /= null then lopts = lopts '--grep='greplog '-i'
    lopts = translate(lopts,'-','/')
    cmd = 'cd' localdir' && git log' lopts
    'vput (lcnt logdfrom logdto greplog lbv incldiff) profile'
    x = docmd(cmd)
    htitle = 'GitLog Results'
    'vput (htitle)'
    if so.0 + se.0 > 1
    then call view_std 'X' lbv
    else do
      zerrsm = null
      zerrlm = 'GitLog filters resulted in an empty report.'
      'setmsg msg(isrz003)'
    end
  end
  return

  /* ----------------------------------------------- *
  | Reset USERIDs for all members                   |
  | May be called with a userid to be used and that |
  | will bypass the prompt.                         |
  * ----------------------------------------------- */
Do_Resetid:
  arg resetid
  if resetid = null then do
    call pfshow 'off'
    'Addpop row(4) column(12)'
    'display panel(zigirsid)'
    xrc = rc
    'Rempop'
    call pfshow 'reset'
  end
  else xrc = 0
  if xrc = 0 then do
    save_top = ztdtop
    'tbtop' rtll
    "LMINIT DATAID(zstats) DATASET("fulldsn")"
    "LMOPEN DATAID("zstats") OPTION(INPUT)"
    do forever
      'tbskip' rtll
      if rc > 3 then leave
      if zluser = resetid then iterate
      zluser = resetid
      'LMMSTATS DATAID('zstats') Member('mem') user('zluser')'
      'tbput' rtll
    end
    "LMClose Dataid("zstats")"
    "LMFree  Dataid("zstats")"
    ztdtop = save_top
    statfile = translate(strip(fulldsn,'B',"'"),' ','.')
    if qualignr > 0 then
    statfile = subword(statfile,qualignr+1)
    statfile = translate(statfile,'.',' ')
    if enhanced_cp = 0 then
    x = zigistat(fulldsn localrep'/'zigirep'/.zigi/'statfile 'S')
    else do
      uscmd = localrep'/'zigirep'/.zigi/'statfile fulldsn
      call update_stats uscmd
    end
    x = docmd('cd' localrep'/'zigirep '&& git add .zigi/'statfile)
  end
  return

  /* ------------------------ *
  | Do the Commit Processing |
  * ------------------------ */
Do_Commit:
  arg copt
  x = debug('Starting Commit:' zigirep)
  parse value '' with tagid msg1 cmsg file zcmd
  cmtab = 'zc'random(99999)
  'tbcreate' cmtab 'names(cmsg) nowrite'
  if datatype(m.0) = 'NUM' then do
    if copt /= null then do
      msg1 = m.1
      do dci = 2 to m.0
        cmsg = m.dci
        'tbadd' cmtab
      end
    end
    cmsg = null
  end
  do dci = 1 to 15
    'tbadd' cmtab
  end
  drop m.
  ctop = 0
  ztdmark = Center('Use F3 to Continue - Cancel if Title blank',79,'-')
  do forever
    if ztdsels > 1 then 'tbdispl' cmtab
    else do
      parse value '' with zsel zcmd
      'tbtop' cmtab
      'tbskip' cmtab 'number('ctop')'
      'tbdispl' cmtab 'panel(zigicom)'
    end
    if rc > 4 then do
       x = do_commitq()
       if x > 0 then answer = 'CANCEL'
       if abbrev('CANCEL',translate(answer),1) = 1
          then zcmd = 'CANCEL'
       else zcmd = 'COMMIT'
       end
    if translate(zcmd) = 'CANCEL' then leave
    if abbrev('COMMIT',translate(zcmd),2) = 1 then leave
    ctop = ztdtop
    if datatype(right(zcmd,1)) = 'NUM' then
    zcmd = left(zcmd,1) substr(zcmd,2)
    if zcmd /= null then
    Select
      When abbrev('IMPORT',word(translate(zcmd),1),2) = 1
      then call commit_import
      When abbrev('INSERT',translate(word(zcmd,1)),1) = 1 then do
        c = word(zcmd,2)
        if c = null then c = 1
        'tbquery' cmtab 'rownum(cr)'
        'tbtop' cmtab
        'tbskip' cmtab 'number('cr')'
        cmsg = ' '
        do ix = 1 to c
          'tbadd' cmtab
        end
      end
      Otherwise nop
    end
    select
      when zsel = 'D' then 'tbdelete' cmtab
      when left(zsel,1) = 'D' & length(zsel) > 1 then do
        dc = substr(zsel,2)
        if datatype(dc) /= 'NUM' then dc = 1
        do ix = 1 to dc
          'tbdelete' cmtab
          'tbskip' cmtab
        end
      end
      when zsel = 'I' then do
        cmsg = ' '
        'tbadd' cmtab
      end
      when left(zsel,1) = 'I' then do
        c = substr(zsel,2,1)
        if datatype(c) /= 'NUM' then c = 1
        cmsg = ' '
        do i = 1 to c
          'tbadd' cmtab
        end
      end
      when zsel = null then
      'tbput' cmtab
      Otherwise if zsel /= null then do
        zerrsm = 'Invalid.'
        zerrlm = zsel 'is an invalid line selection. Try again with a valid' ,
          'line selection of I, I#,or D.'
        'setmsg msg(isrz003)'
      end
    end
  end

  drop ztdmark

  if translate(zcmd) = 'CANCEL' then msg1 = null
  if strip(msg1) = null then do
    x = debug('Commit canceled:' zigirep)
    zerrsm = 'Canceled.'
    zerrlm = 'Commit canceled per your request.'
    'setmsg msg(isrz003)'
    'tbend' cmtab
    drop m.
    return
  end

  zs1 = 'Commit processing started.'
  zs2 = null
  call do_popup

  /* find last row */
  'tbbottom' cmtab
  do forever
    'tbskip' cmtab 'number(-1)'
    if rc > 0 then leave
    if strip(cmsg) /= null then leave
  end
  'tbquery' cmtab 'position(lastrow)'

  cmsg.1 = value('msg1')
  cmsg.2 = left('-',length(cmsg.1),'-')
  io = 2

  'tbtop' cmtab
  if lastrow > 0 then
  do forever
    'tbskip' cmtab
    if rc > 0 then leave
    'tbquery' cmtab 'position(crp)'
    io = io + 1
    cmsg.io = strip(cmsg,'T') ' '
    if crp = lastrow then leave
  end
  cmsg.0 = io

  'tbend' cmtab

  if defruid /= null then call fixup_userids
  drop combine.
  combine.0 = 0

  /* ------------------------------- *
  | If > 1 msg line then use a file |
  * ------------------------------- */
  if io > 2 then do
    file = 'cmsg'random(999)
    fdd  = file
    if sysvar('syspref') = null
    then filem = sysvar('sysuid')'.'file
    else filem = file
    file = localrep'/'file
    file = "'"file"'"
    address tso
    'alloc f('fdd') new spa(1,1) tr recfm(f b) lrecl(72) blksize(0)',
      'ds('filem')'
    'execio * diskw' fdd '(finis stem cmsg.'
    'free  f('fdd')'
    call outtrap 'x.'
    'oput' filem file 'Text'
    'delete' filem
    call outtrap 'off'
    address ispexec
    cmd = 'cd' localrep'/'zigirep
    if zadd = 'Y' then
    cmd = cmd  '&& git add -A .'
    cmd = cmd '&& git commit -F' file
    if zigi_offline = 0 then
    if zpush = 'Y' then
    cmd = cmd '&& git push -v'
    cmd = cmd '&& rm' file
    x = docmd(cmd)
    call add_combine cmd
    call combine_msgs
  end
  /* ------------------------------------- *
  | If cmsg.0 = 2 then use commit -m msg   |
  | remove quotes for this msg             |
  * -------------------------------------- */
  else do
    cmsg.1 = translate(cmsg.1,' ',"'" '"')
    cmd = 'cd' localrep'/'zigirep
    if zadd = 'Y' then
    cmd = cmd  '&& git add -A .'
    cmd = cmd "&& git commit -vm '"cmsg.1"'"
    if zigi_offline = 0 then
    if zpush = 'Y' then
    cmd = cmd '&& git push -v'
    x = docmd(cmd)
    call add_combine cmd
    call combine_msgs
  end
  if tagid /= null then do
    parse value so.1 with '['.  ctag']' .
    cmd = 'cd' localrep'/'zigirep
    cmd = cmd '&& git tag' tagid ctag
    if zigi_offline = 0 then
    if remote1 /= '<no remote defined>' then
    cmd = cmd '&& git push origin' tagid
    cmd = cmd '&& git show' tagid
    x = docmd(cmd)
    call add_combine cmd
    call combine_msgs
  end
  if x > 0 then do
    call view_std 'C'
  end
  if left(remote1,1) /= '<' then
  if zpush = 'N' then do
    zerrsm = 'Push Needed.'
    zerrlm = 'The commit has completed and a push is now required to' ,
      'update the Git remote repository.'
    if zigi_offline = 1 then
    zerrlm = zerrlm 'Which will require not being in Offline mode.'
    'setmsg msg(isrz003)'
  end
  x = debug('Commit completed:' zigirep)
  drop m. cmsg.
  nocrpop = 1
  call update_repo_metadata
  return

  /* ---------------------------------------------------------- *
  | Import the Commit Prose from a dataset.                    |
  |                                                            |
  | If the Import command has no dataset then display popup.   |
  | If the import dataset is not valid then display the popup. |
  * ---------------------------------------------------------- */
Commit_Import:
  parse value zcmd with imp comimprt .
  zcmd = null
  com_prompt = 0
  if strip(comimprt) = null then com_prompt = 1
  else do
    x = sysdsn(comimprt)
    if x /= 'OK' then do
      com_prompt = 1
      zerrsm = 'Error.'
      zerrlm = left(comimprt,76) x
      'setmsg msg(isrz003)'
    end
  end
  if com_prompt = 1 then do
    call pfshow 'off'           /* make sure pfshow is off */
    'addpop row(3) column(4)'
    'display panel(zigicimp)'
    drc = rc
    'rempop'
    call pfshow 'reset'         /* restore pfshow setting */
    if drc > 0 then return
  end
  cdd = 'CI'time('s')
  Address TSO
  'Alloc f('cdd') shr reuse ds('comimprt')'
  'Execio * diskr' cdd '(finis stem cddin.'
  'Free  f('cdd')'
  Address ISPExec
  'tbbottom' cmtab
  do forever
    'tbskip' cmtab 'number(-1)'
    if rc > 0 then leave
    if strip(cmsg) /= null then leave
  end
  'tbquery' cmtab 'position(lastrow)'
  do cinp = 1 to cddin.0
    cmsg = cddin.cinp
    'tbadd' cmtab
  end
  'tbtop' cmtab
  drop cddin.
  return

  /* ------------------------------------------------------ *
  | If the default userid is not null then                 |
  | 1. git status to see what pds files were modified      |
  | 2. reset the userids in all pds files                  |
  * ------------------------------------------------------ */
fixup_userids:
  cmd = 'cd' localrep'/'zigirep  '&& git status'
  x = docmd(cmd)
  dsns = null
  members. = null
  hlq = translate(pdshlq,' ','.')
  if qualignr > 0 then
  hlq = subword(hlq,1,qualignr)
  hlq = translate(hlq,'.',' ')
  do iw = 1 to so.0
    if word(so.iw,1) = 'Untracked' then leave
    if word(so.iw,1) = 'Changes not' then leave
    if left(so.iw,1) /= '05'x then iterate
    if pos('new file',so.iw) = 0
    then parse value so.iw with . file .
    else parse value so.iw with . . file .
    if left(file,1) = '.' then iterate
    if pos('/',file) > 0 then parse value file with file'/'mem
    if dsnvalid(file) = 'NO' then iterate
    if wordpos(file,dsns) = 0 then do
      dsns = dsns file
    end
    members.file = members.file mem
  end
  do iw = 1 to words(dsns)
    file = word(dsns,iw)
    workdsn = "'"hlq"."file"'"
    x = listdsi(workdsn)
    if sysdsorg /= 'PO' then iterate
    "LMINIT DATAID(reset) DATASET("workdsn")"
    "LMOPEN DATAID("reset") OPTION(INPUT)"
    do im = 1 to words(members.file)
      member = word(members.file,im)
      if pos('.',member) > 0 then
      parse value member with member'.' .
      "LMMFind DATAID("reset") Member("member") STATS(YES)"
      if rc > 7 then iterate
      if zluser /= defruid then do
        'LMMSTATS DATAID('reset') Member('member') user('defruid')'
      end
    end
    "LMClose Dataid("reset")"
    "LMFree  Dataid("reset")"
    statfile = translate(strip(workdsn,'B',"'"),' ','.')
    if qualignr > 0 then
    statfile = subword(statfile,qualignr+1)
    statfile = translate(statfile,'.',' ')
    if enhanced_cp = 0 then
    x = zigistat(workdsn localrep'/'zigirep'/.zigi/'statfile 'S')
    else do
      uscmd = localrep'/'zigirep'/.zigi/'statfile workdsn
      call update_stats uscmd
    end
    dir = localrep'/'zigirep
    x = docmd('cd' dir '&& git add .zigi/'statfile)
    if x > 0 then
    call view_std 'B'
  end
  return

  /* ---------------------------------- *
  | Push the updates to the remote git |
  * ---------------------------------- */
Do_Push:
  arg opt
  call pop 'Pushing Updates to Remote Git'
  cmd = 'cd' localdir' && git push -v'
  x = docmd(cmd)
  if x > 0 then do
    call view_std 'B'
  end
  call update_repo_metadata
  return

  /* ----------------------------- *
  | Clone a remote repo           |
  * ----------------------------- */
Clone_Repo:
  if zigi_offline = 1 then do
    zerrsm = 'Offline.'
    zerrlm = 'Clone is not allowed when offline.'
    'Setmsg msg(isrz003)'
    return
  end
  parse value '' with remotebr defcpush defruid zigicat reponame
  'vget (saverep) profile'
  if saverep /= null then localrep = saverep
  if sysvar('syspref') = null
     then pdshlq = sysvar('sysuid')
     else pdshlq = sysvar('syspref')
  do forever
    zcmd = null
    remote = null
    c_stat = 0
    cc_rc = 0
    'Display Panel(zigicc)'
    if rc > 0 then return
    if localrep = "?" then
    localrep = zigiosel()
    if strip(localrep) = null then do
      zerrsm = 'Canceled.'
      zerrlm = 'Clone canceled as OMVS directory selection canceled.'
      'Setmsg msg(isrz003)'
      return 1
    end
    saverep = localrep
    'vput (saverep) profile'
    parsedURI = parseGitURI(remote)
    parse var parsedURI guser host port zigirep '.git'
    if port /= 22 then extrabits = '-p 'port
    else extrabits = null
    /* Let's clone the remote repo... */
    zs1 = "Cloning "zigirep" by "owner
    zs2 = "from "host
    call do_popup
    cmd = 'touch 'home'/.ssh/known_hosts && '
    cmd = cmd 'ssh-keyscan 'extrabits' -t rsa,dsa 'host
    cmd = cmd ' 2>&1 | sort -u - 'home'/.ssh/known_hosts >'
    cmd = cmd ' 'home'/.ssh/tmp_hosts && '
    cmd = cmd 'mv 'home'/.ssh/tmp_hosts 'home'/.ssh/known_hosts'
    x = docmd(cmd)
    localrep = strip(localrep,'T','/')
    x = time('r')  /* begin timer */
    cmd = 'cd 'localrep
    if remotebr = null
    then cmd = cmd ' && git clone -v 'remote reponame
    else cmd = cmd ' && git clone -vb' remotebr remote reponame
    x = docmd(cmd)
    if x > 0 then do
      c_stat = 1
      call view_std 'B'
      Address ISPExec
      return
    end
    if reponame /= null then zigirep = reponame
    else reponame = zigirep
    /* Check to see if this is a ZIGI-managed repo */
    cmd = '[[ | -d 'localrep'/'zigirep'/.zigi ]] && echo 0'
    x = docmd(cmd)
    if so.0 = 1 & so.1 = 0 then do
      call pfshow 'off'           /* make sure pfshow is off */
      'Addpop row(4) column(7)'
      'Display Panel(zigipopn)'
      'Rempop'
      call pfshow 'reset'         /* restore pfshow setting */
      'Select pgm(isptutor) parm(zigih800)'
      non_zigi = 1
    end
    else non_zigi = 0
    Address ISPExec
    if c_stat = 1 then return
    qualignr = words(translate(pdshlq,' ','.'))
    if non_zigi = 0 then
    call Replace localrep zigirep pdshlq qualignr '\ Clone'
    zigikey = localrep'/'zigirep
    zigidate = date('n')
    call set_sortdate
    'tbadd zigirepo order'
    'vget (defrsort srr src srp srl) profile'
    if defrsort /= null then
    'TBSort zigirepo Fields('defrsort')'
    'TBSAVE zigirepo REPLCOPY LIBRARY('isptabl')'
    call get_default_codepage
    leave
  end
  e_time = time("E")
  parse value e_time with ss "." uu
  numeric digits 6
  mm = ss % 60   /* get minutes integer */
  ss = ss // 60  /* get seconds integer */
  uu = uu // 100 /* get micro seconds integer */
  cltime = right(mm+100,2)':'right(ss+100,2)'.'right(uu+100,2)
  call work_with_repo
  return

  /* -------------------------------- *
  | Add Member to Git for Committing |
  * -------------------------------- */
Git_Add_Member:
  arg force_it
  /* The member 'can' have an extension in the local-repo
  of course this information is not present in the member-name
  as shown in the table. So we 'should' check the dsn-info file
  and check if it has an extension (and if so which one).
  */
  repodir = localrep'/'zigirep
  readfile = " '"repodir"/.zigi/dsn'"
  address syscall 'readfile' readfile 'so.'
  extension = null
  do cki = 1 to so.0
    if left(so.cki,1) = '#' then iterate
    if word(so.cki,1) = '*' then do
      parse value so.cki with . def_dsorg def_recfm def_lrecl def_blksize .
    end
    else do
      idsn = word(so.cki,1)        /* dataset name less hlq */
      if idsn = dsn then do
        if word(so.cki,6) <> "" then do
          /* we have an extension for this library */
          extension = word(so.cki,6)
          leave
        end
      end
    end
  end

  d = dsn
  cmd = 'cd' repodir

  if pos('.',mem) = 0 & extension /= null then
  /* so we have an extension, better add correctly */
  toadd = lower(mem)'.'extension
  else do
    /* regular add */
    toadd = mem
  end
  if force_it = null
  then add_force = null
  else add_force = '-f'
  /* Brought back in */
  call git_safe_add repodir  d'/'toadd  add_force
  if se.0 > 0 then
  call view_std 'B'
  /* End of brought back in */
  parse value mem with mem'.'.
  call update_mem_status d'/'toadd mem
  zigi_changed = 1
  return

  /* ---------------------------------- *
  | Update stats file after member add |
  * ---------------------------------- */
Git_Add_Member_Stats:
  statfile = translate(strip(fulldsn,'B',"'"),' ','.')
  x = debug('Add member stats:' statfile)
  if qualignr > 0 then
  statfile = subword(statfile,qualignr+1)
  statfile = translate(statfile,'.',' ')
  cmd = 'cd' localrep'/'zigirep'/.zigi/'
  x = cmd '&& git add -v 'statfile
  x = docmd(cmd)
  if enhanced_cp = 0 then
  x = zigistat(fulldsn ,
    localrep'/'zigirep'/.zigi/'statfile 'S')
  else do
    uscmd = localrep'/'zigirep'/.zigi/'statfile workdsn
    call update_stats uscmd
  end
  x = docmd('cd' localrep'/'zigirep '&& git add .zigi/'statfile)
  call work_with_repo_file
  x = debug('Add member stats completed.')
  return

  /* ------------------------- *
  | Copy a PS dataset to OMVS |
  * ------------------------- */
Edit_PS:
  arg noedit
  edsn = strip(fulldsn,'B',"'")
  /* Do this if it's a regular file (sequential in z/OS) */
  if is_binfile(dsn) = 1 then do
    zerrsm = 'Invalid'
    zerrlm = 'Unable to Edit a binary dataset.'
    'setmsg msg(isrz003)'
    return
  end
  "Edit Dataset('"edsn"')"
  /* so after the edit, we should update it to working directory */
Copy_PS:
  if rc = 0 then do
    copcm = "//'"edsn"'"
    /* -M was replaced with -v in all CP commands */
    copcm = 'cp -U -v "'copcm'" 'localrep'/'zigirep'/'dsn
    x = do_copy(copcm)
    if x > 0 then call view_std 'B'
    if ztdsels < 2 then
    call update_repo_metadata
  end
  return

  /* ------------------------------- *
  | Sort the member list (zigilist) |
  * ------------------------------- */
Do_LSort:
  parse value zcmd with x sort_field sort_order sf sc ,
    save_lsorto
  zcmd = null
  if sort_field = null then do
    call pfshow 'off'           /* make sure pfshow is off */
    'Addpop row(4) column(6)'
    'Display Panel(zigilsrt)'
    drc = rc
    'Rempop'
    call pfshow 'reset'         /* restore pfshow setting */
    if drc > 0 then return
    sort_field = sf
    sort_order = sc
  end
  if sort_order = null then
  if save_lsorto = null then do
    sort_order = 'A'
  end
  else do
    if save_lsorto = 'A' then sort_order = 'D'
    else sort_order = 'A'
  end
  save_lsorto = sort_order
  /* support abbreviations in field names */
  Select
    When abbrev('MEMBER',sort_field,2) = 1 then sort_field = 'MEMBER'
    When abbrev('STATUS',sort_field,2) = 1 then sort_field = 'STATUS'
    When abbrev('SIZE',sort_field,2)   = 1 then sort_field = 'SIZE'
    When abbrev('DATE',sort_field,2)   = 1 then sort_field = 'DATE'
    When abbrev('TIME',sort_field,2)   = 1 then sort_field = 'TIME'
    When abbrev('USERID',sort_field,2) = 1 then sort_field = 'USERID'
    Otherwise nop
  end
  /* 1st validate sort_field */
  if wordpos(sort_field,'MEMBER STATUS SIZE DATE TIME USERID') = 0
  then do
    zerrsm = 'Invalid.'
    zerrlm = sort_field 'is an invalid sort field. Valid names are:' ,
      'MEMBER STATUS SIZE DATE TIME USERID'
    'Setmsg msg(isrz003)'
    return
  end
  /* 2nd validate the sort_order A or D */
  if pos(sort_order,'AD') = 0 then do
    zerrsm = 'Invalid.'
    zerrlm = sort_order 'is an invalid sort order. Must be either' ,
      'A for ascending or D for descending.'
    'Setmsg msg(isrz003)'
    return
  end
  sw = wordpos(sort_field,'MEMBER STATUS SIZE DATE TIME USERID')
  sort_field = subword('mem memstat zlcnorc zlm4date zlmtime zluser',sw,1)
  if sw = 3 then sort_type = 'N'
  else sort_type = 'C'
  if sort_field /= zlm4date
  then 'tbsort' rtll 'fields('sort_field','sort_type','sort_order')'
  else 'tbsort' rtll 'fields('sort_field','sort_type','sort_order',' ,
    'zlmtime,'sort_type','sort_order')'
  return

  /* ----------------------------- *
  | Replace z/OS side of repo     |
  * ----------------------------- */
Replace:
  parse arg r_localrep r_zigirep r_pdshlq r_qualignr r_pulldsns '\' r_type
  replace_state = 0
  ckotdir = r_localrep'/'r_zigirep
  if r_qualignr /= '*' then
  if datatype(r_qualignr) /= 'NUM' then r_qualignr = 0
  if r_qualignr = 0
  then ckothlq = null
  else do
    ckothlq = translate(r_pdshlq,' ','.')
    if r_qualignr /= '*' then
    ckothlq = subword(ckothlq,1,r_qualignr)
    ckothlq = translate(ckothlq,'.',' ')'.'
  end
  ckotqual = r_qualignr
  pulldsns = r_pulldsns
  newhlq = null
  if wordpos(r_type,'CLONE') > 0 then do
    x = check_replace()
    if x > 0 then do
      zerrsm = 'Cancelled.'
      zerrlm = 'z/OS Dataset Update cancelled.'
      'Setmsg Msg(isrz003)'
      return
    end
    if x = 0 then
    if newhlq /= null then do
      pdshlqw = words(translate(pdshlq,' ','.'))
      newhlqw = words(translate(newhlq,' ','.'))
      if newhlqw > pdshlqw then do
        iqn = newhlqw - pdshlqw + r_qualignr
        pdshlq = newhlq
        qualignr = r_qualignr
        if iqn /= null then qualignr = iqn
        'tbmod zigirepo'
        call replace r_localrep r_zigirep pdshlq qualignr r_pulldsns '\' r_type
        return
      end
    end
  end
  'vput (ckotdir ckothlq pulldsns ckotqual)'
  'Select cmd(%zigickot)'
  'vget (badckot) shared'
  if badckot = 1 then do
    zerrsm = 'Failed.'
    zerrlm = 'z/OS Dataset Update failed due to one, or more, of the' ,
      'target datasets are allocated. Free those allocations and' ,
      'try again.'
    'Setmsg Msg(isrz003)'
    'verase (badckot) shared'
    replace_state = 1
  end
  return

  /* -------------------------------------------------------- *
  | Check the datasets to be replaced and prompt the user to |
  | confirm they really REALLY want to replace them.         |
  * -------------------------------------------------------- */
Check_Replace:
  cmd = 'cd' ckotdir '&& ls -l'
  x = docmd(cmd)
  cr_files  = null
  iqn = null
  do i = 2 to so.0
    cfile = word(so.i,9)
    cfile = "'"ckothlq""cfile"'"
    if dsnvalid(cfile) /= 'OK' then iterate
    if sysdsn(cfile) = 'OK' then
    cr_files = cr_files cfile
  end
  if strip(cr_files) = null then return 0
  crtbl = 'CRT'random(9999)
  'tbcreate' crtbl 'names(cfile) nowrite'
  do i = 1 to words(cr_files)
    cfile = word(cr_files,i)
    'tbadd' crtbl
  end
  'tbtop' crtbl
  'tbdispl' crtbl 'panel(zigicrds)'
  drc = rc
  'tbend' crtbl
  if drc > 0 then return 3
  return 0

  /* ----------------------------- *
  | Branch management             |
  * ----------------------------- */
Branch_it:
  if rtbb_open = 1 then 'tbend' rtbb
  'TBCreate' rtbb 'keys(bname) Names(brstatus) Replace NoWrite'
  rtbb_open = 1
  localdir = localrep'/'zigirep
  if zigi_offline = 0 then do
    cmd = ' && git remote prune origin > /dev/null 2>&1 && git branch -a'
    x = docmd('cd 'localdir cmd)
  end
  else parse value '0 0' with so.0 se.0
  if so.0 + se.0 = 0 then do
    cmd = '&& git branch -a'
    x = docmd('cd 'localdir cmd)
  end
  bl. = null
  bl.0 = 0
  do bri = 1 to so.0
    b1 = strip(so.bri,'B')
    if pos('remotes/',b1) > 0 then do
      /* this is a remote branch we (maybe) have never checked out */
      seen_this_branch = 0
      parse var b1 remotes'/'origin'/'bname zooi
      bname = strip(bname)
      do ii = 1 to bl.0
        if bl.ii = bname then seen_this_branch = 1
      end
      if seen_this_branch = 1 then do
        sbname = bname
        'tbtop' rtbb
        do forever
          'tbskip' rtbb
          if rc > 0 then leave
          if sbname = bname then do
            brstatus = 'Local/Remote'
            'tbmod' rtbb
            leave
          end
        end
      end
      /* but only add it to table if we haven't yet */
      if seen_this_branch = 0 then do
        if bname <> branch & bname <> "HEAD" then do
          ni = bl.0 + 1
          bl.ni = bname
          bl.0 = ni
          brstatus = 'Remote'
          'tbadd' rtbb
        end
      end
    end
    else do
      /* this is already a local branch */
      if pos('*',b1) = 0 then do
        /* Add it to the table if it's not the current (*) branch */
        bname = strip(so.bri)
        ni = bl.0 + 1
        bl.ni = b1
        bl.0 = ni
        brstatus = 'Local'
        'tbadd' rtbb
      end
    end
  end
  'tbsort' rtbb 'fields(bname,c,a)'
  'tbtop' rtbb
  save_btop = 0
  do forever
    zcmd = null
    cc_rc = 0
    newb = null
    zsel = null
    if save_btop > 0 then do
      'tbtop' rtbb
      'tbskip' rtbb 'number('save_btop')'
    end
    'tbdispl' rtbb 'panel(zigibra)'
    if rc > 4 then do
       'tbend' rtbb
       return 0
       end
    save_btop = ztdtop
    if abbrev('GITHELP',word(zcmd,1),4) = 1 then
    Address TSO '%githelp' subword(zcmd,2)
    if newb <> null then do
      /* ----------------------------- *
      | Create this new branch, switch|
      * ----------------------------- */
      bad = 0
      do bi = 1 to bl.0
        if newb = bl.bi then bad = 1
      end
      if bad = 1 then do
        zerrsm = 'Invalid.'
        zerrlm = newb 'branch already exists - select a new name.'
        'setmsg msg(isrz003)'
      end
      else do
        localdir = localrep'/'zigirep
        x = docmd('cd 'localdir' && git checkout -b 'newb)
        /* TODO only do this when there is a remote? */
        if zigi_offline = 0 then
        x = docmd('cd 'localdir' && git push -u origin 'newb)
        branch = newb
        leave
      end
    end
    /* ----------------------------- *
    | Checkout the selected bname   |
    * ----------------------------- */
    if zsel = "C" then do
      x = check_clean()
      if x = 'NO' then do
        zs1 = 'Cannot checkout branch as it is not clean.'
        zs2 = 'Use the Status command and fix then try again.'
        call pfshow 'off'           /* make sure pfshow is off */
        'Addpop row(4) column(8)'
        'Display Panel(zigipop)'
        'Rempop'
        call pfshow 'reset'         /* restore pfshow setting */
        call view_std 'B'
      end
      else do
        call check_branch_delta
        call update_repo_metadata
        branch = bname
      end
      leave
    end
    if zsel = "D" then do
        ans = null
        if pos('/',brstatus) > 0
           then bloc = 'Local'
           else bloc = brstatus
        call pfshow 'off'           /* make sure pfshow is off */
        'Addpop row(4) column(6)'
        'display panel(zigibrdq)'
        drc = rc
        'Rempop'
        call pfshow 'reset'         /* restore pfshow setting */
        if ans = 'N' then drc = 4
        if drc > 0 then do
          ans = 'N'
          zerrsm = 'Canceled.'
          zerrlm = 'Branch delete canceled.'
          'setmsg msg(isrz003)'
        end
        if ans = 'Y' then do
          if bloc = 'Local'
             then x = docmd('cd 'localdir' && git branch -D 'bname)
             else x = docmd('cd 'localdir' && git push origin --delete' bname)
          if bloc = 'Remote' then do
            'tbdelete' rtbb
            zerrsm = 'Remote Deleted.'
            zerrlm = 'Branch 'bname' succesfully deleted on the server.'
            'Setmsg msg(isrz003)'
          end
          else do
            zerrsm = 'Local Deleted.'
            zerrlm = 'Branch 'bname' succesfully deleted from the local' ,
              'repository but remains on the remote.'
            'Setmsg msg(isrz003)'
            brstatus = 'Remote'
            'tbmod' rtbb
          end
        end
    end
  end
  'tbend' rtbb
  rtbb_open = 0
  ztdsels = 0
  zsel = null
  call update_repo_metadata /* to reflect status after branch */
  return

  /* ----------------------------- *
  | Merging things...             |
  * ----------------------------- */
Merge_it:
  'tbquery' rtbm
  if rc = 0 then 'tbend' rtbm
  'TBCreate' rtbm 'keys(bname) Names(brstatus) Replace NoWrite'
  localdir = localrep'/'zigirep
  zsel = null
  if zigi_offline = 0 then do
    cmd = ' && git remote prune origin > /dev/null 2>&1 && git branch -a'
    x = docmd('cd 'localdir cmd)
  end
  else parse value '0 0' with so.0 se.0
  if so.0 + se.0 = 0 then do
    cmd = '&& git branch -a'
    x = docmd('cd 'localdir cmd)
  end
  bl. = null
  bl.0 = 0
  do bri = 1 to so.0
    b1 = strip(so.bri,'B')
    if pos('/',b1) > 0 then do
      /* this is a remote branch we (maybe) have never checked out */
      seen_this_branch = 0
      parse var b1 remotes'/'origin'/'bname zooi
      bname = strip(bname)
      do ii = 1 to bl.0
        if bl.ii = bname then seen_this_branch = 1
      end
      if seen_this_branch = 1 then do
        sbname = bname
        'tbtop' rtbm
        do forever
          'tbskip' rtbm
          if rc > 0 then leave
          if sbname = bname then do
            brstatus = 'Local/Remote'
            'tbmod' rtbm
            leave
          end
        end
      end
      /* but only add it to table if we haven't yet */
      if seen_this_branch = 0 then do
        if bname <> branch & bname <> "HEAD" then do
          ni = bl.0 + 1
          bl.ni = bname
          bl.0 = ni
          brstatus = 'Remote'
          'tbadd' rtbm
        end
      end
    end
    else do
      /* this is already a local branch */
      if pos('*',b1) = 0 then do
        /* Add it to the table if it's not the current (*) branch */
        bname = strip(so.bri)
        ni = bl.0 + 1
        bl.ni = b1
        bl.0 = ni
        brstatus = 'Local'
        'tbadd' rtbm
      end
    end
  end
  'tbsort' rtbm 'fields(bname,c,a)'
  'tbtop' rtbm
  save_btop = 0
  do forever
    zcmd = null
    cc_rc = 0
    newb = null
    zsel = null
    if save_btop > 0 then do
      'tbtop' rtbm
      'tbskip' rtbm 'number('save_btop')'
    end
    'tbdispl' rtbm 'panel(zigimer)'
    if rc > 4 then do
       'tbend' rtbm
       return 4
       end
    save_btop = ztdtop
    if abbrev('GITHELP',word(zcmd,1),4) = 1 then
    Address TSO '%githelp' subword(zcmd,2)
    /* ----------------------------- *
    | Checkout the selected bname   |
    * ----------------------------- */
    if zsel = "M" then do
      /* ----------------------------------------- */
      /* Get the delta of the elements between the */
      /* branches being merged.                    */
      /* ----------------------------------------- */
      if brstatus = 'Local' then mer_branch = bname
      else mer_branch = 'origin/'bname
      cmd = 'cd 'localdir ,
        '&& git fetch --all',
        '&& git diff --name-status' branch'..'mer_branch
      x = docmd(cmd)
      /* save the delta info for future use */
      drop save_so.
      do mi = 1 to so.0
        save_so.mi = so.mi
      end
      save_so.0 = so.0
      /* ----------------------------------------- */
      cmd = 'cd 'localdir ,
            '&& git merge --no-commit --no-ff' mer_branch
      x = docmd(cmd)
      zigi_changed = 1
      mok = 'Automatic merge went well'
      mokf = 0
      do i = 1 to se.0
         if pos(mod,se.i) = 0 then mokf = 1
         if mokf = 1 then leave
         end
      if mokf = 0 then call view_std 'B'
      if so.1 = 'Already up-to-date.' then do
        /* No need to merge! */
        zs1 = "Merge not needed"
        zs2 = "Branches are the same"
        zs3 = ""
        zs4 = "Press Enter/F3 to continue"
        call do_popup4p
        leave
      end

      parse var se.1 "Automatic merge went well; stopped" rest
      if rest /= "" then do
        /* No issues. Commit the merge then execute a Replace */
        /* Maybe popup a panel here for the commit message? */
        x = docmd('cd 'localdir' && git commit -m "Merge 'bname'"')
        Report_Header = 'Merge Report'
        delta_from = bname
        delta_to   = branch
        drop so.
        do mi = 1 to save_so.0
          so.mi = save_so.mi
        end
        so.0 = save_so.0
        call check_delta
      end
      else do
        mhit = 0
        do im = 1 to so.0
          if word(so.im,1) /= 'CONFLICT' then iterate
          if pos('.zigi/',so.im) = 0  then do
            mhit = 1
            zcmd = 2
            leave
          end
        end
        /* Merge went fubar */
        if mhit = 1 then
        do forever
          zcmd = null
          call pfshow 'off'           /* make sure pfshow is off */
          'Addpop row(4) column(6)'
          'Display Panel(zigimrgq)'
          drc = rc
          'Rempop'
          call pfshow 'reset'         /* restore pfshow setting */
          if drc > 0 then leave
          if zcmd > 0 then leave
          if zcmd = 0 then do
            zerrsm = null
            zerrlm = 'Issues with .zigi/xxx files can be ignored as they' ,
              'will be handled automatically by ZIGI.'
            'setmsg msg(isrz003)'
            call view_std 'V'
          end
        end
        if drc > 0 then zcmd = 3
        if zcmd = 3 then do
          cmd = 'cd' localdir
          cmd = cmd '&& git merge --abort'
          x = docmd(cmd)
          zerrsm = 'Canceled.'
          zerrlm = "Merge canceled and git merge --abort executed."
          'setmsg msg(isrz003)'
        end
        mrgtype = zcmd
        if zcmd = 2 then zcmd = 1
        /* --------------------------------------------------------------- *
        | If option 1 then setup for the user to resolve the conflicts    |
        | using ispf edit.                                                |
        |                                                                 |
        | 1. parse merge conflict messages for the merge files            |
        | 2. if a file is a PDS then process then add the file name       |
        |    to fix_stats for later and edit to retain only merge records |
        | 3. display the files for selection and correction               |
        | 4. if ALL files have been resolved (edit saved) then            |
        |    process any fix_stats files:                                 |
        |    - run zigistat 'S'                                           |
        |    - git add it                                                 |
        |                                                                 |
        | If option 1 then don't do any processing just display the       |
        | files for editing and manual resolution.  But still fix the     |
        | ISPF stats files                                                |
        * --------------------------------------------------------------- */
        if zcmd = 1 then do
          pdshlqt = translate(pdshlq,' ','.')
          if qualignr > 0 then
          pdshlqt = subword(pdshlqt,1,qualignr)
          pdshlqt = translate(pdshlqt,'.',' ')
          parse value '' with dsntbl mstat
          zmergtbl = 'ZG'time('s')
          zmcount = 0
          fix_stats = null
          'TBCreate' zmergtbl 'Keys(mdsn)' ,
            'Names(mfile mstat) nowrite share'
          mrgdir = localrep'/'zigirep
          merge_rms = null
          do si = 1 to so.0
            mem = null
            if word(so.si,1) /= 'CONFLICT' then iterate
            Select
              When pos('rename/',word(so.si,2)) > 0 then
              parse value so.si with . '->'mdsn .
              When pos('/delete',word(so.si,2)) > 0 then do
                parse value so.si with . 'Version'. 'of' mdsn .
                merge_rms = merge_rms mdsn
                iterate
              end
              When pos('modify/',word(so.si,2)) > 0 then
              parse value so.si with . 'Version'. 'of' mdsn .
              Otherwise
              parse value so.si with 'CONFLICT' . 'in' mdsn .
            End
            mfile = mrgdir'/'mdsn
            if mdsn /= '.zigi/dsn' then
            if left(mdsn,6) = '.zigi/' then do
              if pos(mfile,fix_stats) = 0 then
              fix_stats = fix_stats mfile
              parm = 'M'
              'vput (mrgdir mdsn mfile) shared'
              'Edit file(mfile) macro(zigimrgm) parm(parm)'
              iterate
            end
            if wordpos(mdsn,dsntbl) > 0
            then do
              'tbmod' zmergtbl
            end
            else do
              'tbadd' zmergtbl
              dsntbl = dsntbl mdsn
              zmcount = zmcount + 1
            end
          end
          if zmcount = 0 then do
            zs1 = 'Merge conflicts will be automatically resolved,'
            zs2 = 'issues with ISPF Stat Files only.'
            call do_popup
          end
          ztdsels = 0
          ztdtop = 1
          zsel = null
          file_changed = 0
          drop so. se.
          'tbtop' zmergtbl
          'tbsort' zmergtbl 'fields(mdsn,c,a)'
          ztdsels = 0
          if zmcount > 0 then
          do forever
            if ztdsels > 1
            then 'tbdispl' zmergtbl
            else do
              'tbtop' zmergtbl
              'tbskip' zmergtbl 'number('ztdtop')'
              'tbdispl' zmergtbl 'panel(zigimrds)'
            end
            if rc > 4 then leave
            if zsel = null then iterate
            if row /= null then do
              'tbtop' zmergtbl
              'tbskip' zmergtbl  'number('row')'
            end
            if zsel = '/' then do
              call pfshow 'off'           /* make sure pfshow is off */
              'Addpop row(4) column(6)'
              'Display Panel(zigirmrg)'
              'rempop'
              call pfshow 'reset'         /* restore pfshow setting */
            end

            if ztdsels = 0 then
            if pnsdef = 'P' then do
              if row = 0 then zcmd = 'O'
              if row > 0 then zsel = '/'
            end

            if zsel = 'S' then zsel = 'E'
            Select
              When zsel = 'B' then do
                Address TSO 'OBrowse' mrgdir'/'mdsn
                mstat = '*OBrowse'
                'tbmod' zmergtbl
              end
              When zsel = 'E' then do
                ofile = mrgdir'/'mdsn
                if mrgtype = 1 then do
                  mrgfile = '/tmp/'userid()'.merge'
                  md    = mrgdir
                  mdsns = mdsn
                  cmd = 'cd' md '&& cp' mdsns mrgfile
                  x = docmd(cmd)
                  parm = 'M'
                  'vput (mrgdir mdsn mrgfile) shared'
                  'Edit file(mrgfile) macro(zigimrgm) parm(parm)'
                  'Edit file(ofile) macro(zigimrgm)'
                  mstat = '*Edit'
                end
                else do
                  'Edit file(ofile) panel(zigiedit) macro(zigiem)'
                end
                if rc = 0 then do
                  file_changed = 1
                  zmcount = zmcount - 1
                  cmd = 'cd' mrgdir '&& git add' mdsn
                  x = docmd(cmd)
                  mstat = '*Updated'
                end
                'tbmod' zmergtbl
                cmd = 'rm' mrgfile
                x = docmd(cmd)
              end
              When zsel = 'V' then do
                ofile = mrgdir'/'mdsn
                'View file(ofile)'
                mstat = '*View'
                'tbmod' zmergtbl
              end
              Otherwise nop
            end
            zsel = null
          end
          'tbend' zmergtbl
          zsel = null
          if zmcount = 0 then do
            call do_merge_conflict_rms
            cmd = 'cd' mrgdir '&& git commit -m "Resolve merge conflicts"'
            x = docmd(cmd)
            Report_Header = 'Merge Report'
            delta_from = bname
            delta_to   = branch
            drop so.
            do mi = 1 to save_so.0
              so.mi = save_so.mi
            end
            so.0 = save_so.0
            call check_delta
            if fix_stats /= null
            then do fs = 1 to words(fix_stats)
              sfile = word(fix_stats,fs)
              wfile = translate(word(fix_stats,fs),' ','/')
              wfile = subword(wfile,words(wfile))
              pds = pdshlqt'.'wfile
              if enhanced_cp = 0 then
              Address TSO '%zigistat' "'"pds"'" sfile 'S'
              else do
                uscmd = sfile "'"pds"'"
                call update_stats uscmd
              end
              x = docmd('cd' localrep'/'zigirep '&& git add' sfile)
              if x > 0 then call view_std 'B'
            end
            call update_repo_metadata
          end
          else do
            zs1 = 'Not all conflicts have been resolved.'
            zs2 = 'Merge request is now aborted.'
            zs3 = null
            zs4 = 'Press Enter to exit merge.'
            call do_popup4p
            cmd = 'cd' localdir
            cmd = cmd  '&& git merge --abort'
            x = docmd(cmd)
            call view_std 'B'
          end
        end
      end
      leave
    end
  end
  'tbend' rtbm
  ztdsels = 1
  zsel = null
  return 0

  /* -------------------------------------------------------- *
  | During a merge if there are deletions then those need to |
  | be handled via a git rm.                                 |
  * -------------------------------------------------------- */
do_merge_conflict_rms:
  if words(merge_rms) = 0 then return
  cmd = 'cd' mrgdir '&& git rm' merge_rms
  x = docmd(cmd)
  if x > 0 then call view_std 'B'
  return

  /* --------------------------------------- *
  | Delete a PDS Member using ISPF Services |
  * --------------------------------------- */
Delete_member:
  arg dsn mem
  "LMInit Dataid(test) dataset("dsn") enq(shrw)"
  "LMOpen Dataid("test") Option(Output)"
  "LMMDel  Dataid("test") Member("mem") NoEnq"
  "LMClose Dataid("test")"
  "LMFree Dataid("test")"
  return

  /* ------------------------ *
  | Get the branches for use |
  * ------------------------ */
get_branches:
  localdir = localrep'/'zigirep
  if zigi_offline = 0 then do
    cmd = ' && git remote prune origin > /dev/null 2>&1 && git branch -a'
    x = docmd('cd 'localdir cmd)
  end
  else parse value '0 0' with so.0 se.0
  if so.0 + se.0 = 0 then do
    cmd = '&& git branch -a'
    x = docmd('cd 'localdir cmd)
  end
  bl. = null
  bc = 0
  do bri = 1 to so.0
    branch = strip(so.bri)
    if word(branch,1) = '*' then branch = word(branch,2)
    if pos('->',branch) > 0 then iterate
    if pos('/',branch) > 0 then do
      branch = translate(branch,' ','/')
      branch = word(branch,words(branch))
    end
    bc = bc + 1
    bl.bc = branch
  end
  bl.0 = bc
  return

  /* ----------------------- *
  | Connect a new Repository |
  * ----------------------- */
Connect_Repo:
  'vget (saverep) profile'
  if saverep /= null then localrep = saverep
  do forever
    parse value '' with zerrsm zcmd zigirep cc_rc pdshlq ,
      defcpush defruid qualignr zigicat encoding
    'Display Panel(zigiconr)'
    if rc > 0 then do
      zerrsm = 'Canceled.'
      zerrlm = 'Connection canceled by user action.'
      'setmsg msg(isrz003)'
      return 1
    end
    'vget (qualignr)'
    if readonly = 'N' then readonly = null
    if rc > 0 then return 8
    if localrep = '?' then
    localrep = zigiosel()
    if localrep = null then do
      zerrsm = 'Canceled.'
      zerrlm = 'Create canceled as OMVS directory selection canceled.'
      'setmsg msg(isrz003)'
      return 1
    end
    localrep = strip(localrep,'T','/')
    saverep = localrep
    'vput (saverep) profile'

    Address ISPExec
    zigikey = localrep'/'zigirep
    zigidate = date('n')
    reponame = zigirep
    call set_sortdate
    'tbadd zigirepo order'
    zpush = defcpush
    'vget (defrsort srr src srp srl) profile'
    if defrsort /= null then
    'TBSort zigirepo Fields('defrsort')'
    'TBSAVE zigirepo REPLCOPY LIBRARY('isptabl')'
    leave
  end
  return 0

  /* ----------------------- *
  | Create a new Repository |
  * ----------------------- */
Create_Repo:
  'vget (saverep) profile'
  if saverep /= null then localrep = saverep
  do forever
    parse value '' with zerrsm zcmd zigirep cc_rc pdshlq ,
      defcpush defruid qualignr zigicat encoding
    'Display Panel(ziginew)'
    if readonly = 'N' then readonly = null
    if rc > 0 then return 8
    if localrep = '?' then
    localrep = zigiosel()
    if localrep = null then do
      zerrsm = 'Canceled.'
      zerrlm = 'Create canceled as OMVS directory selection canceled.'
      'setmsg msg(isrz003)'
      return 1
    end

  /* ------------------------------------------ *
   | Clean up repo name replacing blanks with _ |
   | and only allow 1 contig space              |
   * ------------------------------------------ */
   if pos(' ',zigirep) > 0 then do
      zigirep = space(zigirep,1)
      zigirep = translate(zigirep,'_',' ')
      end

    localrep = strip(localrep,'T','/')
    /* ---------------------------------------------------- *
    | We do some basic git repo setup here...              |
    | Fair warning, it's going to be very verbose.         |
    | But that eases feature adding :)                     |
    * ---------------------------------------------------- */
    /* encoding given? */
    if encoding = null then encoding = 'IBM-1047'
    parse value encoding with .'-'codep .
    /* test if localrep is present */
    cmd = '[[ -d 'localrep' ]] && echo 1'
    x = docmd(cmd)
    if so.0 = 1 & so.1 = 1 then do
      /* ok, localrep is there. better not have zigirep */
      cmd = '[[ -d 'localrep'/'zigirep' ]] && echo 1'
      x = docmd(cmd)
      if so.0 = 1 & so.1 = 1 then do
        zerrsm = "Failed."
        zerrlm = "Error: "localrep"/"zigirep" exists and must not."
        'setmsg msg(isrz003)'
        leave
      end
    end
    saverep = localrep
    'vput (saverep) profile'
    /* If we made it here, we can freely git init */
    zs1 = 'Creating your repository'
    zs2 = 'Please standby'
    call do_popup
    x = docmd('cd 'localrep' && git init 'zigirep)
    call do_git_attributes
    if readonly = 'Y' then call set_read_only

    Address ISPExec
    zigikey = localrep'/'zigirep
    zigidate = date('n')
    reponame = zigirep
    call set_sortdate
    'tbadd zigirepo order'
    zpush = defcpush
    'vget (defrsort srr src srp srl) profile'
    if defrsort /= null then
    'TBSort zigirepo Fields('defrsort')'
    'TBSAVE zigirepo REPLCOPY LIBRARY('isptabl')'
    leave
  end
  return 0

do_git_attributes:
  /* The git repo is initialized. Time to stick a
  .gitattributes (ASCII) in there */
  cmd = 'ls' localrep'/'zigirep'/.gitattributes'
  x = docmd(cmd)
  if so.0 = 1 then return
  call syscalls 'ON'
  address syscall
  path = localrep"/"zigirep"/.ga"
  'open' path,
    O_rdwr+O_creat+O_trunc,
    660
  if retval = -1 then do
    Address ISPExec
    zs1 = "Something bad when creating .gitattributes. Make errormsg"
    zs4 = 'Press F3 to close this popup and exit.'
    parse value '' with zs2 zs3
    call do_popup4
    call syscalls 'OFF'
    return
  end
  fd = retval  /* as I think it's weird to write to a retval lol */
  call write_fd ,
    "# This .gitattributes file is autogenerated with ZIGI" ver
  call write_fd ,
    "*   git-encoding=utf-8 zos-working-tree-encoding="encoding
  ga3a = ".gitattributes    "
  ga3b = "git-encoding=utf-8 zos-working-tree-encoding=iso8859-1"
  ga3  = ga3a || ga3b
  call write_fd ga3
  ga4a = ".gitignore        "
  ga4b = "git-encoding=utf-8 zos-working-tree-encoding="encoding
  ga4  = ga4a || ga4b
  call write_fd  ga4
  ga5a = ".zigi/*           "
  ga5b = "git-encoding=utf-8 zos-working-tree-encoding="encoding
  ga5  = ga5a || ga5b
  call write_fd  ga5
  binaries = '*.docm *.docx *.doc *.dotx *.pdf *.epub *.mobi *.azw3' ,
    '*.jpg *.jpeg *.png *.gif *.zip *.gzip *.tz *.z *.Z *.pax' ,
    '*.ppt *.pptx *.xls *.xlsx *.xlsm *.obj *.bin'
  do gai = 1 to words(binaries)
    ga = word(binaries,gai) 'binary'
    call write_fd ga
  end
  'close' fd
  call syscalls 'OFF'
  /* -------------------- .gitattributes written ----------- */
  /*             UNFORTUNATELY, IT'S IN EBCDIC :(            */
  /* ------------------------------------------------------- */
  reporoot = localrep'/'zigirep'/'
  /* convert to iso8859-1 */
  cmd = 'cd 'localrep'/'zigirep' && '
  cmd = cmd '/bin/iconv -f' encoding '-t iso8859-1 .ga'
  cmd = cmd ' > .gitattributes'
  x = docmd(cmd)

  /* delete the .ga file */
  cmd = 'cd 'localrep'/'zigirep' && rm -rf .ga'
  x = docmd(cmd)

  /* tag it and bag it */
  cmd = 'cd 'localrep'/'zigirep' && '
  cmd = cmd 'chtag -tc iso8859-1 .gitattributes'
  x = docmd(cmd)

  /* Create the .zigi folder in the repo and add the dsn-file */
  cmd = 'cd 'localrep'/'zigirep' && mkdir .zigi'
  x = docmd(cmd)

  /* Fill dsn file with the comments */
  path = localrep"/"zigirep"/.zigi/dsn"
  'open' path,
    O_rdwr+O_creat+O_trunc,
    660
  if retval = -1 then do
    Address ISPExec
    zs1 = "Something bad when creating .zigi/dsn."
    zs4 = 'Press F3 to close this popup and exit.'
    parse value '' with zs2 zs3
    call do_popup4
    return
  end
  fd = retval  /* as I think it's weird to write to a retval lol */
  call write_fd "# ZIGI dsn-file"
  call write_fd "# This file needs to be here."
  call write_fd "# Don't edit unless you know what you're doing :)"
  call write_fd '#  '
  call write_fd '# record format is (case insensitive):'
  call write_fd '#  '
  call write_fd '# Position - description'
  call write_fd '#  '
  call write_fd '# 1 - directory name which will be prefixed by the'
  call write_fd '#     defined HLQ to create the z/OS dataset'
  call write_fd '#     (* defines the default)'
  call write_fd '# 2 - PS or PO (dataset organization)'
  call write_fd '#     PS for a flat file'
  call write_fd '#     PO for a directory and thus a partitioned dataset'
  call write_fd '# 3 - record format (FB or VB)'
  call write_fd '# 4 - lrecl'
  call write_fd '# 5 - blksize'
  call write_fd '#     0 is allowed if system determined blksize is enabled'
  call write_fd '# 6 - extension (optional - if used then no period)'
  call write_fd '#     file extension to be used for PDS members in USS'
  call write_fd '#  '
  call write_fd '# Default DSORG and DCB info'
  call write_fd '* PO FB 80 32720'
  'close' fd

  /* ------------------ Let's make our first commit :)       */
  x = docmd('cd 'reporoot' && git add .gitattributes')

  x = docmd('cd 'reporoot ,
  ' && chtag -tc' codep '.zigi/dsn' ,
  ' && git add .zigi/dsn')

  commitmsg = ".gitattributes created and added by ZIGI"
  x = docmd('cd 'reporoot' && git commit -m "'commitmsg'"')
  return

  /* ---------------------------------------------------------- *
  | Generalized routine to view stdout. (so.) or stderr. (se.) |
  | based on the parm passed                                   |
  * ---------------------------------------------------------- */
view_std:
  arg stdopt viewopt
  if stdopt = null then viewopt = 'B'
  if viewopt = null then viewopt = 'B'
  if stdopt = 'X' then stdopt = null
  if datatype(so.0) /= 'NUM' then so.0 = 0
  if datatype(se.0) /= 'NUM' then se.0 = 0
  if viewopt = 'B' then if so.0 + se.0 = 0 then return
  /* ------------------------------- *
  | Randomly define a DDName to use |
  * ------------------------------- */
  dd = 'zd'random(9999)
  /* --------------------------------------- *
  | Get lrecl to determine dcb for temp d/s |
  * --------------------------------------- */
  if stdopt /= 'C' then do
    vlrecl = 0
    do li  = 1 to so.0
      so.li = strip(so.li,'T')
      if length(so.li) > vlrecl then vlrecl = length(so.li)
      if so.li = null then so.li = ' '
    end
    do li  = 1 to se.0
      se.li = strip(se.li,'T')
      if length(se.li) > vlrecl then vlrecl = length(se.li)
      if se.li = null then se.li = ' '
    end
    sec = so.0 + se.0
  end
  else do
    do li = 1 to combine.0
      if length(combine.li) > vlrecl then vlrecl = length(combine.li)
    end
    sec = combine.0
  end
  if vlrecl < 81 then vlrecl = 80
  /* ------------------------------------------ *
  | Allocate a temporary data set for our data |
  * ------------------------------------------ */
  Address TSO
  /* calculate space needed with avg 50 bytes per record */
  prim = (((so.0 + se.0) * 50) % 56000) + 1
  if prim < 2 then prim = 5
  if viewopt = 'V' then do
    if sysvar('syspref') = null then pref = userid()'.'
    else pref = null
    vdsn = pref'work.zigi.gitdata'
  end
  else vdsn = null
  x = listdsi(vdsn)
  if x = 0 then do
    call outtrap 'x.'
    'delete' vdsn
    call outtrap 'off'
  end
  if vdsn /= null then vdsnp = 'da('vdsn') unit(3390)'
  else vdsnp = null
  'Alloc f('dd') new spa('prim','prim') tr' ,
    'recfm(v b) lrecl('vlrecl+4') blksize(0)' vdsnp
  /* ----------------------------- *
  | If stdopt is 'B' then do both |
  * ----------------------------- */
  if stdopt /= 'C' then do
    stdopt = null
    sc = so.0
    sc = sc + 1
    so.sc = left('-',70,'-')
    sc = sc + 1
    so.sc = 'Command:' cmd
    so.0 = sc
    do xi = 1 to se.0
      sc = sc + 1
      so.sc = se.xi
    end
    so.0 = sc
  end
  /* ----------------------- *
  | Write out the stem data |
  * ----------------------- */
  if stdopt = 'C' then do
    'Execio * diskw' dd '(finis stem combine.'
    drop combine.
    combine.0 = 0
  end
  if stdopt /= 'C' then do
    if stdopt = null
    then do
      'Execio * diskw' dd '(finis stem so.'
    end
    else do
      'Execio * diskw' dd '(finis stem se.'
    end
  end
  /* -------------------------------------------------- *
  | Access the Temporary Data Set using ISPF           |
  | Library Services.                                  |
  | Then using ISPF Browse service to browse the data. |
  | And use Library Services to Free the Data Set.     |
  * -------------------------------------------------- */
  Address ISPExec
  if sec > 0 then if viewopt = 'B' then do
    'lminit dataid(ddb) ddname('dd')'
    'browse dataid('ddb') panel(zigibrow)'
    'lmfree dataid('ddb')'
  end
  else do
    vmac = 'Panel(zigiedit) macro(zigivmac)'
    'view dataset('vdsn')' vmac
    vtitle = null
    'verase vtitle'
  end
  /* ----------------------------- *
  | Last Free the z/OS Allocation |
  * ----------------------------- */
  call outtrap 'x.'
  Address TSO ,
    'Free f('dd')'
  if vdsn /= null then
  Address TSO 'Delete' vdsn
  call outtrap 'off'
  return

  /* -------------------------------------------------------- *
  | This routine will generate the users personal SSH Public |
  | Key.                                                     |
  * -------------------------------------------------------- */
Build_SSH:
  parse value '' with zigissh
  zs1 = 'Regenerating your SSH keys'
  call do_keygen
  call catsshk
  return

  /* -------------------------- *
   | Build/Rebuild the SSH Keys |
   * -------------------------- */
Do_Keygen:
  if zs1 = null then
  zs1 = 'No SSH identity found in 'home'/.ssh/id_rsa'
  zs2 = 'Generating keypair, please standby'
  call do_popup
  cmd = 'mkdir -p 'home'/.ssh'
  x = docmd(cmd)
  id_home = home'/.ssh'
  id_rsa_bkup = 'id_rsa.'date('s')
  id_rsa.pub_bkup = 'id_rsa.pub.'date('s')
  if no_key= 1
     then mv_cmd = null
     else mv_cmd = ,
         'mv id_rsa' id_rsa_bkup '&&' ,
         'mv id_rsa.pub' id_rsa.pub_bkup '&&'
  cmd = 'cd' home'/.ssh &&' mv_cmd ,
    'cd .. && ssh-keygen -t rsa -f .ssh/id_rsa'
  x = docmd(cmd)
  call catsshk
  zerrsm = null
  zerrlm = 'SSH Keys regenerated. Old keys saved as' ,
           id_home'/'id_rsa_bkup 'and' ,
           id_home'/'id_rsa.pub_bkup'.' ,
           'Be sure to replace your GIT SSH key and' ,
           'update any authorized_keys files on other servers if' ,
           'appropriate.'
  'setmsg msg(isrz002)'
  return

  /* ------------------------------ *
  | Cat the current ssh key if any |
  * ------------------------------ */
catsshk:
  drop so. se.
  cmd = 'cat' keyfile
  x = docmd(cmd)
  if se.0 = 0
  then do
    zigissh = so.1
    'vput (zigissh) profile'
  end
  else zigissh = null
  return

dsnvalid:
  /* Tests for a 'potentially valid' z/OS datasetname */
  parse arg val_dsn
  if dsninfo.val_dsn /= null then return 'OK'
  if left(val_dsn,1) = '.' then return 'NO'
  if strip(val_dsn) = null then return 'NO'
  if pos(' ',val_dsn) > 0 then return 'NO'
  val_dsn = strip(val_dsn,'B',"'")
  upp = TRANSLATE(val_dsn,".ABCDEFGHIJKLMNOPQRSTUVWXYZ",,
    ".abcdefghijklmnopqrstuvwxyz")
  tdsn = translate(val_dsn,' ','.')
  retval = 'OK'   /* asssume good */
  do dsnvi = 1 to words(tdsn)
    w = word(tdsn,dsnvi)
    if length(w) > 8 then retval = 'NO'
    if pos(left(w,1),'ABCDEFGHIJKLMNOPQRSTUVWXYZ$#@') = 0 then retval = 'NO'
    w = translate(w,copies(' ',40), ,
      'ABCDEFGHIJKLMNOPQRSTUVWXYZ-$#@0123456789')
    w = strip(w)
    if w /= null then retval = 'NO'
  end
  if retval /= 'NO' then
  if upp = val_dsn then do
    smsg = msg()
    call msg 'OFF'
    if sysdsn(val_dsn) = "OK" | sysdsn(val_dsn) = "DATASET NOT FOUND"
    then retval = 'OK'
    else retval = "NO"
    call msg smsg
  end
  return retval

Update_repo_metadata:
  save_fulldsn = fulldsn
  x = debug('update_repo_metadata: zcmd:'zcmd ,
    'zsel:' zsel 'zigirep:' zigirep)
  save_dsn = dsn
  if repo_ztdsels < 2 then
  if rtbl_open = 1 then do
    'tbend' rtbl
    rtbl_open = 0
    ztdsels = 0
    rtop = 0
  end
  if rtbl_open = 0 then
  'TBCreate' rtbl 'Keys(fulldsn) Names(dsnstat dsn filetype)' ,
    'Replace NoWrite'
  rtbl_open = 1
  call get_dsn_info
  /* We always fetch when we start to work on a repo */
  if fetch_flag = 1 then crflag = 1
  if zigi_offline = 1 then crflag = 1
  if crflag = 0 then do
    fetch_flag = 1
    x = debug('fetching remote')
    zs1 = 'Fetching Remote info'
    zs2 = 'Patience . . .'
    if nocrpop /= 1 then
    call do_popup
    nocrpop = 0
    /* get the remote info.....but */
    /* we have to get rid of the tab in git output */
    x = debug('getting the remotes')
    gitcmd = 'git remote -v'
    localdir = localrep'/'zigirep
    x = docmd('cd 'localdir' && 'gitcmd)
      call fix_remote_tab
    if so.0 > 0 then
      parse value so.1 with . (tab) remote1 .
    if so.0 = 0 then do
      remote1 = "<no remote defined>"
      remote2 = null
    end
      'tbmod zigirepo order'
      'TBSAVE zigirepo REPLCOPY LIBRARY('isptabl')'
  end
  cmd = 'cd' localrep'/'zigirep
  /* Fetch only if there's a remote */
  if zigi_offline = 0 then
  if remote1 /= '<no remote defined>' then
  x = docmd(cmd '&& git fetch')
  x = debug('...done fetching remotes')
  fetch_flag = 1
  /* now we get the status for all in the repo */
  if zigi_offline = 0 then
  if crflag = 0 then  do
    if se.0 > 1 then fetchmsg = "Remote updates, check status"
    else fetchmsg = "No remote updates"
    zs1 = 'Updating Repo and/or Getting Stats'
    zs2 = 'Patience . . .'
    call do_popup
  end
  /* get all the files that are in the repo */
  x = debug('getting all files in repo-1')
  address syscall
  'readdir 'localrep'/'zigirep' root.'
  /* check for .zigi/dsn */
  'lstat' localrep'/'zigirep'/.zigi/dsn st.'
  if st.0 = 0 then nonzigi = 1
  else nonzigi = 0
  address ispexec
  if check_flag = 1 then do
    x = debug('Checking z/OS dataset last reference dates.')
    zs1 = 'Checking z/OS dataset change status.'
    zs2 = 'Patience . . .'
    call do_popup
    check_files = zigirefd(localrep'/'zigirep pdshlq qualignr 'C')
    x = debug('Check complete.')
  end
  else check_files = '*'
  do umdi = 1 to root.0
    if left(root.umdi,1) = "." then iterate
    else do
      /* not the . and .. things */
      if dsnvalid(root.umdi) = "OK" then do
        /* and only for valid z/OS-datasets (skip README.md et al) */
        r = root.umdi
        x = debug('   check file or dir')
        cmd = '[ -d 'localrep'/'zigirep'/'r' ] && echo "DIR"'
        so.1 = null
        x = docmd(cmd)
        y = debug('   done')
        fulldsn = add_dsn_hlq(root.umdi)
        edsn = strip(fulldsn,'B',"'")
        if check_files /= null then
        if wordpos(edsn,check_files) = 0 then iterate
        x = listdsi(fulldsn)
        if sysdsorg = 'PO' then so.1 = 'DIR'
        else so.1 = null
        zs1 = 'Checking' fulldsn
        zs2 = 'Patience . . .'
        call do_popup
        if so.1 = "DIR" & x = 0 then do
          x = debug('its a dir...lmmstat all the things' edsn)
          Address TSO
          /* Oh yeah we need this */
          root.umdi = root.umdi
          statpath = localrep'/'zigirep'/.zigi/'root.umdi
          statfile = root.umdi

          Address ISPExec ,
             'vput (debugfil defruid readonly dovedir)'
          mem_delta = zigistat("'"edsn"'" statpath 'C')
          if mem_delta = 0 then mem_delta = null
          Address ISPExec

          /* ---------------------------------------------------------- *
          | If using enhanced_cp (getpds) then use getpds to copy all  |
          | updated members. If the file is mixed then copy the binary |
          | members again.                                             |
          * ---------------------------------------------------------- */
          if enhanced_cp = 1 & sysrecfm /= 'U' then do
            file = root.umdi
            file_len = length(file)
            is_bin = is_binfile(root.umdi)
            mixed  = check_mixed_bintext(root.umdi)
            bin_members = null
            if mixed = 1 then do gb = 1 to binfiles.0
              if left(binfiles.gb,file_len) /= file then iterate
              parse value binfiles.gb with gf'/'gm
              bin_members = bin_members gm
            end
            if is_bin = 1 then binopt = '-b'
            else binopt = null
            if zdsn.file = null
            then filesuf = ',upp=Y'
            else filesuf = ',su='zdsn.file
            if binopt /= '-b' then
               filesuf = filesuf',tag=y -t' codep
            cmd = 'cd' localrep'/'zigirep'/'file '&&' ,
              'getpds' binopt '-LI -M' ,
              'st='statpath',upd=n'filesuf '//'edsn '.' ,
              '&& chtag -tc' encoding statpath
            x = docmd(cmd)
       /* ---------------------------------------------------------------- *
        | If mixed and there are binary members then copy all of them      |
        | with replace=yes (r=y). We can't do an upd=n since the stats     |
        | file was just updated with the previous getpds copy all updates. |
        * ---------------------------------------------------------------- */
            if strip(bin_members) /= null then do
              bin_members = translate(strip(bin_members),',',' ')
              cmd = 'cd' localrep'/'zigirep'/'file '&&' ,
                'getpds -b -LI -M' ,
                'st='statpath',r=y'filesuf ,
                '//'edsn"'("bin_members")'" '.' ,
              '&& chtag -tc' encoding statpath
            x = docmd(cmd)
            end
          end
          else do
            mem_hit = 0
            memcount = words(mem_delta)
            do im = 1 to words(mem_delta)
              mem = word(mem_delta,im)
              file = root.umdi
              m = strip(mem)
              e = edsn
              r = file
              if zdsn.file /= null
              then do
                rm = lower(strip(m)'.'zdsn.file)
                extopt = null
              end
              else do
                rm = m
                extopt = '-U'
              end
              rm = strip(rm)
              /* Binary v1, check if PDS is a bin, then copy binary */
              if is_binfile(file'/*') = 1 then do
                binopt = '-B'
              end
              else do
                binopt = null
              end
              if is_binfile(file'/'rm) = 1 then do
                binopt = '-B'
              end
              else do
                binopt = '-T'
              end
              if binopt = '-T'
              then bintext = 'as Text'
              else bintext = 'as Binary'
              cplmod = null
              if sysrecfm = 'U' then
              if sysdsorg = 'PO' then do
                binopt = null
                cplmod = '-X -I'
                bintext = 'as LMod'
              end
              copycmd = "//'"e"("m")'"
              copycmd = '"'copycmd'"'
              copycmd = "cp" binopt cplmod extopt "-v" copycmd ,
                localrep"/"zigirep
              copycmd = copycmd || "/"r"/"rm
              zs1 = 'Copying:' fulldsn
              zs2 = 'Member: ' mem 'to' '/'clean(r)'/'clean(rm)
              zs3 = 'Progress:' im 'of' left(memcount,6) bintext
              call do_popup3
              x = do_copy(copycmd)
              if x > 0 then call view_std 'B'
              x = debug('Copy:' copycmd)
              if strip(binopt''cplmod) /= '-T' then do
                tagcmd = 'chtag -b 'localrep'/'zigirep'/'r'/'rm
                x = docmd(tagcmd)
              end
              else do /* text file tag */
                tagcmd = 'chtag -tc' codep localrep'/'zigirep'/'r'/'rm
                x = docmd(tagcmd)
                end
              mem_hit = 1
            end
          end
          /* ------------------------------------------------------- *
          | If any files in the directory do not have a counterpart |
          | in the PDS that indicates the member was deleted from   |
          | the PDS prior to ZIGI. Need to remove it from OMVS      |
          | and git.                                                |
          * ------------------------------------------------------- */
          address syscall 'readdir' localrep'/'zigirep'/'r rd.
          mem_omvs = null
          allmems = null
          'vget (allmemsc)'
          if strip(allmemsc) = null then allmemsc = 0
          do im = 1 to allmemsc
            'vget (allmems'im')'
            interpret 'allmems = allmems allmems'im
            'verase (allmems'im')'
          end
          do im = 1 to rd.0
            if left(rd.im,1) = '.' then iterate
            m = strip(rd.im)
            mfile = m
              parse value m with m'.'.
            m = translate(m)
            if wordpos(m,allmems) = 0 then do
              mem_omvs = mem_omvs mfile
            end
          end
          if strip(mem_omvs) /= null then do
            x = debug('PDS members deleted - removing from OMVS:' ,
              mem_omvs)
            mem_hit = 1
            cmrecover = 0
            delkeep_members = null
            x = confirm_mem_deletes()
            if strip(mem_omvs) = null then x = 4
            if x = 0 then do
              zs1 = 'Deletions being processed.'
              zs2 = 'Should not take long.'
              call do_popup
              mem_omvs = strip(mem_omvs)
              cmd = 'cd' localrep'/'zigirep'/'r'/'
              cmd = cmd '&& rm -f' mem_omvs
              x = docmd(cmd)
              if x > 0 then call view_std 'B'
              cmd = 'cd' localrep'/'zigirep'/'r ,
                '&& git rm -f' mem_omvs
              x = docmd(cmd)
              if x > 0 then call view_std 'B'
            end
            if cmrecover = 1 then call fix_mem_stats
          end
          /* --------------------------------------------------------- *
          | If members were updated then need to update the stat file |
          * --------------------------------------------------------- */
          if mem_hit = 1 then do
            if enhanced_cp = 0 | sysrecfm = 'U' then
            x = zigistat("'"edsn"'" statpath 'S')
            else do
              uscmd = statpath "'"edsn"'"
              call update_stats uscmd
            end
            cmd = 'cd' localrep'/'zigirep'/.zigi'
            cmd = cmd '&& git add -A .'
          end
        end
        else if nonzigi = 0 then do
          /* It must be a PS, just copy it over to OMVS */
          x = listdsi(fulldsn)
          if x = 0 then do
            s = fulldsn
            if is_binfile(r) = 1 then do
              binopt = '-B'
            end
            else do
              binopt = '-T'
            end
            cplmod = null
            if sysrecfm = 'U' then
            if sysdsorg = 'PO' then do
              binopt = null
              cplmod = '-X -I'
            end
            zs1 = 'Copying:' fulldsn
            zs2 = 'To:     ' localrep'/'zigirep
            call do_popup
            copycmd = "//"s
            copycmd = '"'copycmd'"'
            copycmd = "cp "binopt cplmod" -U -v" copycmd" "localrep"/"zigirep
            copycmd = copycmd || "/"r
            x = do_copy(copycmd)
            if x > 0 then call view_std 'B'
            x = debug('Copy:' copycmd)
            if strip(binopt''cplmod) /= '-T' then do
              tagcmd = 'chtag -b 'localrep'/'zigirep'/'r
              x = docmd(tagcmd)
            end
          end
        end
      end
    end
  end

  if check_flag = 1 then do
    zs1 = 'Updating z/OS Dataset Last Access Information.'
    zs2 = 'Patience . . .'
    call do_popup
    x = debug('Calling zigirefd to update last access info.')
    x = zigirefd(localrep'/'zigirep pdshlq qualignr 'U')
    x = debug('Completed the last access update.')
  end
  zs1 = 'Building List of repository Data Sets'
  zs2 = fetchmsg
  call do_popup
  x = debug('get the status')
  cmd = 'cd' localrep'/'zigirep
  x = docmd(cmd '&& git status --porcelain')
  x = debug('done')
  /* get the stuff from the repo-file */
  x = debug('get all the files (again?)')
  address syscall
  'readdir 'localrep'/'zigirep' root. rstat.'
  address ispexec
  x = debug('done')
  x = debug('iterate the files')
  do rooti = 1 to root.0
    zs1 = 'Updating dataset and file Git status to display.'
    zs2 = 'Patience . . .'
    call do_popup
    dsnstat = null
    if root.rooti = "." | root.rooti = ".." then do
      iterate
    end
    else do
      if dsnvalid(root.rooti) = "OK" then do
        x = debug('Get the git status and fill dsnstat' root.rooti)
        dsn = root.rooti
        filet. = null
        do ii = 1 to so.0
          stat = substr(so.ii,1,2)
          PATH = substr(so.ii,4)
          dsnstat = null
          if pos('/',path) > 0
          then parse value path with test'/'.
          else test = path
          if test = dsn then
          Select
            When stat = '??' then do
              filet.dsn = stat
              leave
            end
            When right(stat,1) /= ' '
            then filet.dsn = ' M'
            When left(stat,1) /= ' ' & filet.dsn = null
            then filet.dsn = 'M '
            Otherwise nop
          end
        end

        if filet.dsn /= null then
        dsnstat = porcelain(filet.dsn)
        x = debug('done')

        'tbmod zigirepo order'
        fulldsn = add_dsn_hlq(dsn)
        if nonzigi = 0 then do
          call outtrap 'x.'
          if sysdsn(fulldsn) /= ok then dsnstat = 'Missing z/OS Dataset'
          call outtrap 'off'
        end
        else if sysdsn(fulldsn) /= 'OK' then fulldsn = dsn
        'tbadd' rtbl
      end
      /* -------------------------------------------------- *
      | If NOT a z/OS dataset then it must be an OMVS file |
      | make sure it isn't a . file and then add it        |
      * -------------------------------------------------- */
      else do
        if left(root.rooti,1) /= '.' then do
          dsn = root.rooti
          if rstat.rooti.1 = 1 then filetype = '(D)'
          else filetype = null
          fulldsn = dsn
          do ii = 1 to so.0
            stat = substr(so.ii,1,2)
            PATH = substr(so.ii,4)
            if left(path,1) = '"' then
            path = strip(path,'B','"')
            spos = POS('/',zigirep)
            cutrep = substr(zigirep,spos+1)
            trywith = cutrep'/'fulldsn
            if pos(dsn, PATH) = 1 then do
              dsnstat = porcelain(stat)
              leave
            end
            if pos(trywith, PATH) = 1 then do
              dsnstat = porcelain(stat)
              leave
            end
            /* Ugly fix for uss files with a space */
            if pos('"'dsn'"', PATH) = 1 then do
              dsnstat = porcelain(stat)
              leave
            end
            /* end of ugly fix */
          end
          'tbadd' rtbl
          filetype = null
        end
      end
    end
  end

  /* --------------------------- *
  | Get the current branch info |
  * --------------------------- */
  zs1 = 'Getting current Git Status.'
  zs2 = 'Patience . . .'
  call do_popup
  x = debug('getting git status for current branch')
  x = docmd('cd 'localdir' && git status')
  branch = word(so.1,3)
  if so.0 > 1 then call Update_Status
  else do
    parse value '' with bstat baction
  end
  if created /= 1 then
  if pos('clean',baction) = 0 then
  if show_status = 'Y' then call view_std 'B'
  created = null
  show_status = 'N'
  'tbsort' rtbl 'fields(dsn,c,a)'
  fulldsn = save_fulldsn
  'tbmod zigirepo order'
  dsn = save_dsn
  x = debug('Done with update_repo_metadata' zigirep)
  return

  /* -------------------------------------------- *
  | Update the status with more meaningful info. |
  * -------------------------------------------- */
Update_Status:
  parse value '' with bstat baction
  do usi = 1 to so.0
    Select
      When bstat = null & ,
        pos('up-to-date',so.usi) > 0 then bstat = so.usi
      When bstat = null & ,
        pos('branch is behind',so.usi) > 0 then
      parse value so.usi with bstat',' .
      When bstat = null & ,
        pos('branch is ahead',so.usi) > 0 then
      parse value so.usi with bstat',' .
      When pos('working tree clean',so.usi) > 0 then baction = so.usi
      When pos('Untracked files:',so.usi)   > 0 then baction = so.usi
      When pos('Changes not staged',so.usi) > 0 then baction = so.usi
      When pos('Changes to be comm',so.usi) > 0 then baction = so.usi
      Otherwise nop
    end
  end
  Return

  /* ----------------------------------------------------- *
  | Confirm the delete of a member with optional recovery |
  * ----------------------------------------------------- */
Confirm_Mem_Deletes:
  tbcd = 'zcd'time('s')
  cmdhit = 0
  zdconf = 'N'
  'tbcreate' tbcd 'names(dmrow dmorig dmstate) nowrite'
  do cmdi = 1 to words(mem_omvs)
    dmrow = word(mem_omvs,cmdi)
    dmorig = dmrow
    dmstate = null
    if pos('.',dmrow) > 0 then do
      parse value dmrow with dmrow'.'.
      dmrow = translate(dmrow)
    end
    cmdhit = 1
    'tbadd' tbcd
  end
  'tbsort' tbcd 'fields(dmrow,ch,a)'
  'tbtop' tbcd
  if cmdhit = 0 then do
    'tbdelete' tbcd
    return 4
  end
  cmtop = 0
  cmtsels = 0
  do forever
    dsel = null
    if cmtsels < 1 then do
      if cmtop > 0 then do
        'tbtop' tbcd
        'tbskip' tbcd 'number('cmtop')'
      end
      'tbdispl' tbcd 'panel(zigicdm)'
    end
    else 'tbdispl' tbcd
    drc = rc
    cmtsels = ztdsels
    if drc > 4 then do
    if zdconf = 'Y' then return 0
    else return 4
    end
    cmtop = ztdtop
    if dsel /= null then
    Select
      When dsel = 'R' then do
        cmrecover = 1
        delkeep_members = delkeep_members dmrow
        if is_binfile(r'/'dmrow) = 1
        then cbinopt = '-B'
        else cbinopt = null
        x = listdsi(fulldsn)
        if sysdsorg = 'PO' then
        if sysrecfm = 'U' then cbinopt = '-X -I'
        dw = wordpos(dmorig,mem_omvs)
        mem_omvs = delword(mem_omvs,dw,1)
        tdsn = "'"strip(fulldsn,'B',"'")"("dmrow")'"
        rd = translate(r)
        cmd = 'cp -v -U' cbinopt localrep'/'zigirep'/'rd'/'dmorig '"//'tdsn'"'
        x = do_copy(cmd)
        if x > 0 then call view_std 'B'
        dmstate = 'Recovered'
        'tbput' tbcd
      end
      When dsel = 'E' then
      Address TSO ,
        'oedit' localrep'/'zigirep'/'r'/'dmorig
      Otherwise Address TSO ,
        'obrowse' localrep'/'zigirep'/'r'/'dmorig
    end
  end
  'tbdelete' tbcd
  return 0

Fix_mem_stats:
  cmd = 'cd' localrep'/'zigirep'/.zigi/'
  cmd = cmd '&& cat' r
  x = docmd(cmd)
  do fmsi = 1 to so.0
    do fmsim = 1 to words(delkeep_members)
      dmbr = word(delkeep_members,fmsim)
      if word(so.fmsi,1) = dmbr then call add_stats so.i
    end
  end
  return

porcelain:
  parse arg stat

  /* parse git status --short as documented in
  https://www.git-scm.com/docs/git-status#_short_format */

  Select
    When stat == " M" then res = "Modified"
    When stat == " D" then res = "Deleted"
    When stat == " R" then res = "Renamed"
    When stat == " C" then res = "Copied"
    When stat == "M " then res = "Ready to commit"
    When stat == "??" then res = "Untracked"
    When stat == "MM" then res = "Modified"
    When stat == "AM" then res = "Modified"
    When stat == "RM" then res = "Modified"
    When stat == "CM" then res = "Modified"
    When stat == "MD" then res = "Deleted"
    When stat == "AD" then res = "Deleted"
    When stat == "RD" then res = "Deleted"
    When stat == "CD" then res = "Deleted"
    When stat == "DR" then res = "Renamed"
    When stat == "DC" then res = "Copied"
    When stat == "??" then res = "Untracked"
    When stat == "||" then res = "Ignored"
    When left(stat,1) == " " then res = "Not Updated"
    When left(stat,1) == "M" then res = "Updated in index"
    When left(stat,1) == "A" then res = "Added to index"
    When left(stat,1) == "D" then res = "Deleted from index"
    When left(stat,1) == "R" then res = "Renamed in index"
    When left(stat,1) == "C" then res = "Copied in index"
    Otherwise res = null
  end
  return '[' || stat || '] ' || res

clean:
  parse arg string
  if pos('\',string) = 0 then return string
  string = translate(string,' ','\')
  return strip(string)

usssafe:
  parse arg safe_command
  safe_ret = 1
  if pos('\$',safe_command) > 0 then safe_ret = 0
  if pos('\#',safe_command) > 0 then safe_ret = 0
  if safe_ret = 0 then return safe_command
  if pos('$',safe_command)  > 0 then safe_ret = 1
  if pos('#',safe_command)  > 0 then safe_ret = 1
  if safe_ret = 0 then return safe_command
  safe$pos = 1
  do forever
    pos$safe = pos('$',safe_command,safe$pos)
    if pos$safe < 1 then leave
    left$safe = left(safe_command,pos$safe-1)
    right$save = substr(safe_command,pos$safe)
    safe_command = left$safe'\'right$save
    safe$pos = pos$safe + 2
  end
  safe$pos = 1
  do forever
    pos$safe = pos('#',safe_command,safe$pos)
    if pos$safe < 1 then return safe_command
    left$safe = left(safe_command,pos$safe-1)
    right$save = substr(safe_command,pos$safe)
    safe_command = left$safe'\'right$save
    safe$pos = pos$safe + 2
  end
  return safe_command

Remove_Safe:
  parse arg safe_command
  if pos('\$',safe_command) = 0 then return safe_command
  do until pos('\',safe_command) = 0
    parse value safe_command with sl'\'sr
    safe_command = sl''sr
  end
  return safe_command

  /* ------------------------------------------------- *
  |                                                  |
  | String replace routine                           |
  | input string                                     |
  | from string                                      |
  | to string                                        |
  | translate is input to from                       |
  * ------------------------------------------------- */
strreplace:
  string  = arg(1)
  strfrom = arg(2)
  strto   = arg(3)
  if pos(strfrom,string) = 0 then return string
  newString = ''
  do repi = 1 to length(string)
    if substr(string,repi,1) /= strfrom
    then newstring = newstring''substr(string,repi,1)
    else  newstring = newstring''strto
  end
  return newstring

  /* ------------------------------------------------------ *
  | The pfshow routine will:                               |
  | 1. check to see the passed option                      |
  | 2. if Off then it will save the current pfshow setting |
  |    - save the current setting                          |
  |    - turn off pfshow                                   |
  | 3. if the option is Reset then it will                 |
  |    - test if pfshow was on and turn it back on         |
  * ------------------------------------------------------ */
pfshow:
  if zpfshow = 'OFF' then return
  arg pfkopt
  if pfkopt = 'RESET' then do
    if pfkeys = 'ON' then
    'select pgm(ispopf) parm(FKA,ON)'
  end
  if pfkopt = 'OFF' then do
    'vget (zpfshow)'
    pfkeys = zpfshow
    if pfkeys /= 'OFF' then
    'select pgm(ispopf) parm(FKA,OFF)'
  end
  return

  /* ------------------------------- *
  | Add a dataset to the repository |
  * ------------------------------- */
Add_Dataset:
  parse value '' with zcmd what list dsnapfx zsel
  call get_dsn_info
  save_extfile = extfile
  dsnapfx = pdshlq
  s_dsnapfx = dsnapfx
  lc_count = 0
  add_count = 0
  last_find = 0
  top = 0
  save_top = 0
  dsnatbl = 'ZIGID'random(999)
  call tbcreate_dsnatbl
  if qualignr > 0 then
  if dsnapfx = null then qualignr = null
  do forever
    parse value '' with zsel zcmd row
    'tbquery' rtbl 'rownum(rows)'
    if rows = 0 | qualignr = 0 | qualignr = null
    then dsnapnl = 'zigidsna'
    else do
      dsnapnl = 'zigidsnb'
      if list /= 1 then
      call get_list
    end
    if ztdsels > 1
    then 'tbdispl' dsnatbl
    else do
      select
        when add_count = 0 & list = 1 then csr = 'ZSEL'
        when dsnapfx  = null then csr = 'DSNAPFX'
        when qualignr = null then csr = 'QUALIGNR'
        otherwise csr = 'ZCMD'
      end
      zigpass = 'PASSTHRU'
      'vput (zigpass) shared'
      'tbtop' dsnatbl
      'tbskip' dsnatbl 'number('top')'
      'tbdispl' dsnatbl 'panel('dsnapnl') cursor('csr')'
      trc = rc
      zigpass = null
      'vput (zigpass) shared'
      rc = trc
    end
    top = ztdtop
    if add_count > 0 then
    pdshlq  = dsnapfx
    if trc > 4 then do
      zsel = null
      'tbput' rtbl
      'tbend' dsnatbl
      'tbsort' rtbl 'fields(dsn,c,a)'
      'tbtop' rtbl
      if qualignr = 0 then pdshlq = null
      if add_count > 0 then
      'tbmod zigirepo order'
      'TBSAVE zigirepo REPLCOPY LIBRARY('isptabl')'
      extfile = save_extfile
      return
    end
    if dsnapfx /= s_dsnapfx then do
      s_dsnapfx = dsnapfx
      zcmd = null
      zsel = null
      row = 0
      call get_list
    end
    if row = 0 then zsel = null
    if row <> null then
    if row > 0 then do
      'TBTop' dsnatbl
      'TBSkip' dsnatbl 'Number('row')'
    end

    zcmd = translate(zcmd)
    rf = 0
    if abbrev('RFIND',word(zcmd,1),2) = 1 then do
      zcmd = 'FIND' finddsn
      rf = 1
      'TBTop' dsnatbl
      'TBSkip' dsnatbl 'Number('last_find+1') rowid(row)'
      if rc > 0 then do
        'TBTop' dsnatbl
        last_find = 0
        'TBSkip' dsnatbl 'Number('last_find+1') rowid(row)'
      end
    end
    if abbrev('FIND',word(zcmd,1),1) = 1 then do
      finddsn = word(zcmd,2)
      if rf = 0 then do
        'TBTop' dsnatbl
        'TBSkip' dsnatbl 'Number('ztdtop') rowid(row)'
        wrap = 0
        found = 0
      end
      save_top = row
      do forever
        if pos(finddsn,dsna) > 0 then do
          found = 1
          zerrsm = 'Found.'
          zerrlm = finddsn 'found in row' row +0
          if wrap = 1 then zerrlm = zerrlm 'Wrap around.'
          'setmsg msg(isrz003)'
          last_find = row
          if datatype(last_find) /= 'NUM' then
          last_find = 0
          top = row
          leave
        end
        /* go to the next row */
        'tbskip' dsnatbl 'rowid(row)'
        if rc > 0 then if found = 0 then do
          zerrsm = 'Not Found.'
          zerrlm = finddsn 'not found.'
          'setmsg msg(isrz003)'
          top = save_top
          last_find = 0
          leave
        end
        if rc > 0 then if found = 1 then do
          wrap = 1
          'tbtop' dsnatbl
          'tbskip' dsnatbl 'rowid(row)'
          last_find = 0
        end
      end
    end

    if zsel /= null then
    Select
      when zsel = 'B' then do
        x = listdsi("'"dsna"'")
        if sysdsorg = 'PO' then do
          "LMInit Dataid(edvbr) dataset('"dsna"')"
          "Memlist Dataid("edvbr") Default(B)"
          mrc = rc
          "LMfree Dataid("edvbr")"
          if mrc > 0 then 'setmsg msg(isrz003)'
        end
        else "Browse Dataset('"dsna"')"
      end
      when zsel = 'S' | zsel = 'A' then do
        rc = check_if_empty(dsna)
        if rc = 0 then do
          rc = Check_Load_Library(dsna)
          if rc = 0 then
          call do_add_copy
          else do
            call do_add_copy 'binary'
            gaupdate = 1
          end
        end
      end
      when zsel = 'AB' then do
        rc = check_if_empty(dsna)
        if rc = 0 then do
          rc = Check_Load_Library(dsna)
          if left(sysrecfm,1) = 'V' then do
            zerrsm = null
            zerrlm = left('DSN:' dsna,74) ,
              'Is RECFM=V and binary may be a problem due to the way' ,
              'the OMVS cp command handles binary data. You should' ,
              'verify that the data is usable after adding it. If not' ,
              'Then convert it to a more portable' ,
              'format (e.g. TSO Transmit or IEBCopy Unload) if you' ,
              'need to have it included in the git repository.'
            'setmsg msg(isrz003)'
          end
          if rc = 0 then do
            call do_add_copy 'binary'
            gaupdate = 1
          end
        end
      end
      Otherwise nop
    end

    if list = null then call get_list
    if lc_count = 0 then do
      zerrsm = 'Empty List'
      zerrlm = 'The requested high level qualifier resulted in zero' ,
        'eligible datasets.'
      'setmsg msg(isrz003)'
    end
    'tbtop' dsnatbl
  end
  if ztdels < 2 then
  if gaupdate = 1 then do
    call get_binfiles
    crflag = 1
    call work_with_repo
  end
  extfile = save_extfile
  return

tbcreate_dsnatbl:
  'tbcreate' dsnatbl 'keys(dsna) names(dastat dsnvol) nowrite'
  return

Check_If_Empty:
 arg dsna
 x = listdsi("'"dsna"'" "dir")
 if sysmembers = 0 then do
    zerrsm = 'Empty.'
    zerrlm = "The selected dataset '"dsna"' is empty so may not be added."
    'setmsg msg(isrz003)'
    return 4
    end
 return 0

Get_List:
  'tbend' dsnatbl
  call tbcreate_dsnatbl
  dsnapfx = strip(dsnapfx)
  if qualignr > 0 then do
    prefix = translate(dsnapfx,' ','.')
    prefix = subword(prefix,1,qualignr)
    prefix = translate(prefix,'.',' ')
  end
  else prefix = dsnapfx
  cmd = 'ls' localrep'/'zigirep
  x = docmd(cmd)
  Address TSO
  call outtrap 'x.'
  do ip = 1 to words(dsnapfx)
    csipfx = word(dsnapfx,ip)
    '%zigircsi 'csipfx'.**'
  end
  call outtrap 'off'
  Address ISPExec
  do dsni = 1 to x.0
    if word(x.dsni,1) /= 'NONVSAM' then iterate
    dsna = word(x.dsni,2)
    dsnvol = word(x.dsni,3)
    dastat = null
    do gl = 1 to so.0
      if qualignr > 0 then do
        if substr(dsna,length(prefix)+2) = word(so.gl,1)
        then dastat = 'Added'
      end
      else do
        if dsna = word(so.gl,1) then dastat = 'Added'
      end
    end
    'tbadd' dsnatbl
    lc_count = lc_count + 1
  end
  if lc_count > 0 then
  list = 1
  return

  /* -------------------------------------------- *
  | Perform the actual copy of the added dataset |
  | or member to the local repository.           |
  * -------------------------------------------- */
Do_Add_Copy:
  arg acopt
  parse arg option with ''
  gabs = 'git-encoding=BINARY binary'
  call get_binfiles
  zsel = null
  ac_mem = null
  copy_dsna = dsna
  if pos('(',dsna) > 0 then
  parse value dsna with dsna'('ac_mem')'
  what = dsna
  FC = listdsi("'"WHAT"'" "DIR")
  dsnb = remove_dsn_hlq(dsna)
  ext = null
  if ac_mem = null then
  if extfile = 'N' then
  if sysdsorg = 'PO' then
  if zdsn.dsnb = null then do
    extans = 'N'
    call pfshow 'off'           /* make sure pfshow is off */
    'addpop row(4) column(6)'
    'display panel(zigiadde)'
    drc = rc
    'rempop'
    call pfshow 'reset'         /* restore pfshow setting */
    if drc = 0 then zdsn.dsnb = ext
    if extans = 'Y' then
    extfile = 'Y'
  end
  if ac_mem /= null then
  if zdsn.dsnb /= null then do
    ac_mem = lower(ac_mem'.'zdsn.dsnb)
  end
  if ac_mem /= null then dsnb = dsnb'/'ac_mem
  zs1 = 'Copying' copy_dsna
  zs2 = 'to' dsnb 'in OMVS'
  if translate(option) = 'BINARY' then do
    zs3 = 'Copy as Binary'
  end
  else do
    zs3 = 'Copy as Text'
  end
  cplmod = null
  if sysrecfm = 'U' then
  if sysdsorg = 'PO'
  then do
    cplmod = '-X -I'
    binopt = null
    option = 'BINARY'
    acopt = 'BINARY'
    zs3 = 'Copy as Load Module'
  end
  if ac_mem = null then do
    if sysmembers /= null
    then patmem = 'Members to copy:' sysmembers
    else patmem = null
  end
  else patmem = null
  zs4 = 'Patience . . .' patmem
  call do_popup4
  DIR = localrep'/'zigirep
  if SYSDSORG = 'PO' then do
    pds = what
    PDS = strip(PDS,"B","'")
    pdss = dsnb
    pdsc = pds
    if pos('/',pdss) > 0 then
    parse value pdss with pdss'/'.
    mkdir = "mkdir -p "DIR"/"pdss ,
            '&& touch' dir'/.zigi/'pdss ,
            '&& chtag -tc' codep localrep'/'zigirep'/.zigi/'pdss
    x = docmd(mkdir)
    binopt = null
    if translate(option) = 'BINARY' then do
      if cplmod = null then
      binopt = '-B'
      if is_binfile(dsnb) = 0 then do
        if ac_mem = null then ga_mem = '*'
        else ga_mem = ac_mem
        /* setting the gitattributes file */
        /* first convert the ASCII atrtib file to ebcdic :( */
        cmd = 'cd 'DIR' &&'
        cmd = cmd 'cat .gitattributes > .gae'
        /* then append the binary attrib for this file */
        cmd = cmd '&& echo "'pdss'/'ga_mem' 'gabs'" >> .gae '
        /* convert it back to ascii */
        cmd = cmd '&& cat .gae '
        cmd = cmd '> .gitattributes '
        /* add (and commit) .gitattributes to the index */
        cmd = cmd '&& git add .gitattributes '
        cmd = cmd ".gitattributes"
        x = docmd(cmd)
        /* finally remove the .gae file */
        cmd = 'cd 'DIR' && rm .gae'
        x = docmd(cmd)
        call view_std 'B'
        call get_binfiles
      end
    end
    if zdsn.dsnb /= null
    then extopt = '-S a=.'zdsn.dsnb
    else extopt = '-U'
    if check_mixed_bintext(dsnb) = 0 | ac_mem /= null then do
      if pos('.',ac_mem) = 0
      then cmem = translate(ac_mem)
      else parse value ac_mem with cmem'.'.
      if ac_mem /= null then pdsc = pdsc"("cmem")"
      call bpxwdyn "alloc da('"pdsc"') shr rtddn(ddname)"
      copycmd = "//'"pdsc"'"
      copycmd = '"'copycmd'"'
      cmd = "cp -v "binopt extopt cplmod copycmd" "DIR"/"pdss"/"ac_mem
      x =do_copy(cmd)
      call bpxwdyn "free  fi("|| ddname ||")"
    end
    else do
      call outtrap 'cm.'
      address tso 'listd' "'"pds"' m"
      call outtrap 'off'
      hit = 0
      cm_count = cm.0 - 6
      call bpxwdyn "alloc da('"pds"') shr rtddn(ddname)"
      do ci = 7 to cm.0
        if pos(')',cm.ci) > 0 then do
          hit = 0
          iterate
        end
        if hit = 1 then iterate
        mem = word(cm.ci,1)
        if pos('ALIAS(',cm.ci) > 0 then hit = 1
        if zdsn.dsnb /= null
        then ussmem = lower(mem)'.'zdsn.dsnb
        else ussmem = mem
        zs2 = 'to' dsnb'/'ussmem
        zs4 = 'Patience . . .' ci-6 'of' cm_count
        if is_binfile(pdss'/'ussmem) = 1 then
        if cplmod = null then do
          binopt = '-B'
          zs3 = 'Copy as Binary'
        end
        else zs3 = 'Copy as Text'
        call do_popup4
        pdsc = pds"("mem")"
        if binopt = null then binopt = '-T'
        copycmd = "//'"pdsc"'"
        copycmd = '"'copycmd'"'
        cmd = "cp -U -v "binopt cplmod copycmd" "dir"/"pdss"/"ussmem
        x =do_copy(cmd)
      end
      call bpxwdyn "free  fi("|| ddname ||")"
    end
    if translate(option) = 'BINARY' then do
      /* for some reason the git autotagging due to .gitattributes
      does not work all the time (?? weird) so we tag it if binary
      */
      tagcmd = 'chtag -bR 'dir'/'pdss'/'ac_mem
      x = docmd(tagcmd)
    end
    if enhanced_cp = 0 | sysrecfm = 'U' then
    x = zigistat("'"pds"'" dir'/.zigi/'pdss 'S')
    else do
      uscmd = dir'/.zigi/'pdss "'"pds"'"
      call update_stats uscmd
    end
    x = docmd('cd' dir '&& git add .zigi/'pdss)
  end
  else do
    W = WHAT
    PSS = dsnb
    binopt = null
    if translate(option) = 'BINARY' then
    if is_binfile(dsnb) = 0 then do
      binopt = '-B'
      /* setting the gitattributes file */
      /* first convert the ASCII atrtib file to ebcdic :( */
      cmd = 'cd 'DIR' && /bin/iconv -f ISO8859-1 -t' encoding
      cmd = cmd '.gitattributes > .gae'
      /* then append the binary attrib for this file */
      cmd = cmd '&& echo "'pss gabs'" >> .gae '
      /* convert it back to ascii */
      cmd = cmd '&& /bin/iconv -f' encoding '-t ISO8859-1 .gae '
      cmd = cmd '> .gitattributes '
      /* add (and commit) .gitattributes to the index */
      cmd = cmd '&& git add .gitattributes '
      /* finally remove the .gae file */
      cmd = cmd '&& rm .gae'
      x = docmd(cmd)
      call get_binfiles
    end
    if sysrecfm = 'U' then
    if sysdsorg = 'PO'
    then binopt = binopt '-X -I'
    copycmd = "//'"W"'"
    copycmd = '"'copycmd'"'
    copycmd = "cp -U -v "binopt copycmd" "DIR"/"pss
    x =do_copy(copycmd)
    if translate(option) = 'BINARY' then do
      /* for some reason the git autotagging due to .gitattributes
      does not work all the time (?? weird) so we tag it if binary
      */
      tagcmd = 'chtag -b 'DIR'/'pss
      x =docmd(tagcmd)
    end
  end
  dsnstat = '[??] Untracked'
  dsn = dsnb
  fulldsn = "'"what"'"
  pdshlq = dsnapfx
  'tbadd' rtbl
  dastat = 'Added'
  'tbmod' dsnatbl
  add_count = add_count + 1
  call save_dsninfo
  return

  /* ------------------------------------------------------- *
  | Get the DCB and optionally Directory info for the added |
  | dataset and save in the /.zigi/dsn file for use when    |
  | creating/recreating the z/OS dataset.                   |
  |                                                         |
  | Routine uses OGET and OPUT along with ALLOC/EXECIO.     |
  |                                                         |
  | Format is:                                              |
  | dsn PS/PO recfm lrecl blksize extension                 |
  | the extension is optional - no preceeding period        |
  * ------------------------------------------------------- */
save_dsninfo:
  /* make sure we aren't saving a member with dsname */
  if pos('/',dsn) > 0 then return
  /* better make sure sd. stem is empty before we start :) */
  sd. = ''
  sd.0 = 0
  x = listdsi(fulldsn)
  dsn_record = dsn sysdsorg sysrecfm syslrecl sysblksize zdsn.dsn
  if sysvar('syspref') = null then pref = sysvar('sysuid')'.'
  else pref = null
  sd_dsn = pref'zigi.t'time('s')
  sd_dd  = 'zdd'time('s')
  path = localrep"/"zigirep"/.zigi/dsn"
  address tso
  call outtrap 'x.'
  "oget '"path"'" sd_dsn 'text'
  'alloc f('sd_dd') shr ds('sd_dsn')'
  'execio * diskr' sd_dd '(finis stem sd.'
  do x = 1 to sd.0
    wd = translate(sd.x,' ','/')
    if word(wd,1) = dsn then do
      sd.x = '*'sd.x
    end
  end
  slast = sd.0
  slast = slast + 1
  sd.slast = dsn_record
  sd.0 = slast
  do sx = 1 to sd.0
    sd.sx = translate(sd.sx,' ','0D'x)
  end
  'execio * diskw' sd_dd '(finis stem sd.'
  call outtrap 'x.'
  'oput' sd_dsn "'"path"' text"
  'free f('sd_dd')'
  'delete' sd_dsn
  cmd = 'cd 'localrep'/'zigirep' && git add .zigi/dsn'
  x = docmd(cmd)
  call outtrap 'off'
  Address ISPExec
  return

Write_FD:
  parse arg string
  string = string || ESC_N
  'write' fd 'string' length(string)
  return

  /* ----------------------------------------------------------- *
  | Undo Routine to revert an element in a Modified state prior |
  | to a commit.                                                |
  * ----------------------------------------------------------- */
Do_Undo:
  if readonly = 1 then do
    zerrsm = 'Invalid.'
    zerrlm = 'UNDO is not supported for ReadOnly Repositories.'
    'setmsg msg(isrz003)'
    return
  end
  arg uopt
  if uopt = 'D' then mem = null
  zerrsm = null
  /* -------------------------------- *
  | Undo a commit. eg checkout --    |
  * -------------------------------- */
  d = dsn
  if uopt = 'M' then
  m = mem

  zs1 = 'Un-modiying 'mem
  zs2 = 'This never happened...'
  call do_popup
  address 'SYSCALL' 'SLEEP (1)'

  if uopt = 'M'
  then parse value memstat with '['vm']' vt
  else parse value dsnstat with '['vm']' vt
  if pos('M',vm) = 0 then do
    zerrsm = 'Not Applicable'
    zerrlm = 'Undo is only valid on a status of [M ] or [ M]' ,
      'where the element is modified or Ready for commit.'
    'setmsg msg(isrz003)'
  end

  /* ------------------------ *
  | check for file extension |
  * ------------------------ */
  if uopt = 'M' then do
    if zdsn.dsn /= null
    then rm = lower(m)'.'zdsn.dsn
    else rm = m
  end

  if zerrsm = null then do
    cmd = 'cd' localrep'/'zigirep
    cmd2 = null
    if pos('Ready to',vt) > 0 then do
      if mem = null
      then cmd2 = '&& git reset HEAD' d
      else do
        cmd2 = '&& git reset HEAD' d'/'rm
        cmd2 = cmd2 '&& git reset HEAD .zigi/'d
        cmd2 = cmd2 '&& git checkout -- .zigi/'d
      end
    end
    if uopt = 'M'
    then cmd = cmd cmd2 ' && git checkout -- 'd'/'rm
    else cmd = cmd cmd2 ' && git checkout -- 'd
    cmd = cmd '&& echo "----------------------"'
    x = docmd(cmd)
    if is_binfile(dsn) = 1 then cpbin = '-B'
    else cpbin = null
    if uopt = 'M' then do
      fdsn = strip(fulldsn,'B',"'")
      cmd = 'cd' localrep'/'zigirep'/'d
      cmd = cmd '&& cp -U' cpbin rm ,
        '"//' || "'"fdsn"("m")'" || '"'
    end
    else do
      cmd = 'cd' localrep'/'zigirep ,
             '&& cp -U' cpbin d ,
             '"//' || "'"strip(fulldsn,'B',"'")"'" || '"'
    end
    x = do_copy(cmd)
    cmd = 'cd' localrep'/'zigirep '&& git status'
    x = docmd(cmd)
    call view_std 'B'
    if uopt = 'M' then do
      sfile = localrep'/'zigirep'/.zigi/'d
      statmems = mem
      'vput (statmems)'
      if enhanced_cp = 0 then
      Address TSO '%zigistat' fulldsn sfile 'U'
      else do
        uscmd = sfile fulldsn
        call update_stats uscmd
      end
      memstat = null
      'tbmod' rtbl
    end
    call update_repo_metadata
    if uopt = 'D'
    then call work_with_repo
    else call work_with_repo_file
  end
  return

  /* ------------------------- *
  | Do Blame for an element   |
  * ------------------------- */
do_blame:
  parse arg element
  zerrlm = null
  zsel = null
  update_flag = 0
  select
    When filetype = '(D)' then zerrlm = 'Blame does not work on directories'
    When left(element,1) = "'" then do
      x = listdsi(element)
      if sysdsorg = 'PO' then
      zerrlm = 'Blame does not work on Partitioned Datasets'
    end
    otherwise nop
  end
  if zerrlm /= null then do
    zerrsm = 'Error.'
    'setmsg msg(isrz003)'
    return
  end
  if zdsn.dsn /= null then do
    if pos('/',element) > 0
    then parse value element with l'/'element
    else l = null
    element = lower(element)'.'zdsn.dsn
    if l /= null then element = l'/'element
  end
  shelement = element
  if pos('/',zigirep) > 0 then do
    parse value zigirep with x'/'zrep
    element = zrep'/'element
  end
  cmd = 'cd' localrep'/'zigirep
  cmd = cmd '&& git blame' element
  x = docmd(cmd)
  call view_std 'B'
  return

  /* ------------------------- *
  | Do History for an element |
  * ------------------------- */
do_history:
  parse arg element
  zerrlm = null
  zsel = null
  update_flag = 0
  select
    When filetype = '(D)' then zerrlm = 'History does not work on directories'
    When left(element,1) = "'" then do
      x = listdsi(element)
      if sysdsorg = 'PO' then
      zerrlm = 'History does not work on Partitioned Datasets'
    end
    otherwise nop
  end
  if zerrlm /= null then do
    zerrsm = 'Error.'
    'setmsg msg(isrz003)'
    return
  end
  if zdsn.dsn /= null then do
    if pos('/',element) > 0
    then parse value element with l'/'element
    else l = null
    element = lower(element)'.'zdsn.dsn
    if l /= null then element = l'/'element
  end
  shelement = element
  if pos('/',zigirep) > 0 then do
    parse value zigirep with x'/'zrep
    element = zrep'/'element
  end
  cmd = 'cd' localrep'/'zigirep
  cmd = cmd '&& git log --cc -n 9999 --unified=1'
  cmd = cmd "--pretty=format:'commit:%h Date:%cD Subject:%f' --name-only" ,
    '| grep -e commit -e' element
  x = docmd(cmd)
  hhit = 0
  hist_tbl = 'ZHIST'random(999)
  'tbcreate' hist_tbl 'Keys(hcommit)' ,
      'Names(hdate hsubject) nowrite'
  do ih = 1 to so.0
    if left(so.ih,7) = 'commit:' then do
      if pos('Date:',so.ih) = 0 then iterate
      parse value so.ih with 'commit:'hcommit . 'Date:'.',' d m year ,
        time zone 'Subject:'hsubject
      m = wordpos(translate(m), ,
        'JAN FEB MAR APR MAY JUN JUL AUG SEP OCT NOV DEC')
      hdate = year'/'right(m+100,2)'/'right(d+100,2) time
    end
    else do
      so.ih =strip(shelement)
      if element /= shelement then iterate
      'tbadd' hist_tbl
      hhit = 1
    end
  end
  if hhit = 0 then do
    zerrsm = 'Warning'
    zerrlm = 'There was no git commit history found.'
    'setmsg msg(isrz003)'
    return
  end
  'control display save'
  if hhit = 1 then do
    delement = element
    if pos('/',delement) > 0 then do
      parse value delement with le'/'re
    end
    'tbsort' hist_tbl 'Fields(hdate,c,d)'
    'tbtop' hist_tbl
    save_top = ztdtop
    top = 1
    save_ztdsels = ztdsels
    last_hfind = 0
    wrap = 0
    do forever
      zsel = null
      if ztdsels > 1 then 'tbdispl' hist_tbl
      else do
        zigpass = 'PASSTHRU'
        'vput (zigpass) shared'
        'tbtop' hist_tbl
        'tbskip' hist_tbl 'number('top')'
        'tbdispl' hist_tbl 'Panel(zigihist)'
        drc = rc
        zigpass = null
        'vput (zigpass) shared'
      end
      if drc > 4 then leave
      top = ztdtop

      if zcmd = 'RFIND' then do
        zcmd = 'FIND' fstring
        'tbtop' hist_tbl
        'tbskip' hist_tbl 'number('last_hfind')'
      end
      if strip(zcmd) /= null then
      if abbrev('FIND',translate(word(zcmd,1))) = 1 then do
        fstring = translate(word(zcmd,2))
        zcmd = null
        do forever
          'tbskip' hist_tbl 'Position(fcrp)'
          if rc > 0 then if wrap = 1 then do
            zerrsm = 'Not Found'
            zerrlm = fstring 'not found.'
            'setmsg msg(isrz003)'
            leave
          end
          else do
            wrap = 1
            'tbtop' hist_tbl
          end
          if pos(fstring,translate(hsubject)) > 0 then do
            top = fcrp + 0
            zerrsm = 'Found'
            if wrap = 1
            then wmsg = 'wrapped.'
            else wmsg = null
            zerrlm = fstring 'found in row' fcrp + 0 wmsg
            last_hfind = fcrp
            wrap = 0
            'setmsg msg(isrz003)'
            leave
          end
        end
      end

      if ztdsels = 0 then
      if pnsdef = 'P' then do
        if row = 0 then zcmd = 'O'
        if row > 0 then zsel = '/'
      end

      if zsel = '/' then do
        call pfshow 'off'           /* make sure pfshow is off */
        'Addpop row(4) column(6)'
        'Display Panel(zigirhst)'
        'rempop'
        call pfshow 'reset'         /* restore pfshow setting */
      end
      if zsel /= null then
      Select
        When zsel = 'C' then call DoHist_ComView
        When zsel = 'R' then call DoHist_Recover
        When zsel = 'S' then call DoHist_ViewSource
        When zsel = 'Z' then call DoHist_Compare
        Otherwise nop
      end
    end
  end
  'control display restore'
  'tbend' hist_tbl
  ztdsels = save_ztdsels
  ztdtop = save_top
  if update_flag = 1 then do
    if sysdsorg = 'PS' then call work_with_repo
    else do
      call update_repo_metadata
      call work_with_repo_file
    end
  end
  return

  /* ---------------------------------------- *
  | Confirm removal of the requested element |
  * ---------------------------------------- */
Confirm_Remove:
  parse arg rxdsn
  if remc = 'YES' then return 0
  if remc = null then remc = 'NO'
  rema = null
  remq = null
  call pfshow 'off'           /* make sure pfshow is off */
  if pos('(',rxdsn) = 0
  then rmpan = 'zigirmsq'
  else rmpan = 'zigiremq'
  'Addpop row(4) column(12)'
  'Display Panel('rmpan')'
  drc = rc
  if rema /= 'YES' then rrc = 4
  else rrc = 0
  'Rempop'
  if drc > 0 then do
    rrc = 4
    remc = 'NO'
  end
  call pfshow 'reset'         /* restore pfshow setting */
  return rrc

  /* ----------------------- *
  | Generalized Pop Message |
  | with msg passed         |
  * ----------------------- */
Pop:
  parse arg zs1 zs2
  add = address()             /* save addressing environment */
  Address ISPExec
  call do_popup
  Address add                 /* restore addressing environment */
  return

  /* ---------------------------------------- *
  | Common routine for normal (2 line) popup |
  * ---------------------------------------- */
Do_Popup:
  call pfshow 'off'           /* make sure pfshow is off */
  'Control Display Lock'
  'Addpop row(4) column(8)'
  'Display Panel(zigipop)'
  'Rempop'
  call pfshow 'reset'         /* restore pfshow setting */
  parse value '' with zs1 zs2
  return

  /* ---------------------------------------- *
  | Common routine for normal (2 line) popup |
  * ---------------------------------------- */
Do_PopupP:
  call pfshow 'off'           /* make sure pfshow is off */
  'Addpop row(4) column(8)'
  'Display Panel(zigipop)'
  'Rempop'
  call pfshow 'reset'         /* restore pfshow setting */
  parse value '' with zs1 zs2
  return

  /* ---------------------------------------- *
  | Confirm Commit Cancel or Proceed........ |
  * ---------------------------------------- */
Do_CommitQ:
  call pfshow 'off'           /* make sure pfshow is off */
  answer = null
  'Addpop row(4) column(16)'
  'Display Panel(zigicomq)'
  prc = rc
  'Rempop'
  call pfshow 'reset'         /* restore pfshow setting */
  return prc

  /* ---------------------------------------- *
  | Common routine for normal (3 line) popup |
  * ---------------------------------------- */
Do_Popup3:
  call pfshow 'off'           /* make sure pfshow is off */
  'Control Display Lock'
  'Addpop row(4) column(4)'
  'Display Panel(zigipop3)'
  'Rempop'
  call pfshow 'reset'         /* restore pfshow setting */
  return

  /* ---------------------------------------- *
  | Common routine for normal (4 line) popup |
  * ---------------------------------------- */
Do_Popup4:
  call pfshow 'off'           /* make sure pfshow is off */
  'Control Display Lock'
  'Addpop row(4) column(6)'
  'Display Panel(zigipop4)'
  'Rempop'
  call pfshow 'reset'         /* restore pfshow setting */
  return

  /* ---------------------------------------- *
  | Common routine for normal (4 line) popup |
  * ---------------------------------------- */
Do_Popup4p:
  call pfshow 'off'           /* make sure pfshow is off */
  'Addpop row(4) column(6)'
  'Display Panel(zigipop4)'
  'Rempop'
  call pfshow 'reset'         /* restore pfshow setting */
  return

Handle_Gitenv:
  zcmd = null
  'vget (gitenv) profile'
  save_gitenv = gitenv
  do forever
  'Display Panel(zigigit)'
  gitenv_rc = rc
  if gitenv_rc > 3 then do
     if save_gitenv = gitenv then return gitenv_rc
     zerrsm = 'Cancelled.'
     zerrlm = 'ZIGI has been cancelled. Come back when you have a valid',
      'environment file.'
     'setmsg msg (isrz002)'
     call done
     end
  'vput (gitenv) profile'
  call getenv
  x = docmd('command -v git')
  if so.0 > 0 then do
    x = so.0
    zigigitl = strip(so.x)
    if gitenv /= save_gitenv then do
      'vput (zigigitl) profile'
      zerrsm = 'Updated.'
      zerrlm = 'Git environment file updated to:' gitenv
      'setmsg msg(isrz002)'
      x = docmd('git --version')
      required_version = '2.26'
      x = so.0
      parse var so.x 'git' 'version' version'_'subversion
      gitver = version
      'vput (gitver) shared'
    end
    return 0
  end
  else do
      zs1 = "The env file ("gitenv") does not point me to"
      zs2 = "git :( Please try again and specify a valid"
      zs3 = "environment file."
      zs4 = 'Press Enter to exit and try again.'
      call do_popup4p
      parse value '' with zs1 zs2 zs3 zs4
      'verase (gitenv) profile'
      end
  end

  /* ----------------------------------------------------- *
  | Get the users current OMVS enviornment for use in the |
  | bpxwunix commands.                                    |
  * ----------------------------------------------------- */
GETENV:
  cmd = 'pwd'
  omvsenv.1 = '_BPX_SHAREAS=MUST'
  omvsenv.0 = 1
  x = bpxwunix(cmd,,so.,se.,omvsenv.)
  home    = strip(so.1)

  call init_debug

  x = debug('Starting collection of env variables')

  cmd  = docmdx('umask')
  rc = bpxwunix(cmd,,s.,se.,omvsenv.)
  last = s.0
  umask = strip(s.last)

  cmd  = docmdx('env')

  rc = bpxwunix(cmd,,env.,se.,omvsenv.)
  envc = env.0
  call add_env '_BPX_SHAREAS=MUST'
  call add_env '_BPX_SPAWN_SCRIPT=YES'
  call add_env 'EXPORT _EDC_ADD_ERRNO2=1'
  call add_env '_EDC_ZERO_RECLEN=Y'
  call add_env 'ICONV_EBCDIC_ZOS_UNIX=1'
  env.0 = envc
  drop so. se.

  /* -------------------------------------------- *
  | Fill out the env ispf variables for zigigcmd |
  * -------------------------------------------- */
  envs = null
  do i = 1 to env.0
    interpret 'env'i '=  env.'i
    envs = envs 'env'i
  end
  'vput ('envs' envs)'

  /* ----------------------- *
  | Check for getpds/putpds |
  * ----------------------- */
  x = listdsi('NOCOZ' 'FILE')
  if sysreason = 3 then do
    enhanced_cp = 0
    dovedir     = 0
    dovestat    = null
    'vput (dovedir dovestat) shared'
    x = debug('Co:Z is not available due to the NOCOZ DD allocation')
    return
  end
  x = docmd('command -v getpds')
  if x = 0
  then do
    enhanced_cp = 1
    dovetail_dir = so.1
    lp = lastpos('/',dovetail_dir,length(dovetail_dir)-1)
    dovetail_dir = left(dovetail_dir,lp)
  end
  else do
    x = zigiexit(0)
    if left(x,1) = '/' then do
      if right(x,1) /= '/' then x = x'/'
      dovetail_dir = x
      enhanced_cp = 1
      x = debug('Co:Z is available in:' dovetail_dir 'via zigiexit')
    end
    else enhanced_cp = 0
  end
  if enhanced_cp /= 0
  then do
     dovedir = enhanced_cp dovetail_dir
     dovestat    = 'Co:Z active'
     x = debug('Co:Z is available in:' dovetail_dir)
     x = bpxwunix('cd' dovetail_dir '&& df .',,dso.,dse.)
     parse value dso.2 with . zfscoz .
     zfscoz = strip(translate(zfscoz,' ','()'))
     end
  else do
       dovedir = 0
       zfscoz = null
       end
  'vput (dovedir dovestat) shared'
  x = debug('Finished collection of env variables')
  return

  /* -------------------- *
  | Add info to env stem |
  * -------------------- */
add_env:
  parse arg env_val
  envc = envc + 1
  env.envc = env_val
  return

do_gcmd:
  'Select cmd(%zigigcmd)'
  return

  /* ------------------------- *
   | Issue the OMVS command(s) |
   * ------------------------- */
docmd:
  parse arg cmd
  cmd = usssafe(cmd)
  if right(cmd,6) /= 'getpds' then do
  if pos('getpds',cmd) > 0 | pos('putpds',cmd) > 0
     then cmd = fixup_escape(cmd)
  if pos('"//',cmd) > 0
     then cmd = fixup_escape(cmd)
  end
  drop so. se.
  cmd = 'umask' umask '&&' cmd
  x = debug('Command:' cmd)
  x = bpxwunix(cmd,,so.,se.,env.)
  return x

  /* ------------------------------------------ *
   | Issue the OMVS command(s) alternate stems. |
   * ------------------------------------------ */
docmds:
  parse arg cmd
  cmd = usssafe(cmd)
  if pos('getpds',cmd) > 0 | pos('putpds',cmd) > 0 ,
     | pos('"//',cmd) > 0
     then cmd = fixup_escape(cmd)
  drop sso. sse.
  x = debug('Command:' cmd)
  x = bpxwunix(cmd,,sso.,sse.,env.)
  return x

docmdx:
  /* quircky thing, we need to export HOME as we are
  not running a login shell via bpxwunix */
  parse arg cmd
  drop o. se.
  if reset_env = null then
  if gitenv /= null
  then envfile = '.' gitenv ' >/dev/null 2>&1 &&'
  else envfile = null
  reset_env = null

  /* check for users .profile */
  address syscall 'lstat' "'"home"/.profile'" 'x.'
  if x.0 > 0 then home_profile =  ". "home"/.profile &&"
     else home_profile = null

  rx = 'export HOME='home' && . /etc/profile > /dev/null 2>&1 && ' ,
       home_profile envfile
  r = rx ' ' cmd
  return r

  /* ----------------------------------------- *
   | Remove any escape chars for getpds/putpds |
   | and for any "//'xxx'" used by cp          |
   * ----------------------------------------- */
fixup_escape:
  parse arg fxescape
  rtn_data = null
  do forever
    parse value fxescape with fxescape'&&' more
    if strip(fxescape) = null then return rtn_data
    fxrtn = 0
    if pos('getpds',fxescape) > 0 then fxrtn = 1
    if pos('putpds',fxescape) > 0 then fxrtn = 2
    if fxrtn = 0 then
    if pos("//'",fxescape) > 0
       then fxrtn = 3
       else fxrtn = 0
    if fxrtn = 0 then do
      if rtn_data = null
        then rtn_data = fxescape
        else rtn_data = rtn_data '&&' fxescape
      if strip(more) = null then return rtn_data
      fxescape = more
      iterate
       end
    parse value fxescape with lc'//'fixdsn rc
    if fxrtn < 3 then
    do forever
      if pos('\$',fixdsn) = 0 then leave
      parse value fixdsn with lfc'\$'rfc
      fixdsn = lfc'$'rfc
    end
    do forever
      if pos('\#',fixdsn) = 0 then leave
      parse value fixdsn with lfc'\#'rfc
      fixdsn = lfc'#'rfc
    end
    fxescape = lc'//'fixdsn rc
    if rtn_data = null
      then rtn_data = fxescape
      else rtn_data = rtn_data '&&' fxescape
    if strip(more) = null then return rtn_data
    fxescape = more
  end
  return rtn_data

view_debug:
  if zigidebg = 1 then do
    filev = debugfil
    'view  file(filev)'
  end
  else do
    zerrsm = 'Invalid.'
    zerrlm = 'VIEWD is not supported when debug is not enabled. To' ,
      'enable debug allocate a ZIGIDEBG DD to Dummy and' ,
      'restart ZIGI.'
    'setmsg msg(isrz003)'
  end
  return

debug:
  if zigidebg  = 1 then do
    parse arg msg
    msg = Date() Time()' : 'msg
    c = 'echo "'msg'" >>' debugfil
    x = bpxwunix(usssafe(c),,dso.,dse.,omvsenv.)
    zigidebg_use = 1
  end
  return 0

  /* --------------------------------- *
  | Add a message to the combine stem |
  * --------------------------------- */
Add_Combine:
  parse arg msg
  combine_count = combine.0
  combine_count = combine_count + 1
  combine.combine_count = '   '
  combine_count = combine_count + 1
  combine.combine_count = msg
  combine_count = combine_count + 1
  combine.combine_count = '   '
  combine.0 = combine_count
  return

  /* --------------------------------------------------------- *
  | Combine the stdout and stderr messages into combine. stem |
  | for viewing.                                              |
  * --------------------------------------------------------- */
Combine_msgs:
  combine_count = combine.0
  do combi = 1 to so.0
    combine_count = combine_count + 1
    combine.combine_count = strip(so.combi,'T')
    if combine.combine_count = null then combine.combine_count = ' '
  end
  do combi = 1 to se.0
    combine_count = combine_count + 1
    combine.combine_count = strip(se.combi,'T')
    if combine.combine_count = null then combine.combine_count = ' '
  end
  combine.0 = combine_count
  return

  /* -------------------------------------------- *
  | Get the date/time for the provided omvs file |
  * -------------------------------------------- */
get_fd_date:
  parse arg file_var
  x = docmd('ls -laT' file_var)
  fdate = subword(so.1,9,3)
  ftag  = subword(so.i,2,1)
  return fdate

Test_Repo_Table_State:
  /* --------------------------------------------- *
  | Test to see if the ZIGIREPO table is for V2R1 |
  | and if not upgrade it.                        |
  * --------------------------------------------- */
  'TBQuery zigirepo Names(names) Rownum(rows)'
  if rows = 0 then return
  if pos('REPONAME',names) = 0 then do
    zs1 = 'Upgrading the ZIGI Repository ISPF Table'
    zs2 = 'This should not take long.'
    call do_popup
    'tbtop zigirepo'
    branch = null
    remote1 = null
    reponame = null
    sortdate = null
    zigicat = null
    tc = 0
    do forever
      'tbskip zigirepo'
      if rc > 0 then leave
      'tbget zigirepo'
      tc = tc + 1
      key.tc = zigikey'\'localrep'\'pdshlq'\'qualignr'\'zigirep ,
        '\'defcpush '\'defruid'\'zigidate '\' sortdate '\' zigicat ,
        '\' branch '\' remote1 '\' reponame
    end
    key.0 = tc
    'TBErase zigiorep Library('isptabl')'
    'tbclose zigirepo name(zigiorep) library('isptabl')'
    call create_zigirepo
    do i = 1 to key.0
      parse value key.i with zigikey'\'localrep'\'pdshlq'\'qualignr ,
        '\'zigirep ,
        '\'defcpush'\'defruid'\'zigidate'\'sortdate'\'zigicat ,
        '\'branch'\'remote1'\'reponame
      if right(localrep,1) = '/' then localrep = strip(localrep,'T','/')
      if reponame = null then reponame = zigirep
      localdir = strip(localdir)
      zigirep  = strip(zigirep)
      zigicat  = strip(zigicat)
      sortdate  = strip(sortdate)
      zigikey = localrep'/'zigirep
      if cat = 0 then
      Select
        when zigidate /= null then do
          zd = subword(zigidate,1,3)
          zt = subword(zigidate,4)
          zigidate = zd
          if strip(zt) = null then zt = 0
          sortdate = date('b',zd,'n') zt
        end
        When words(zigidate) > 3 then do
          zigidate = strip(subword(zigidate,1,3))
          zt = subword(zigidate,4)
          if pos(':',zt) > 0 then zt = left(zt,2)''substr(zt,4,2)
          sortdate = date('b',strip(zigidate),'n') zt
        end
        When words(zigidate) = 3 then do
          sortdate = date('b',strip(zigidate),'n') 0
        end
        Otherwise call set_sortdate
      end
      'tbadd zigirepo order'
      if cat = 0 then do
        sortdate = null
        zigicat = null
      end
    end
    zerrsm = null
    zerrlm = 'The ZIGI Repository Table has been upgraded' ,
      'with new variables' ,
      'and the prior version of the table has been saved in DD' ,
      isptabl 'as ZIGIREPO.'
    'setmsg msg(isrz003)'
  end
  Return

parseGitURI:
  /* --------------------------------------------- *
  | Parse the various forms of git repo uri's into|
  | <user> <site> <port> <repo>                   |
  * --------------------------------------------- */
  parse arg uri
  /* port and user defaults */
  port = 22
  /* normal style ssh:// processing */
  if translate(substr(uri,1,6)) = 'SSH://' then do
    uri = substr(uri,7)
    if pos('@',uri) > 0 & pos(':',uri) > 0 then
    /* user and port specified */
    parse var uri user '@' site ':' port '/' owner '/' repo
    else
    if pos('@',uri) > 0 & pos(':',uri) = 0 then
    /* user but no port specified */
    parse var uri user '@' site '/' owner '/' repo
    else
    if pos('@',uri) = 0 & pos(':',uri) > 0 then
    /* no user, but port specified */
    parse var uri site ':' port '/' owner '/' repo
    else
    /* no user and port specified */
    parse var uri site '/' owner '/' repo
  end
  /* alternative scp-like processing */
  else
  /* user specified */
  if pos('@',uri) > 0 then
  parse var uri user '@' site ':' owner '/' repo
  else
  /* no user specified */
  parse var uri site ':' owner '/' repo
  return owner site port repo

  /* -------------------------------------------------- *
  | Routine to update git with the user name and email |
  * -------------------------------------------------- */
Update_Config:
  /* dunno if we still need these in the profile?? */
  'VPut (zigiuid zigimail zigissh) Profile'
  /* maybe we could use the ispprof for some lazy caching */
  /* now that we've had the user see the settings.
  set the git config if they have changed...
  */
  if old_zigiuid /= zigiuid then do
    x = docmd('git config --global user.name "'zigiuid'"')
    if x > 0 then do
      zs1 = "something went wrong with git config user.name"
      x = so.0
      zs2 = so.x
      zs3 = se.1
      zs4 = null
      call do_popup4
    end
    x = docmd('git config --global user.email "'zigimail'"')
    if x > 0 then do
      zs1 = "something went wrong with git config user.email"
      x = so.0
      zs2 = so.x
      zs3 = se.1
      zs4 = null
      call do_popup4
    end
    x = docmd(' git config --global init.defaultBranch main')
    if x > 0 then do
      zs1 = "something went wrong with git config defaultBranch"
      x = so.0
      zs2 = so.x
      zs3 = se.1
      zs4 = null
      call do_popup4
    end
    /* Let's adopt the new style. Only push current branch */
    x = docmd('git config --global push.default simple')
  end
  'VPut (zigiuid zigimail zigissh) Profile'
  zerrsm = 'Updated.'
  zerrlm = 'ZIGI Settings updated successfully.'
  'Setmsg msg(isrz003)'
  return

MGEN:
  /* ---------------------------------------------------------- |
  | Name:      MGEN                                            |
  |                                                            |
  | Function:  Return the current system  MAXGENS_LIMIT        |
  |            which is the system max generations value       |
  |            for PDSE Version 2 libraries                    |
  |                                                            |
  | Syntax:    mgen=(mgen)                                     |
  |                                                            |
  | ---------------------------------------------------------- */
  parse source source
  Numeric Digits 10
  CVT      = C2D(Storage(10,4))
  CVTDFA   = C2D(Storage(D2X(CVT + 1216),4))   /* cvt + 4c0 */
  DFAMGEN  = C2D(Storage(D2X(cvtdfa + 76),4))  /* dfa + 4c */
  return dfamgen

get_binfiles:
  /* ---------------------------------------------------------\
  | Name:      get_binfiles                                    |
  |                                                            |
  | Function:  Fills the global binfiles. stem with all        |
  |            current repo files that are added as binary.    |
  \---------------------------------------------------------- */
  cmd = 'cd 'localrep'/'zigirep' &&' ,
    'cat -W filecodeset=UTF-8,pgmcodeset='encoding' .gitattributes' ,
    '| grep binary' ,
    '| cut -d" " -f1'
  x = docmd(cmd)
  binfiles. = null
  bc = 0
  do b = 1 to so.0
    if left(strip(so.b),1) = '#'  then iterate
    if left(strip(so.b),1) = '.'  then iterate
    if left(strip(so.b),2) = '*.' then iterate
    bc = bc + 1
    binfiles.bc = so.b
  end
  binfiles.0 = bc
  return 0

is_binfile:
  /* ---------------------------------------------------------\
  | Name:      is_binfile                                      |
  |                                                            |
  | Function:  Checks the global binfiles. stem for the        |
  |            provided dataset or dataset/member              |
  \---------------------------------------------------------- */
  parse arg checkForBinFile
  if datatype(binfiles.0) /= 'NUM' then return 0
  do bi = 1 to binfiles.0
    if binfiles.bi = checkForBinFile then return 1
    if right(binfiles.bi,1) = '*' then do
      parse value checkForBinFile with test'/'.
      if left(binfiles.bi,length(binfiles.bi)-2) = test
      then return 1
    end
  end
  return 0

  /* ----------------------------------------------------- *
   | If the encoding ISPF variable is not set then get the |
   | repository default encoding from the .gitattributes   |
   * ----------------------------------------------------- */
Get_Default_Codepage:
  cmd = 'cd' localrep'/'zigirep '&&' ,
    'cat -W filecodeset=UTF-8,pgmcodeset='encoding' .gitattributes' ,
    "| grep 'zos-working-tree-encoding'"
  x = bpxwunix(cmd,,s.,e.)
  encoding = null
  do i = 1 to s.0
    if pos('zos-working-tree-encoding',s.i) = 0 then iterate
    parse value s.i with .'zos-working-tree-encoding='encoding .
    parse value encoding with .'-'codep .
    codep = strip(translate(codep,' ','0D'x))
    encoding = strip(translate(encoding,' ','0D'x))
    return
  end
  if encoding = null then
  encoding = 'IBM-1047'
  codep = 1047
  return

  /* ---------------------------------------- *
  | Check if a PDS has mixed binary and text |
  * ---------------------------------------- */
Check_Mixed_BinText:
  parse arg checkForBinFile
  cmbtRC = 0
  if datatype(binfiles.0) /= 'NUM' then return 0
  do bi = 1 to binfiles.0
    parse value binfiles.bi with cmbtfile'/'cmbtmbr
    parse value checkForBinFile with checkFile'/'checkmbr
    if cmbtfile = checkFile then
    if cmbtmbr = '*' then cmbtRC = 0
    else return 1
    if binfiles.bi = checkForBinFile then return 1
  end
  return cmbtRC

check_clean:
  /* ---------------------------------------------------------\
  | Name:      check_clean                                     |
  |                                                            |
  | Function:  Checks if working dir is clean                  |
  |            returns YES or NO                               |
  \---------------------------------------------------------- */
  cmd = 'cd 'localrep'/'zigirep' && git status'
  x = docmd(cmd)
  clast = so.0
  if pos('working tree clean',so.clast) > 0 then return 'YES'
  else return "NO"

  /* -------------------------------------------------------- *
  | This is where the most recent pull will be reversed.     |
  |                                                          |
  | The reverse will use the last hash saved in: rev_head    |
  * -------------------------------------------------------- */
Reverse_Pull:
  cmd = 'cd' localrep'/'zigirep
  cmd = cmd '&& git reset --hard' rev_head
  cmd = cmd '&& git status'
  x = docmd(cmd)
  call view_std 'B'
  return

flowselect:
  /* ----------------------------- *
  | Show the flows and select one |
  * ----------------------------- */
  if rtbf_open = 1 then 'tbend' rtbf
  'TBCreate' rtbf 'keys(bname) Names(brstatus) Replace NoWrite'
  rtbf_open = 1
  localdir = localrep'/'zigirep
  if zigi_offline = 0 then do
    cmd = ' && git remote prune origin > /dev/null 2>&1 && git branch -a'
    x = docmd('cd 'localdir cmd)
  end
  else parse value '0 0' with so.0 se.0
  if so.0 + se.0 = 0 then do
    cmd = '&& git branch -a'
    x = docmd('cd 'localdir cmd)
  end
  bl. = null
  bl.0 = 0
  do flowi = 1 to so.0
    b1 = strip(so.flowi,'B')
    if pos('/',b1) > 0 then do
      /* this is a remote branch we (maybe) have never checked out */
      seen_this_branch = 0
      parse var b1 remotes'/'origin'/'bname zooi
      bname = strip(bname)
      do ii = 1 to bl.0
        if bl.ii = bname then seen_this_branch = 1
      end
      if seen_this_branch = 1 then do
        sbname = bname
        'tbtop' rtbf
        do forever
          'tbskip' rtbf
          if rc > 0 then leave
          if sbname = bname then do
            brstatus = 'Local/Remote'
            'tbmod' rtbf
            leave
          end
        end
      end
      /* but only add it to table if we haven't yet */
      if seen_this_branch = 0 then do
        if bname <> branch & bname <> "HEAD" then do
          ni = bl.0 + 1
          bl.ni = bname
          bl.0 = ni
          brstatus = 'Remote'
          /* and only if it's a zigiflow branch */
          if substr(bname,1,9) = 'zigiflow-' then do
            'tbadd' rtbf
          end
        end
      end
    end
    else do
      /* this is already a local branch */
      if pos('*',b1) = 0 then do
        /* Add it to the table if it's not the current (*) branch */
        bname = strip(so.flowi)
        ni = bl.0 + 1
        bl.ni = b1
        bl.0 = ni
        brstatus = 'Local'
        if substr(bname,1,9) = 'zigiflow-' then do
          'tbadd' rtbf
        end
      end
    end
  end
  'tbsort' rtbf 'fields(bname,c,a)'
  'tbtop' rtbf
  save_btop = 0
  do forever
    zcmd = null
    cc_rc = 0
    newb = null
    zsel = null
    if save_btop > 0 then do
      'tbtop' rtbf
      'tbskip' rtbf 'number('save_btop')'
    end
    'tbdispl' rtbf 'panel(zigifsel)'
    if rc > 4 then leave
    save_btop = ztdtop
    /* ----------------------------- *
    | Workin selected flow          |
    * ----------------------------- */
    if zsel = "S" then do
      x = docmd('cd 'localdir' && git checkout 'bname)
      call Replace localrep zigirep pdshlq qualignr
      call update_repo_metadata
      branch = bname
      leave
    end
  end
  'tbend' rtbf
  rtbf_open = 0
  ztdsels = 0
  zsel = null
  return

  /* ------------------------------------------------------------- *
  | Convert a non-zig repository to enable ZIGI management.       |
  |  - for this to work the repository must be manually setup     |
  |    by the user after the clone thus:                          |
  |    - All sequential files in the repo root that are z/OS      |
  |      datasets must be renamed to upper case and using z/OS    |
  |      naming conventions.                                      |
  |   - all subdirectories that will be the OMVS copy of a PDS    |
  |     must also be upper case with z/OS naming                  |
  |   - all PDS members must be in their respective OMVS          |
  |     subdirectory without a suffix and follow PDS member       |
  |     name conventions and be upper case                        |
  |                                                               |
  | This routine will call ZIGICNVT and pass the OMVS directory   |
  | for the repository to be converted.                           |
  |                                                               |
  | After conversion the ZIGICKOT routine will be called to copy  |
  | the OMVS files into their respective z/OS datasts (which will |
  | be dynamically allocated)                                     |
  * ------------------------------------------------------------- */
Convert_Repo:
  convdir = localrep'/'zigirep
  'vput (convdir)'
  'Select cmd(%zigicnvt)'
  qualignr = words(translate(pdshlq,' ','.'))
  call Replace localrep zigirep pdshlq qualignr
  return

Do_Tag_Extract:
  x = check_clean()
  if x = 'NO' then do
    zerrsm = null
    zerrlm = left('The current repository has uncommited changes.',74) ,
      'Resolve and try again.'
    'setmsg msg(isrz003)'
    return
  end
  do forever
    call pfshow 'off'           /* make sure pfshow is off */
    'Addpop row(3) column(4)'
    'Display Panel(zigitagx)'
    drc = rc
    'Rempop'
    call pfshow 'reset'         /* restore pfshow setting */
    if drc > 0 then do
      zerrsm = 'Canceled.'
      zerrlm = 'Extract canceled.'
      'setmsg msg(isrz003)'
      return
    end
    if tagxpath = '?' then tagxpath = zigiosel()
    call pfshow 'off'           /* make sure pfshow is off */
    'Addpop row(3) column(4)'
    'Display Panel(zigiextq)'
    drc = rc
    'Rempop'
    call pfshow 'reset'         /* restore pfshow setting */
    if sans = 'Y' then leave
  end
  if tagxpath /= null then
  if validate_path(tagxpath) = 8 then do
    zerrsm = 'Error.'
    zerrlm = tagxpath e.1
    'Setmsg msg(isrz003)'
    return
  end
  zs1 = 'Preparing the extract. This could take a minute'
  zs2 = '(or two) so please be patient.'
  call do_popup
  exhlq = tagxhlq
  expath = tagxpath
  if expath = null then expath = '.'
  'Select Cmd(%zigiextr' localrep'/'zigirep exhlq expath tags')'
  return

  /* --------------------------------------------------------- *
  | This routine checks for deletes that are not included     |
  | in the git messages. These would be PDS members that are  |
  | deleted and thus no longer in the OMVS directory and need |
  | to be removed from the z/OS PDS.                          |
  * --------------------------------------------------------- */
Check_For_More_Deletes:
  cmd = 'cd' localrep'/'zigirep '&& ls -lR'
  x = docmd(cmd)
  ckd_dir = null
  do ck_i = 1 to so.0
    if left(so.ck_i,2) = './' then do
      parse value so.ck_i with './'ckd_dir':'
      call Get_PDS_Members
    end
    if ckd_dir = null then iterate
    if left(so.ck_i,1) /= '-' then iterate
    m = word(so.ck_i,9)
    if pos('.',m) > 0 then do
      parse value m with m'.'.
      m = translate(m)
    end
  end
  return

Get_PDS_Members:
  members = null
  call outtrap 'pdsmems.'
  address tso "listd '"delhlq"."dir"' M"
  call outtrap 'off'
  do gm = 7 to pdsmems.0
    members = members word(pdsmems.gm,1)
  end
  drop pdsmems.
  return

  /* -------------------------------------------------------- *
  | Get the file extension information for the datasets from |
  | .zigi/dsn.                                               |
  * -------------------------------------------------------- */
get_dsn_info:
  zdsn. = null
  dsninfo. = null
  readfile = "'"localrep"/"zigirep"/.zigi/dsn'"
  address syscall 'readfile' readfile 's.'
  if x > 0 then return
  do di = 1 to s.0
    if left(s.di,1) = '#' then iterate
    zd = word(s.di,1)
    dsninfo.zd = zd
    zdsn.zd = word(s.di,6)
  end
  drop s. e.
  return

  /* ------------------------------------- *
  * Name:     Lower                       *
  *                                       *
  * Function: Lowercase the provided data *
  *                                       *
  * Syntax:   x=lower(input)              *
  * ------------------------------------- */
Lower:
  parse arg Lower_Input
  Lower_Out = translate(Lower_Input,"abcdefghijklmnopqrstuvwxyz",,
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
  return Lower_Out

  /* -------------------------------------------- *
  | View the commit log for this historical item |
  * -------------------------------------------- */
DoHist_ComView:
  cmd = 'cd' localrep'/'zigirep
  cmd = cmd '&& git log' hcommit '-n 1 --cc'
  x = docmd(cmd)
  'control display save'
  call view_std 'X' 'V'
  'control display restore'
  zsel = null
  return

  /* ----------------------------------------------------------- *
  | Recover the specific historical level of the element. This  |
  | does use the dohist_file_extract routine to get the element |
  | and then prompts for a target dataset.                      |
  | If the element is a PDS member then it must be recovered to |
  | a PDS member.                                               |
  * ----------------------------------------------------------- */
DoHist_Recover:
  if readonly = 1 then do
    zerrsm = 'Invalid.'
    zerrlm = 'History Recover is not supported for ReadOnly Repositories.'
    'setmsg msg(isrz003)'
    return
  end
  if dsnvalid(remove_dsn_hlq(fulldsn)) = 'NO' then do
    zerrsm = 'Error.'
    zerrlm = 'The recovery of a non-z/OS dataset is not supported' ,
      'at this time. You can use S to view the historical' ,
      'data and then copy it into the clipboard to paste' ,
      'into a OMVS file to recover it.'
    'setmsg msg(isrz003)'
    return
  end
  if left(fulldsn,1) /= "'" then
  relement = fulldsn
  if left(fulldsn,1) = "'" then do
    if pos('/',element) = 0
    then relement = fulldsn
    else do
      parse value element with .'/'rcmem
      if zdsn.dsn /= null then
      parse value rcmem with rcmem'.'.
      relement = left(fulldsn,length(fulldsn)-1) ,
        || "("rcmem")'"
    end
  end
  rdsn = null
  ralc = 'N'
  rans = null
  rover = null
  call pfshow 'off'           /* make sure pfshow is off */
  'Addpop row(4) column(8)'
  'Display Panel(zigiresq)'
  drc = rc
  'Rempop'
  call pfshow 'reset'         /* restore pfshow setting */
  if drc > 0 then return
  if rans = 'N' then return
  rcdd = 'RC'random(99999)

  address tso
  if sysdsn(rdsn) = 'DATASET NOT FOUND' then ralloc = 'Y'
  else ralloc = 'N'
  if ralloc = 'N'
  then 'Alloc f('rcdd') shr reuse da('rdsn')'
  else 'Alloc f('rcdd') new like('relement') da('rdsn')'
  'Free f('rcdd')'
  save_rdsn = rdsn

  call dohist_file_extract

  if is_binfile(rdsn) = 1 then binopt = '-B'
  else binopt = null
  x = check_llib(rdsn)
  if x = 0 then binopt = binopt '-X -I'

  cmd = 'cd' localrep'/'zigirep ,
    '&& cp -UA' binopt file ,
    '"//'rdsn'"'
  x = do_copy(cmd)
  if x > 0 then call view_std 'B'

  x = docmd('rm' file)

  address ispexec

  teste = strip(relement,'B',"'")
  testr = strip(rdsn,'B',"'")
  parse value teste with teste'('.
  parse value testr with testr'('.

  if is_binfile(rdsn) = 1 then binopt = '-B'
  else binopt = null
  x = check_llib(rdsn)
  if x = 0 then binopt = binopt '-X -I'
  if pos('-X',binopt) = 0 then
  if pos('(',rdsn) > 0 then do
    parse value rdsn with rdsn"("mem")"
    if left(rdsn,1) = "'" then rdsn = rdsn"'"
    "LMINIT DATAID(zstats) DATASET("rdsn")"
    "LMOPEN DATAID("zstats") OPTION(INPUT)"
    'LMMSTATS DATAID('zstats') Member('mem') user('zluser')'
    "LMClose Dataid("zstats")"
    "LMFree  Dataid("zstats")"
  end
  if teste = testr then do
    m = strip(mem)
    if sysvar('syspref') = null
    then pref = sysvar('sysuid')
    else pref = sysvar('syspref')
    if left(rdsn,1) /= "'"
    then rdsne = pref'.'rdsn
    else rdsne = rdsn
    e = strip(rdsne,'B',"'")
    r = dsn

    if zdsn.dsn /= null
    then rm = lower(strip(mem)'.'zdsn.dsn)
    else rm = m
    rm = rm

    copycmd = "//'"e"("m")'"
    copycmd = '"'copycmd'"'
    copycmd = "cp "binopt" -U -v" copycmd" "localrep"/"zigirep
    copycmd = copycmd || "/"r"/"rm
    x = do_copy(copycmd)
    if x > 0 then call view_std 'B'
    zerrsm = 'Completed.'
    zerrlm = relement 'successfully recovered into' save_rdsn ,
      left(' ',76) ,
      'the recovered element will be in a Modified state and will' ,
      'need to be added to the staging index and committed if' ,
      'desired.'
    'setmsg msg(isrz003)'
    if fulldsn = rdsn then update_flag = 1
  end
  zerrsm = 'Success.'
  zerrlm = element 'successfully recovered.'
  'setmsg msg(isrz003)'
  if sysdsorg /= 'PS'
  then "View Dataset('"strip(rdsn,'B',"'")"("mem")')"
  else "View Dataset('"strip(rdsn,'B',"'")"')"
  if rc > 0 then 'setmsg msg(isrz003)'
  return

  /* ---------------------------------------------------------- *
  | View the Source for the element at the historical (commit) |
  | point in time.                                             |
  * ---------------------------------------------------------- */
DoHist_ViewSource:
  hrc = dohist_file_extract()
  if hrc > 0 then do
    zerrsm = 'No History.'
    zerrlm = 'No History found for this commit level.'
    'setmsg msg(isrz003)'
    return
  end
  vtitle = element '\' hdate '\' hsubject '\' fulldsn
  gitcmde = null
  'vput (vtitle gitcmde localrep zigirep)'
  'View File(file) macro(zigivmac)'
  x = docmd('rm' file)
  return

  /* -------------------------------------------- *
   | Compare active element to historical element |
   * -------------------------------------------- */
DoHist_Compare:
  hrc = dohist_file_extract()
  compare_update = 0
  if hrc > 0 then do
    zerrsm = 'No History.'
    zerrlm = 'No History found for this commit level.'
    'setmsg msg(isrz003)'
    return
  end
  vtitle = 'History date:' hdate '\Subject:' hsubject
  zfile = file
  'control display save'
  if left(fulldsn,1) = "'" then do
     if pos('/',element) > 0 then do
        parse value element with .'/'workm
        if pos('.',workm) > 0 then
           parse value workm with workm'.'.
        workdsn = "'"strip(translate(fulldsn,"","'"))'('workm')'"'"
        end
     else workdsn = fulldsn
     'vput (vtitle localrep zigirep zfile workdsn)'
     'edit dataset('workdsn') macro(zigizmac)'
     if rc = 0 then do
        if sysdsorg = 'PS' then do
           ztdsels = 2
           call copy_ps
           ztdsels = 0
           dsnstat = '[ M] Modified'
           'tbput' rtbl
           end
        else do
             call copy_pds_mem
             end
        end
     end
  else do
      workdsn = localrep'/'zigirep'/'fulldsn
      'vput (vtitle localrep zigirep zfile workdsn)'
      'edit File(workdsn) macro(zigizmac)'
      if rc = 0 then do
         dsnstat = '[ M] Modified'
         'tbput' rtbl
         end
      end
  'control display restore'
  x = docmd('rm' file)
  return

  /* ------------------------------------------------------ *
  | Extract the historic level of the element based on the |
  | commit hash provided.                                  |
  |                                                        |
  | 1. use git show on hash level for element              |
  | 2. copy (using cat) to /tmp/file-name                  |
  * ------------------------------------------------------ */
DoHist_File_Extract:
  if pos('/',element) > 0
  then do
    parse value element with file'/'work
    file = translate(file,' ','.')
    file = home'/tmp/'work
  end
  else file = home'/tmp/'element
  call check_tmp
  cmd = 'cd' localrep'/'zigirep ,
     '&& unset _TAG_REDIR_OUT' ,
     '&& git show' hcommit':'element ,
     '>' file ,
     '&& chtag -tc 'encoding file
  dhrc = docmd(cmd)
  if dhrc > 0 then call view_std 'B'
  return dhrc

  /* ------------------------------------------------------------ *
  | Checks for the home/tmp directory by attempting to create it |
  | and if it exists great, if not then it does now.             |
  * ------------------------------------------------------------ */
Check_TMP:
  x = docmd('mkdir' home'/tmp')
  return

  /* ------------------------------- *
  | Validate the provided OMVS Path |
  * ------------------------------- */
Validate_path:
  parse arg valid_path
  if valid_path = null then return 8
  valid_path = translate(valid_path,' ','/')
  valid_path = subword(valid_path,1,words(valid_path)-1)
  valid_path = '/'translate(valid_path,'/',' ')'/'
  x = docmd('ls -la' valid_path)
  if x > 0 then return 8
  else return 0

  /* -------------------------------------------------- *
  | Check for load library                             |
  |  - argument passed is fully qualified dataset name |
  |  - return codes                                    |
  |    0 = load library                                |
  |    1 = not a load library                          |
  * -------------------------------------------------- */
Check_LLib:
  arg check_llib_dsn
  x = listdsi(check_llib_dsn)
  if sysdsorg /= 'PO' then return 1
  if sysrecfm = 'U'
  then do
    x = check_load_library(dsn)
    return rc
  end
  else return 1

Check_Load_Library:
  arg check_loadlib_dsn
  x = listdsi("'"check_loadlib_dsn"'")
  if sysrecfm /= 'U' then return 0
  x = check_lmod_ptf()
  if x = 0 then return 0
  zerrsm = 'Not Supported.'
  zerrlm = 'Load Library support is not available. To enable it install' ,
    'PTF UJ01358 for z/OS 2.2 or UJ01356 for z/OS 2.3.'
  'setmsg msg(isrz003)'
  return 4

  /* -------------------------------------------------- *
  | Validate that the PTF with the -I support has been |
  | installed and return 0 if good and >0 if not       |
  * -------------------------------------------------- */
Check_LMOD_PTF:
  cmd = 'cp -X -I "//'
  cmd = cmd"'SYS1.LINKLIB(IEFBR14)'"
  cmd = cmd '"  test'
  x = do_copy(cmd)
  return x

  /* --------------------------- *
  | Add statistics to a member. |
  * --------------------------- */
Add_Stats:
  arg mstats
  if pos(left(word(mstats,1),1),'=<>') > 0 then return
  zstats = 'ZS'time('s')
  "LMINIT DATAID(zstats) DATASET("fulldsn")"
  "LMOPEN DATAID("zstats") OPTION(INPUT)"
  parse value mstats with upmbr ZLCDATE ZLMDATE ZLVERS ZLMOD ,
    ZLMTIME ZLCNORC ZLINORC ZLMNORC ZLUSER ZLCNORCE ,
    ZLINORCE ZLMNORCE .
  if zlcdate = null then ,
    'LMMSTATS DATAID('zstats') Member('upmbr') user('sysvar(sysuid)')'
  else ,
    'LMMSTATS DATAID('zstats') MEMBER('upmbr') VERSION('zlvers')' ,
    'MODLEVEL('zlmod') CREATED('zlcdate') MODDATE('zlmdate')' ,
    'MODTIME('zlmtime') INITSIZE('zlinorc')' ,
    'MODRECS('zlmnorc') USER('zluser')'
  "LMClose Dataid("zstats")"
  "LMFree  Dataid("zstats")"
  return

  /* ------------------------------------------------------------- *
  | Change to the new branch                                      |
  | Then determine what changed from the previous branch to       |
  | this branch.                                                  |
  | Based on the delta setup the zigickot input to make the       |
  | changes for only those affected elements (and handle deletes) |
  * ------------------------------------------------------------- */
Check_Branch_Delta:
  cmd = 'cd 'localdir' && git checkout 'bname
  cmd = cmd '&& git diff --name-status' branch'..'bname
  x = docmd(cmd)
  if x > 0 then call view_std 'B'
  Report_Header = 'ZIGI Branch Change Report'
  delta_from = branch
  delta_to   = bname
  call  Check_Delta
  return

Add_Report:
  parse arg br_text
  rcr = rcr + 1
  report.rcr = br_text
  report.0 = rcr
  return

Check_Delta:
  x05 = '05'x
  parse value '' with brdsns brmems. brdeletes pullmems. report.
  rcr = 0
  call add_report report_header copies(' ',10) ,
    date('n') time('c')
  call add_report 'From branch:' delta_from
  call add_report 'To branch:  ' delta_to
  call add_report ' '
  call add_report 'Elements added or changed from branch:' delta_from
  call add_report ' '
  /* Get the HLQ for use */
  if qualignr = 0
  then ckothlq = null
  else do
    ckothlq = translate(pdshlq,' ','.')
    if qualignr /= '*' then
    ckothlq = subword(ckothlq,1,qualignr)
    ckothlq = translate(ckothlq,'.',' ')'.'
  end
  /* ------------------------------- *
  | Process the differences report: |
  | M = modified                    |
  | A = added                       |
  | D = deleted                     |
  | R = renamed                     |
  |     - ignore the xxx in Rxxx    |
  * ------------------------------- */
  do bri = 1 to so.0
    if pos(x05,so.bri) = 0 then iterate
    data = translate(so.bri,' ',x05)
    parse value data with change_flag change_file
    if left(change_file,1) = '.' then iterate
    change_flag = left(change_flag,1)
    call brDelta
  end
  do zz = 1 to words(brdsns)
    zd = word(brdsns,zz)
    zw = words(brmems.zd)
    ldsn = "'"ckothlq""zd"'"
    x = listdsi(ldsn "dir")
    if sysdsorg /= 'PO' then iterate
    interpret 'zv'zz '= (brmems.zd)'
    'vput zv'zz
  end
  ckotdir = localrep'/'zigirep
  pulldsns = brdsns
  if pulldsns /= null then do
    ckotqual = qualignr
    'vput (ckotdir ckothlq pulldsns ckotqual)'
    'Select cmd(%zigickot)'
  end
  'vget (badckot) shared'
  if badckot = 1 then do
    zerrsm = 'Failed.'
    zerrlm = 'z/OS Dataset Update failed due to one, or more, of the' ,
      'target datasets are allocated. Free those allocations and' ,
      'try again.'
    'Setmsg Msg(isrz003)'
    'verase (badckot) shared'
    return
  end
  if words(brdeletes) > 0 then do
    call add_report ' '
    call add_report 'Elements not in the To branch:' delta_to
    call add_report '(They may not exist, have been deleted, or renamed)'
    call add_report ' '
  end
  do brdel = 1 to words(brdeletes)
    deldsn = "'"ckothlq""word(brdeletes,brdel)"'"
    call add_report translate(deldsn)
    Address TSO
    call outtrap 'brd.'
    'Delete' deldsn
    call outtrap 'off'
    Address ISPExec
  end
  drop so. se.
  if pulldsns /= null then do
    do copyr = 1 to report.0
      so.copyr = report.copyr
    end
    so.0 = report.0
    call view_std
  end
  Return

  /* ---------------------------------------------- *
  | Set Repository as Read Only by creating a file |
  | .zigi/readonly                                 |
  * ---------------------------------------------- */
Set_Read_Only:
  x = docmd('touch' localrep'/'zigirep'/.zigi/readonly')
  cmd = 'cd' localrep'/'zigirep ,
    "&& echo '.zigi/readonly' > .gitignore" ,
    '&& git add .gitignore'
  x = docmd(cmd)
  return 0

Check_Read_Only:
  x = docmd('ls -la' localrep'/'zigirep'/.zigi/readonly')
  if so.0 > 0 then return 1
  else return 0

  /* ----------------------------------------------- *
  | Check if a OMVS file exists (rc = 1 if it does) |
  * ----------------------------------------------- */
File_Exists:
  parse arg file_check
  ckotdir = localrep'/'zigirep
  x = docmd('ls -la' localrep'/'zigirep'/'file_check)
  if se.0 = 0 then return 1
  return 0

  /* -------------------------------------------------------------- *
  | Process the branch delta from the git diff command to identify |
  | the files changed.                                             |
  * -------------------------------------------------------------- */
BrDelta:
  Select
    When change_flag = 'M' then BrType = 'A'
    When change_flag = 'A' then BrType = 'A'
    When change_flag = 'D' then do
      if pos('/',change_file) > 0
      then do
        parse value change_file with change_file'/'brdmem
        if pos('.',brdmem) > 0 then
        parse value brdmem with brdmem'.'.
        change_file = change_file"("brdmem")"
      end
      brdeletes = brdeletes change_file
      BrType = 'D'
    end
    When change_flag = 'R' then do
      parse value change_file with brdelfile change_file
      if pos('/',brdelFile) > 0
      then do
        parse value brdelFile with brdelFile'/'brdmem
        if pos('.',brdmem) > 0 then
        parse value brdmem with brdmem'.'.
        brdelFile = brdelFile"("brdmem")"
      end
      brdeletes = brdeletes brdelFile
      BrType = 'A'
    end
    Otherwise nop
  end
  if BrType = 'D' then return
  if pos('/',change_file) = 0 then do
    if dsnvalid(change_file) = 'NO' then return
    brdsns = brdsns change_file
    call add_report "'"ckothlq""change_file"'"
  end
  else do
    parse value change_file with change_file'/'BrMem
    if wordpos(change_file,brdsns) = 0 then
    brdsns = brdsns change_file
    if pos('.',brmem) > 0 then
    parse value brmem with brmem'.'.
    brmems.change_file = brmems.change_file BrMem
    call add_report "'"ckothlq""change_file'('translate(brmem)')'"'"
  end
  return

  /* ------------------------------------------------------- *
  | Copy to or from a PDS routine.                          |
  |                                                         |
  | Allow use of DoveTail's enhanced cp (getpds and putpds) |
  | if installed.                                           |
  |                                                         |
  | Normal OVMS cp will be used for DSORG=PS, Load Libraries|
  | and when the DoveTail product is not installed.         |
  * ------------------------------------------------------- */
do_copy:
  parse arg cp_cmd
  /* ------------------------------------------------------- *
  | If enhance cp is not enabled or if the cp is for a load |
  | module then do normal cp                                |
  * ------------------------------------------------------- */
  do_enhanced = 1
  if enhanced_cp = 0 then do_enhanced = 0
  if pos('-X',cp_cmd) > 0 then do_enhanced = 0
  if sysdsorg = 'PS' then do_enhanced = 0
  if do_enhanced = 0 then do
    codepage = null
    cp_target = word(cp_cmd,words(cp_cmd))
    if left(cp_target,3) = '"//' then
       cp_target = word(cp_cmd,words(cp_cmd)-1)
    if right(cp_target,1) = '/'
       then cp_target = cp_target'*'
    codepage = '&& chtag -tc 'encoding cp_target
    if pos('-B ',cp_cmd) > 0 then codepage = null
    if pos('-X ',cp_cmd) > 0 then codepage = null
    x = docmd(cp_cmd codepage)
    if x > 0 then call view_std 'B'
    return x
  end
  else do
    getpds = dovetail_dir'getpds'
    putpds = dovetail_dir'putpds'
    /* -------------------------------------------- *
    | otherwise use the Dovetail enhanced cp tools |
    * -------------------------------------------- */
    do_cpcmd = null
    do_1st = 0
    do until length(cp_cmd) = 0
      parse value cp_cmd with lcmd '&&' cp_cmd
      if word(lcmd,1) = 'cp' then do
        lcmd = fixup_cp(lcmd)
        if do_1st = 0
        then do_cpcmd = lcmd
        else do_cpcmd = do_cpcmd '&&' lcmd
        do_1st = 1
      end
      else do
        if do_1st = 0
        then do_cpcmd = lcmd
        else do_cpcmd = do_cpcmd '&&' lcmd
        do_1st = 1
      end
    end
    x = docmd(do_cpcmd)
    if se.0 > 1 then
      call view_std 'B'
    return x
  end

Fixup_cp: Procedure expose null putpds getpds qualignr localrep zigirep ,
  env. codep debugfil
  parse arg cmd
  parse value cmd with cmd '&&' rcmd
  w = words(cmd)
  target = word(cmd,w)
  source = word(cmd,w-1)

  if left(source,1) = '#'
     then source = '\'source

  cmd = subword(cmd,2,w-3)
  target = strip(target,'B','"')
  source = strip(source,'B','"')
  parse value '' with cpm cpu
  if left(target,3) = "//'" then do
    target = remove_safe(target)
    statfile = fixup_cpstat(target)
  end
  if left(source,3) = "//'" then do
    source = remove_safe(source)
    statfile = fixup_cpstat(source)
  end
  if left(target,2) = '//' then do   /* use putpds */
    cp = putpds
  end
  if left(source,2) = '//' then do   /* use getpds */
    cp = getpds
    if pos('(',source) > 0 then cpu = 'upp=y'
    if pos('-U',cmd) > 0 then cpu = 'upp=y'
    if pos('-S',cmd) > 0 then do
      parse value cmd with . 'a='suf .
      if left(suf,1) = '.' then suf = substr(suf,2)
      cpm = 'su='suf
      cpu = null
    end
    else do
      p = lastpos('/',target)
      ls = substr(target,p+1)
      if pos('.',ls) = 0
      then do
        target = left(target,p)
      end
      else do
        parse value ls with .'.'suf
        target = left(target,p)
        cpm = 'su='suf
        cpu = null
      end
    end
    if cpu /= null then do
      if cpm /= null then cpu = cpu','cpm
    end
    else
    if cpm /= null then cpu = cpm
    if cpu /= null
    then cp = cp '-M' cpu',r=y'
  end
  if right(word(cp,1),6) = 'putpds'
     then putsd = '-S D '  /* trailing blank required */
     else putsd = null
  if cp = null & pos('-X',cp) = 0
  then cp = putsd'-M st='localrep'/'zigirep'/.zigi/'statfile
  else do
    cp = word(cp,1) ,
      putsd'-M st='localrep'/'zigirep'/.zigi/'statfile','strip(subword(cp,3))
  end
  if pos('-B',cmd) > 0 then cp = cp '-b'
  else if right(word(cp,1),6) = 'getpds' then
       cp = cp',tag=y -t' codep
  cmd = cp source target
  if right(word(cp,1),6) = 'getpds' then
  tagit = '&& chtag -tc' codep localrep'/'zigirep'/.zigi/'statfile
  else tagit = null
  if rcmd = null then return cmd tagit
  else return cmd '&&' rcmd tagit

Fixup_cpstat:
  arg cpstat
  cpstat = substr(cpstat,3)   /* remove // */
  lq = pos('(',cpstat)
  if lq > 0 then parse value cpstat with cpstat'(' .
  cpstat = translate(cpstat,' ',".'")
  cpstat = subword(cpstat,qualignr+1)
  cpstat = translate(cpstat,'.',' ')
  return cpstat

Get_Ignored:
  cmd = 'cat' localrep'/'zigirep'/.gitignore'
  x = docmds(cmd)
  return

Check_ignore:
  parse arg check_git_ignore
  do gic = 1 to sso.0
    if check_git_ignore = strip(sso.gic) then return 'GI'
  end
  return 0

Update_stats:
  parse arg us_stats us_dsn
  if pos('(',us_dsn) > 0 then do
    parse value us_dsn with us_dsn'('.')'r_dsn
    us_dsn = us_dsn''r_dsn
  end
  if left(us_dsn,1) /= "'" then us_dsn = "'"us_dsn"'"
  uscmd = dovetail_dir'getpds -M st='us_stats',upd=n' '//'us_dsn ,
     '&& chtag -tc' encoding us_stats
  x = docmd(uscmd)
  if rc > 0 then call view_std 'B'
  return

  /* Ensure files are correctly tagged before adding to index */
Git_Safe_Add:   /* FM */
  parse arg gsa_dir gsa_files gsa_options
  gsa_cmd = 'cd' gsa_dir
  gsa_cmd = gsa_cmd '&& git add' gsa_options gsa_files
  x = docmd(gsa_cmd)
  return

  /* Automatically tag modified and untracked files */
Auto_Tag_Files:  /* FM */
  parse arg atf_dir atf_files
  ls_cmd = 'cd' atf_dir '&& git ls-files -mo' atf_files
  x = docmd(ls_cmd)
  /* save output which otherwise is overridden */
  do i=0 to so.0
    ls_cmd_so.i = so.i
  end
  do i=1 to ls_cmd_so.0
    atf_data = ls_cmd_so.i
    call auto_tag_file atf_dir atf_data
  end
  return

  /* Automatically tag specified file */
Auto_Tag_File:   /* FM */
  parse arg atf_dir atf_file
  attr_cmd = 'cd' atf_dir
  attr_cmd = attr_cmd '&& git check-attr -a' atf_file ,
    '| grep -e "binary: set"' ,
    ' -e "zos-working-tree-encoding:"'
  x = docmd(attr_cmd)
  codepage = null
  do atfi = 1 to so.0
    if pos('binary:',so.atfi) > 0 then do
      cht_cmd = 'cd' atf_dir
      cht_cmd = cht_cmd '&& chtag -b' atf_file
      x = docmd(cht_cmd)
      return
    end
    if pos('zos-working',so.atfi) > 0 then
    parse value so.1 with . 'encoding:' xx'-'codepage
  end
  if codepage = null then return
  cht_cmd = 'cd' atf_dir
  cht_cmd = cht_cmd '&& chtag -tc' codepage atf_file
  x = docmd(cht_cmd)
  return

  /* -------------------------------------------------- *
   | Check for any lowercase characters in the provided |
   | string and return the match count.                 |
   * -------------------------------------------------- */
Lower_Check: Procedure
  parse arg check_dsn
  return verify(check_dsn,'abcdefghijklmnopqrstuvwxyz','M')

Fix_Remote_Tab:
  Select
    When pos('05'x,so.1) > 0 then
         tab = '05'x
    When pos('09'x,so.1) > 0 then
         tab = '09'x
    Otherwise nop
    end
    return
