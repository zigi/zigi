  /* --------------------  rexx procedure  ------------------- */
  ver = 'v2r7'
  /*Name:      zigi  (z ISPF Git Interface)                    |
  |                                                            |
  | Function:  ISPF Interface to Git for source code           |
  |            management                                      |
  |                                                            |
  | Syntax:    ex 'zigi.exec(zigi)'                            |
  |                                                            |
  |            or to restore the splash screen                 |
  |            ex 'zigi.exec(zigi)' 'S'                        |
  |                                                            |
  |            or to start with a specific repository          |
  |            ex 'zigi.exec(zigi)' 'repo-name'                |
  |                                                            |
  | NOTE:      ZIGI MUST NEVER be started under the ZIGI       |
  |            ISPF Applications ID unless the libdef and      |
  |            altlibs are done prior to starting.             |
  |                                                            |
  | Dependencies:                                              |
  |            1. Requires the z/OS port of GIT be installed   |
  |            2. Git setup in /etc/profile or ~/.profile      |
  |                                                            |
  | Authors:   Henri Kuiper                                    |
  |            Lionel B. Dyck                                  |
  |                                                            |
  | History:  (most recent on top, see git log for full info)  |
  |                                                            |
  |            03/18/20 LBD - Refine ref date check            |
  |                         - Bypass update check after repo   |
  |                           is selected.                     |
  |                         - New CHECK command to check       |
  |                           updated datasets.                |
  |            03/17/20 LBD - Improve delete PDS member        |
  |                           detection on PULL                |
  |                         - Bypass update check based on     |
  |                           last reference date of dataset   |
  |            03/15/20 LBD - Detect when PDS members deleted  |
  |                           outside of zigi                  |
  |            03/09/20 LBD - Remove unneeded control save/rest|
  |            03/05/20 HBK - Fixed another qualignr 'bug'     |
  |                         - More deletes at remove repo      |
  |            03/04/20 LBD - Jump to Add Dataset after Create |
  |            03/03/20 LBD - Several updates                  |
  |            02/28/20 LBD - Added Convert Repo capability    |
  |            02/27/20 HBK - Added feature 'zigiflow'         |
  |                           Fixed another edge case with $'s |
  |            02/26/20 LBD - Numerous changes to support      |
  |                           Stash processes                  |
  |                         - Fix fetch flag setting           |
  |            02/21/20 LBD - Change Refresh to Replace        |
  |                         - Add Fetch command                |
  |                         - Only fetch 1st time or on demand |
  |            02/15/20 LBD - Remove view_std's where not      |
  |                           worth it (rm/rn) and added msgs  |
  |                         - Change commit to use a table for |
  |                           an unlimited # of message lines  |
  |            02/14/20 LBD - Correctly identify already added |
  |                           datasets during ADDDSN           |
  |            02/13/20 LBD - Enable 2 column sort on Local    |
  |                           Repository and retain sort order |
  |                           for next time zigi starts.       |
  |                         - Fix bug with selective OMVS to   |
  |                           z/OS copy during PULL for both   |
  |                           renames and deletes.             |
  |                         - Enable passing a repo name on    |
  |                           start                            |
  |            02/10/20 LBD - Add SortDate for proper sorting  |
  |                         - Add optional tag on commit       |
  |            02/09/20 LBD - Update sort default orders       |
  |                         - add time to zigidate             |
  |                         - save default sort for zigirepo   |
  |            02/08/20 LBD - Test for branch before create    |
  |            02/07/20 LBD - Support Tag/Tagline              |
  |            02/03/20 LBD - Support mixed text/binary pds    |
  |            02/02/20 LBD - Add ADDALL to current repo and   |
  |                           PDS member list commands         |
  |            01/24/20 LBD - Improve RFIND table entry setup  |
  |            01/23/20 LBD - Eliminate use of LISTC for ADDdsn|
  |                           and call ZIGIRCSI                |
  |                         - Add FIND for ADDDSN routine      |
  |                         - Enable RFIND                     |
  |            01/21/20 LBD - Undo now works for PS and PDS    |
  |                         - Correct bug in RM for OMVS file  |
  |                           with blanks in name              |
  |                         - On Pull correctly delete items   |
  |                           that have been removed.          |
  |                         - After Commit if no push and a    |
  |                           Remote issue message to remind   |
  |                           to push.                         |
  |            01/20/20 LBD - Put OMVS files in quotes for     |
  |                           git add                          |
  |                         - Add several binary filetypes     |
  |                           to .gitattributes priming        |
  |            01/19/20 LBD - Add LMFree after every LMClose   |
  |                         - Pass qualignr to zigickot        |
  |                         - Fix qualignr=0 issues            |
  |            01/17/20 LBD - Support Only and Refresh in      |
  |                           Rollback                         |
  |            01/16/20 LBD - Support Recover in History for   |
  |                           individual element               |
  |            01/15/20 LBD - Fix binary PDS member tag -R     |
  |            01/14/20 HBK - Binary support implemented       |
  |                     LBD - Correct selective refresh bug    |
  |            01/13/20 LBD - Implement repository Snapshot    |
  |                         - Change current repo ADD to       |
  |                           ADDDSN                           |
  |            01/12/20 LBD - Always copy PS files and let     |
  |                           git determine any changes        |
  |            01/11/20 LBD - Do git add for stats after PDS   |
  |                           member rm                        |
  |                         - Prompt for OK to delete branch   |
  |            01/10/20 LBD - Correct detection of renames     |
  |                         - fix rename member with specials  |
  |            01/09/20 LBD - Support Repo del of the z/OS     |
  |                           datasets and more confirmation   |
  |            01/08/20 LBD - Update for PDSE generations      |
  |                           at allocation                    |
  |            01/07/20 LBD - Additional debug calls           |
  |                         - debug file name date/time added  |
  |                         - change list debug files from B   |
  |                         - don't copy PS if not new/changed |
  |            01/05/20 LBD - If PDSE then never do full       |
  |                           refresh on a pull                |
  |            01/03/20 LBD - On Pull only refresh updated     |
  |                           datasets and/or members.         |
  |                         - if > 25% members updated in pull |
  |                           then refresh full pds.           |
  |                         - Correct primary panel zcmd for   |
  |                           upper case command, mixed other  |
  |                         - Change sort order if Date to     |
  |                           include Time                     |
  |                         - On Edit_PS use usssafe for cp    |
  |                           on the repository file name      |
  |                         - Bypass update_repo_metadata if   |
  |                           multiple rows selected           |
  |            01/02/20 LBD - For clone/create set sets to null|
  |                         - Add Select command for repo      |
  |            12/26/19 LBD - Change temp dsn suffix: gitdata  |
  |            12/24/19 HBK - Correct URL parse                |
  |                     LBD - Enable O.xxx commands            |
  |            12/23/19 HBK - One more fix for file status     |
  |                     LBD - Use View for DIFF for hilite     |
  |            12/22/19 HBK - Correct stats for subdirectories |
  |            12/15/19 LBD - Add Author  to History display   |
  |            12/14/19 LBD - Improve history log search       |
  |                           using grep                       |
  |            12/13/19 LBD - Add new History selection        |
  |                         - Add incldiff leed-dev            |
  |            12/10/19 LBD - Add FIND/RFIND for Repo table    |
  |                           and in the dataset/file table    |
  |            12/09/19 LBD - Improve OMVS directory support   |
  |            12/07/19 LBD - Implement a git merge conflict   |
  |                           resolution process.              |
  |            12/06/19 LBD - Define top tutorial panel        |
  |            12/04/19 LBD - Support Remove (RM) and          |
  |                           Rename (RN) options              |
  |            11/30/19 LBD - Use Edit and View for OMVS files |
  |                         - Test if Edit OMVS file changed   |
  |            11/27/19 HBK - Check for minimal git version    |
  |            11/27/19 LBD - Translate ' and " from commit    |
  |                           1 line msg.                      |
  |                         - add -i (ignore case) to grep     |
  |                         - in grep dsn allow b/e/v of       |
  |                           omvs files                       |
  |            11/26/19 HBK - Support site profile             |
  |            11/25/19 LBD - Add repository SET for defaults  |
  |                         - Support ROLLBACK of repo         |
  |                         - Enhance GITLOG and GREP          |
  |                         - Update member uids if default id |
  |                           set during commit                |
  |            11/21/19 LBD - Check for ISPTABL and use it     |
  |                           otherwise use ISPPROF for our    |
  |                           table.                           |
  |            11/18/19 LBD - Support F3 in ZIGIOSEL and       |
  |                           skip clone.                      |
  |                         - Replace LMMSTATS with LMMFIND    |
  |                           to get member stats              |
  |                         - Add -v (verbose) where ok        |
  |            11/16/19 LBD - Convert to using zigitstat       |
  |                           to save/update/compare           |
  |                           ispf stats on PDS members.       |
  |            11/13/19 LBD - Enhance the debug routine:       |
  |                           Return a return code             |
  |                           check for ZIGIDEBG DD enable     |
  |                           log is in users home dir         |
  |            11/11/19 LBD - Add GITHELP as a command from    |
  |                           all panels (except browse)       |
  |            11/10/19 HBK - Fix qualignr edge-cases          |
  |            11/09/19 HBK - My history keeps dissapearing    |
  |                           see git :)                       |
  |            11/06/19 LBD - Numerous changes including       |
  |                           - Improve bpxwunix performance   |
  |                             by using an env stem           |
  |                           - fix lrecl for browse reports   |
  |                           - other bug fixes and cleanup    |
  |            11/02/19 LBD - Add shorten ZIGIREPO panel       |
  |                           ZIGIREPS if Short command used   |
  |            10/31/19 LBD - Various Fixes :)                 |
  |            10/29/19 LBD - Add MultiDCB Support             |
  |            10/24/19 HBK - Also source ~/.profile if exists |
  |            10/24/19 LBD - Change 2 routines to procedure   |
  |                         - Add Commit message               |
  |            10/21/19 LBD - Use PARSE SOURCE for hlq         |
  |            10/20/19 HBK - Fix LMM things :)                |
  |            10/19/19 LBD - Better prefix, scrolling etc.    |
  |            10/17/19 HBK - Add back LMM, cleanup code       |
  |            09/30/19 HBK - Major rewrite :)                 |
  |            07/24/19 HBK - Some git functions               |
  |            06/15/19 HBK - Autofind git binary              |
  |            06/14/19 LBD - Major updates                    |
  |            06/12/19 LBD - Major updates                    |
  |            06/11/19 LBD - Creation                         |
  |                                                            |
  | ---------------------------------------------------------- |
  |    zigi - the z/OS ISPF Git Interface                      |
  |    Copyright (C) 2020 - Henri Kuiper and Lionel Dyck       |
  |                                                            |
  |    This program is free software: you can redistribute it  |
  |    and/or modify it under the terms of the GNU General     |
  |    Public License as published by the Free Software        |
  |    Foundation, either version 3 of the License, or (at     |
  |    your option) any later version.                         |
  |                                                            |
  |    This program is distributed in the hope that it will be |
  |    useful, but WITHOUT ANY WARRANTY; without even the      |
  |    implied warranty of MERCHANTABILITY or FITNESS FOR A    |
  |    PARTICULAR PURPOSE.  See the GNU General Public License |
  |    for more details.                                       |
  |                                                            |
  |    You should have received a copy of the GNU General      |
  |    Public License along with this program.  If not, see    |
  |    <https://www.gnu.org/licenses/>.                        |
  * ---------------------------------------------------------- */
  parse arg start_option

  Address ISPExec
  'vget (zapplid)'

  null = ''

  /* ----------------------------------------------------- *
  | Get the Active HLQ for use with the ALTLIB and LIBDEF |
  | of the zIGI libraries.                                |
  | 1st Get the active exec library or dd                 |
  * ----------------------------------------------------- */
  parse source TSO Type exec_name DDName exec NameO Env Addr Token
  if exec = '?' then do
    x = listdsi(ddname 'FILE')
    exec = sysdsname
  end
  /* ------------------------------------------ *
  | Now extract the HLQ for the Panels Library |
  * ------------------------------------------ */
  zigihlq = translate(exec,' ','.')
  zigihlq = subword(zigihlq,1,words(zigihlq)-1)
  zigihlq = translate(zigihlq,'.',' ')
  /* ---------------------------------------------- *
  | Fully qualify the EXEC and PANELS library dsns |
  * ---------------------------------------------- */
  exec = "'"exec"'"
  panels = "'"zigihlq".PANELS'"

  /* ----------------------------------------------------------- *
  | Check for running under the ZIGI ISPF application ID and if |
  | not then recurse into it.                                   |
  * ----------------------------------------------------------- */
  if zapplid <> "ZIGI" then do
    Address ISPExec
    /* ---------------------------------------- *
    | If panels/exec then libdef and/or altlib |
    | but only if not under ZIGI applid.       |
    * ---------------------------------------- */
    if panels /= null then
    'libdef ispplib dataset id('panels') stack'
    if exec /= null then
    Address TSO 'altlib act application(exec) dataset('exec')'
    /* --------------------------------------- *
    | Make sure we are under the ZIGI applid  |
    * --------------------------------------- */
    "Select CMD("exec_name start_option") Newappl(ZIGI) Passlib scrname(zigi)"
    if panels /= null then
    'libdef ispplib'
    if exec /= null then
    Address TSO 'altlib deact application(exec)'
    exit 0
  end
  zigpass = null
  'vput (zigpass) shared'

  parse value '' with null rx zigidebg_flag save_zigirep fulldsn cltime
  cscnt = 0
  cdrcnt = 0

  cmd = 'pwd'
  x = bpxwunix(cmd,,so.,se.)
  home    = strip(so.1)

  /* ---------------------------------------- *
  | Check for ZIGIDEBG DD for debug purposes |
  * ---------------------------------------- */
  x = listdsi('ZIGIDEBG' 'FILE')
  if x > 0 then if sysreason = 3 then do
    zigidebg = 1
    ztime = time()
    ztime = left(ztime,2)''substr(ztime,4,2)''substr(ztime,7,2)
    debugfil = home'/zigidebug.d'date('j')'.t'ztime
    'vput (debugfil)'
  end
  else zigidebg = 0
  if zigidebg = 0 then
  "Control Errors Return"

  /* ---------------------------------------------------------------- *
  | Running under the ZIGI ISPF Application ID so let's do some work |
  * ---------------------------------------------------------------- */
  parse value '' with zcmd zsel
  zigtitle = '(zigi' ver')'
  'vput (zigtitle ver)'
  'vget (bypass pnsdef) profile'
  if pnsdef = null then do
    pnsdef = 'S'
    'vput (pnsdef) profile'
  end
  bypasso = bypass
  if translate(start_option) = 'S' then bypass = 'N'
  if bypass /= 'Y' then do
    'display panel(zigispls)'
    if rc = 8 then exit
    'vput (bypass) profile'
    if bypasso /= 'Y' then
    if bypass = 'Y' then do
      zs1 = 'The splash screen will no longer display per your request.'
      zs2 = ' '
      zs3 = 'Start zigi with a parm of S to restore.'
      zs4 = '--- Press Enter to continue.'
      call do_popup4p
    end
  end

  /* ---------------------------------------------------------- *
  | Enable RFIND (Repeat Find) by adding an RFIND entry to the |
  | active site command table with a symbolic that will be     |
  | changed to PASSTHRU prior to each TBDISPL and back to null |
  | after. This allows RFIND to be passed to our applicaiton.  |
  * ---------------------------------------------------------- */
  zctverb  = "RFIND"
  zcttrunc = 0
  zctact   = "&ZIGPASS"
  zctdesc  = "RFIND for zigi Dialog"
  'vget (zsctpref)'
  if zsctpref = null
  then zsctpref = 'ISP'
  ctab = zsctpref'cmds'
  'tbtop' ctab
  'tbscan' ctab 'arglist(zctdesc) condlist(EQ) Next'
  if rc > 0 then 'tbadd' ctab
  zigpass = null
  'vput (zigpass)'

  /* ------------------------------------ *
  | define our working default variables |
  * ------------------------------------ */
  zhtop = 'ZIGIHINT'
  zerrhm   = 'zigih00'
  zerralrm = 'NO'
  zerrtp   = 'NOTIFY'
  zs1 = 'Preparing the zigi environment for use'
  zs2 = 'Please standby'
  call do_popup

  /* See if we've a custom env file in profile already */
  'vget (gitenv) profile'
  call getenv

  keyfile = home'/.ssh/id_rsa.pub'
  rtbl = 'ZIGL'random(9999)
  rtll = 'ZIGM'random(9999)
  rtbb = 'ZIGB'random(9999)
  rtbl_open = 0
  rtll_open = 0
  combine.0 = 0
  zigi_offline = 0

  /* ------------------------------------ *
  | Let's try to find git.               |
  * ------------------------------------ */
  zs1 = 'Checking if you have git installed'
  zs2 = 'Please standby'
  call do_popup

  x   = docmd('command -v git')

  x = so.0
  if so.0 > 0 then do
    zigigitl = strip(so.x)
    'vput (zigigitl) profile'
  end
  else do
    'Display Panel(zigigit)'
    'vput (gitenv) profile'
    call getenv
    x = docmd('command -v git')
    if so.0 > 0 then do
      x = so.0
      zigigitl = strip(so.x)
      'vput (zigigitl) profile'
    end
    else do
      /* Nope that file is not correct. removing from profile */
      zs1 =  "The env file ("gitenv") does not point me to git :("
      zs2 =  "Please rerun zigi and specify a valid env file"
      zs4 = 'Press Enter to exit and try again.'
      call do_popup4p
      parse value '' with zs3
      'verase (gitenv) profile'
      exit(0)
    end
  end

  x = docmd('git --version')
  required_version = '2.14.4'
  x = so.0
  parse var so.x 'git' 'version' version'_'subversion
  version = strip(version,'B')
  if version < required_version then do
    zs1 = "Your git version is not at the minimum required level"
    zs2 = "Your level    : "version
    zs3 = "Required level: "required_version
    zs4 = 'Press Enter to exit and install the correct version.'
    call do_popup4p
    exit 8
  end
  /* ------------------------------------------ *
  | Check for GIT Userid and if not found      |
  | then prompt for it along with a GIT E-Mail |
  | Find the SSH key and if not there generate |
  * ------------------------------------------ */
  zs1 = 'Checking for user.name and user.email'
  zs2 = 'Please standby'
  call do_popup
  x = docmd('git config --global user.name')
  if x = 0 then do
    x = so.0
    zigiuid = so.x
  end
  else do
    zigiuid = null
  end
  x = docmd('git config --global user.email')

  if x = 0 then do
    x = so.0
    zigimail = so.x
  end
  else do
    zigimail = null
  end
  cmd = 'cat 'home'/.ssh/id_rsa.pub'
  x = bpxwunix(cmd,,so.,se.)
  if x > 0 then do
    zs1 = 'No SSH identity found in 'home'/.ssh/id_rsa'
    zs2 = 'Generating keypair, please standby'
    call do_popup
    cmd = 'mkdir -p 'home'/.ssh'
    x = bpxwunix(cmd,,so.,se.)
    cmd = 'cd 'home' && ssh-keygen -t rsa -f .ssh/id_rsa'
    x = bpxwunix(cmd,,so.,se.)
    cmd = 'cat 'home'/.ssh/id_rsa.pub'
    x = bpxwunix(cmd,,so.,se.)
  end
  x = so.0
  zigissh = so.x
  old_zigiuid = zigiuid
  old_zigimail = zigimail

  'vget (mgen)'

  Select
    When mgen = null then hit = 0
    when zigiuid = null then hit = 0
    when zigimail = null then hit = 0
    Otherwise hit = 1
  end
  do forever
    if hit = 1 then leave
    sl = mgen()
    'Display Panel(zigiset)'
    if rc > 0 then leave
    'vput (mgen) profile'
    call update_config
    if zigiuid /= null
    then if zigimail /= null
    then if zigissh /= null
    then do forever
      zcmd = null
      'Display Panel(zigisshk)'
      if rc > 0 then do
        hit = 1
        leave
      end
    end
  end

  /* ---------------------------------------- *
  | Open (or create and open) the Repo Table |
  * ---------------------------------------- */
  isptabl = 'ISPTABL'
  x = listdsi(isptabl 'FILE')
  if x > 0 then isptabl = 'ISPPROF'
  'TBOpen zigirepo Library('isptabl') Write Share'
  if rc > 0 then do
    if rc = 8 then call create_zigirepo
    if rc > 8 then do
      'setmsg msg(isrz003)'
    end
  end

  /* --------------------------------------------- *
  | Test to see if the ZIGIREPO table is for V2R0 |
  | and if not upgrade it.                        |
  * --------------------------------------------- */
  call test_repo_table_state

  repo_top = 1
  'tbtop zigirepo'
  'vget (defrsort) profile'
  if words(defrsort) = 2 then defrsort = 'zigirep,c,a'
  'TBSort zigirepo Fields('defrsort')'
  parse value '' with zsel szcmd
  if start_option /= null
  then if translate(start_option) /= 'S' then
  szcmd = 'S' start_option

  /* Panel for when there are no repos in profile yet */
  'TBStats zigirepo rowcurr('tr')'
  if tr = 0 then do
    'Addpop row(4) column(6)'
    'Display Panel(zigi1st)'
    'rempop'
  end

  do forever
    if szcmd = null then do
      parse value '' with zsel row
      fetch_flag = 0
      zigpass = 'PASSTHRU'
      'vput (zigpass) shared'
      'TBTop zigirepo'
      'tbskip zigirepo number('repo_top')'
      localrep = null
      'vput (localrep) shared'
      'tbdispl zigirepo panel(zigiprim)'
      trc = rc
      zigpass = null
      'vput (zigpass) shared'
      if trc > 4 then leave

      if ztdsels = 0 then
      if pnsdef = 'P' then do
        if row = 0 then zcmd = 'O'
        if row > 0 then zsel = '/'
      end

      repo_top = ztdtop
      if row = 0 then zsel = null
      if row <> null then
      if row > 0 then do
        'TBTop zigirepo'
        'TBSkip zigirepo Number('row')'
      end
    end

    if szcmd /= null then do
      zcmd = szcmd
      szcmd = null
    end

    check_flag = 1

    zcmd = strip(translate(word(zcmd,1)) subword(zcmd,2))

    if word(zcmd,1) = 'L' then
    zcmd = 'F' subword(zcmd,2)

    parse value '' with findstr selfind
    if pos('.',zcmd) > 0 then
    parse value zcmd with x'.'zcmd
    if zcmd = 'O' then do
      'Addpop row(4) column(6)'
      'Display Panel(zigioprm)'
      'rempop'
    end
    if findstr /= null
    then zcmd = 'F' findstr
    if selfind /= null
    then zcmd = 'S' selfind

    /* ------------------------ *
    | Select a repo by command |
    * ------------------------ */
    if abbrev('SELECT',word(zcmd,1),1) = 1 then do
      x = debug('Selecting repo via command:'zcmd)
      zerrsm = null
      fstring = word(zcmd,2)
      zcmd = null
      if fstring = null then do
        'addpop row(3) column(4)'
        'display panel(zigisel)'
        drc = rc
        'rempop'
        if fstring = null then drc = 4
        if drc > 0 then  do
          zerrsm = 'Canceled.'
          zerrlm = 'Select canceled.'
          'setmsg msg(isrz003)'
        end
      end
      if zerrsm = null then do
        'tbtop zigirepo'
        do forever
          'tbskip zigirepo'
          if rc > 0 then do
            zerrsm = 'Not Found'
            zerrlm = fstring 'repository not found. Verify the spelling and' ,
              'case.'
            'setmsg msg(isrz003)'
            leave
          end
          if translate(fstring) /= translate(zigirep) then iterate
          'tbget zigirepo'
          if defcpush = 'Y' then zpush = 'Y'
          else zpush = 'N'
          zcmd = null
          call select_repo
          parse value '' with zsel zcmd
          leave
        end
      end
    end

    /* -------------- *
    | Process a Find |
    * -------------- */
    if zcmd = 'RFIND' then do
      zcmd = 'FIND' fstring
      rfs  = rowcnt
    end
    else rfs = 0
    if abbrev('FIND',word(zcmd,1),1) = 1 then do
      fstring = translate(word(zcmd,2))
      zcmd = null
      find = null
      if fstring = null then do
        'Addpop row(4) column(6)'
        'Display Panel(zigifind)'
        drc = rc
        'rempop'
        if drc > 0 then find = null
        fstring = find
      end
      if fstring /= null then do
        rowcnt = 0
        'tbtop zigirepo'
        if rfs > 0 then do
          'tbskip zigirepo number('rfs')'
          rowcnt = rfs
        end
        do forever
          'tbskip zigirepo'
          if rc > 0 then do
            if rfs > 0 then do
              rfs = 0
              'tbtop zigirepo'
              'tbskip zigirepo'
              rowcnt = 0
            end
            else do
              zerrsm = 'Not Found'
              zerrlm = fstring 'not found.'
              'setmsg msg(isrz003)'
              leave
            end
          end
          rowcnt = rowcnt + 1
          'tbget zigirepo'
          if pos(fstring,translate(zigirep pdshlq)) > 0 then do
            repo_top = rowcnt
            zerrsm = 'Found'
            zerrlm = fstring 'found in row' rowcnt + 0
            'setmsg msg(isrz003)'
            leave
          end
        end
      end
    end

    parse value '' with fulldsn dsn defcpush defruid
    /* Get the row after the clear to get variables */
    'tbget zigirepo'
    if defcpush = 'Y' then zpush = 'Y'
    else zpush = 'N'

    if zcmd /= null then
    Select
      When abbrev('CREATE',zcmd,2) = 1 then do
        x = Create_Repo()
        crflag = 1
        if x = 0 then do
          zcmd = 'ADDDSN'
          call work_with_repo
          zsel = null
        end
      end
      When abbrev('CLONE',zcmd,2) = 1 then do
        encoding = null
        call Clone_Repo
        zsel = null
      end
      When abbrev('CONFIG',zcmd,2) = 1 then do forever
        zcmd = null
        'vget (mgen pnsdef) profile'
        sl = mgen()
        'display panel(zigiset)'
        'vput (mgen pnsdef) profile'
        call update_config
        if rc = 0 | rc = 8 then leave
      end
      When abbrev('GITHELP',word(zcmd,1),4) = 1 then
      Address TSO '%githelp' subword(zcmd,2)
      when abbrev('LOCAL',zcmd,2) = 1 then do
        if zigtitle = 'Offline'
        then do
          zigtitle = '(zigi' ver')'
          zigi_offline = 0
        end
        else do
          zigtitle = 'Offline'
          zigi_offline = 1
        end
        'vput (zigtitle)'
      end
      When abbrev('SORT',word(zcmd,1),2) = 1 then do
        zcmd = translate(zcmd)
        defrsort = null
        parse value zcmd with . skey sopt skey2 sopt2
        if skey = null then do
          call pfshow 'off'           /* make sure pfshow is off */
          'Addpop row(4) column(6)'
          'Display Panel(zigipsrt)'
          'Rempop'
          call pfshow 'reset'         /* restore pfshow setting */
        end
        if sopt = '' then
        if lsopt = 'A' then sopt = 'D'
        else sopt = 'A'
        select
          when abbrev('REPOSITORY',skey,1) = 1 then
          skey = 'zigirep'
          when abbrev('CATEGORY',skey,1) = 1 then
          skey = 'zigicat'
          when abbrev('PREFIX',skey,1) = 1 then
          skey = 'pdshlq'
          when abbrev('LAST',skey,1) = 1 then
          skey = 'sortdate'
          when abbrev('DATE',skey,1) = 1 then
          skey = 'sortdate'
          otherwise skey = 'zigirep'
        end
        select
          when abbrev('REPOSITORY',skey2,1) = 1 then
          skey2 = 'zigirep'
          when abbrev('CATEGORY',skey2,1) = 1 then
          skey2 = 'zigicat'
          when abbrev('PREFIX',skey2,1) = 1 then
          skey2 = 'pdshlq'
          when abbrev('LAST',skey2,1) = 1 then
          skey2 = 'sortdate'
          when abbrev('DATE',skey2,1) = 1 then
          skey2 = 'sortdate'
          otherwise nop
        end
        if left(sopt,1) = 'D' then sopt = 'D'
        else sopt = 'A'
        if skey2 /= null then do
          if left(sopt2,1) = 'D' then sopt2 = 'D'
          else sopt2 = 'A'
        end
        defrsort = skey',c,'sopt
        if skey2 /= null then
        defrsort = defrsort','skey2',c,'sopt2
        'tbsort zigirepo fields('defrsort')'
        lsopt = sopt
        'vput (defrsort) profile'
      end
      When abbrev('SSH',zcmd,2) = 1 then do forever
        zcmd = null
        'display panel(zigisshk)'
        if rc > 0 then leave
      end
      when zcmd = 'VIEWD' then call view_debug
      Otherwise if zcmd /= null then do
        zerrsm = 'Unknown'
        zerrlm = zcmd 'is not a recognized command.'
        'setmsg msg(isrz003)'
      end
    end

    if zsel = '/' then do
      'Addpop row(4) column(6)'
      'Display Panel(zigirprm)'
      'rempop'
    end

    if zsel /= null then
    Select
      When zsel = 'I' then do
        'addpop row(3) column(2)'
        'display panel(zigiinfo)'
        'rempop'
        zsel = null
      end
      When zsel = 'S' then call select_repo
      When zsel = 'V' then do
        'SELECT PGM(ISRDSLST) PARM(UDL' localrep'/'zigirep') SUSPEND'
      end
      When zsel = 'D' then do
        parse value '' with delcg delco delcf delzd
        'Addpop row(3) column(10)'
        'Display panel(zigidelc)'
        drc = rc
        'rempop'
        if drc = 0 & delcf = 'Y' then do
          if delcg = 'Y' then do
            'tbdelete zigirepo'
            cmd = 'cd 'localrep'/'zigirep' && rm -rf'
            cmd = cmd' .git .gitattributes .zigi'
            x = bpxwunix(cmd,,so.,se.)
            if x = 0 then do
              zerrsm = 'Deleted.'
              delcg = 'Repo removed from zigi, .git files deleted.'
            end
            else do
              zerrsm = 'Partially Deleted.'
              delcg = 'Repo removed from zigi, .git files not deleted.'
            end
          end
          if delzd = 'Y' then do
            delzd = 'The z/OS datasets have been deleted.'
            address syscall 'readdir' localrep'/'zigirep d.
            do id = 1 to d.0
              if left(d.id,1) = '.' then iterate
              deldsn = Add_DSN_HLQ(word(d.id,1))
              if dsnvalid(deldsn) = 'NO' then iterate
              call outtrap 'x.'
              address tso 'delete' deldsn
              call outtrap 'off'
            end
          end
          else delzd = 'The z/OS datasets were NOT deleted.'
          if delco = 'Y' then do
            cmd = 'cd' localrep' && rm -rf 'zigirep
            x = bpxwunix(cmd,,so.,se.)
            delco = 'The local repository has been deleted from OMVS.'
          end
          else delco = 'The local repository was NOT deleted from OMVS.'
          zerrlm = left(delcg,76) left(delco,76) left(localrep'/'zigirep,76) ,
            left(delzd,76)
          'setmsg msg(isrz003)'
        end
        else do
          zerrsm = 'Retained.'
          zerrlm = 'The local repository was NOT deleted from zigi, from' ,
            'OMVS' localrep'/'zigirep', or from z/OS.'
          'setmsg msg(isrz003)'
        end
      end
      Otherwise do
        zerrsm = 'Unknown'
        zerrlm = zsel 'is not a recognized command.'
        'setmsg msg(isrz003)'
      end
    End
  end

  if rtbl_open = 1 then
  'tbend' rtbl
  'tbclose zigirepo'

  /* ----------------------------------------------------------- *
  | If the ZIGIDEBG DD was present and the debugging was in use |
  | then display a list of debug files using the UDList (3.17)  |
  | utility.                                                    |
  * ----------------------------------------------------------- */
  if zigidebg = 1 then
  if zigidebg_use = 1 then do
    "Select Pgm(isrdslst) Parm(UDL ~/zigidebug*) SUSPEND"
  end
  Exit 0

  /* ------------------------------------- *
  | Select the Current Repository Routine |
  * ------------------------------------- */
Select_Repo:
  zigidate = date('n')
  sortdate = date('b')''right(time('s')+100000,5)
  'tbmod zigirepo order'
  x = debug('Getting binfiles:' zigirep)
  drop binfiles.
  call get_binfiles
  x = debug('Got 'binfiles.0' binfiles')
  x = debug('Selecting repo:' zigirep)
  call Work_With_Repo
  x = debug('Return from repo:' zigirep)
  Return

  /* ------------------------------ *
  | Create the ZIGIREPO ISPF Table |
  * ------------------------------ */
Create_zigirepo:
  "TBCreate zigirepo Keys(zigikey)",
    "Names(zigirep localrep pdshlq qualignr zigidate defcpush" ,
    " sortdate defruid zigicat branch remote1)",
    'Library('isptabl') Write Share'
  'vget (defrsort) profile'
  'TBSort zigirepo Fields('defrsort')'
  'TBSAVE zigirepo REPLCOPY LIBRARY('isptabl')'
  return

  /* --------------------------------- *
  | Work with the selected repository |
  * --------------------------------- */
Work_With_Repo:
  parse value '' with dsn dsnstat zsel
  list_top = 0
  crflag = 0
  remc = 'NO'
  x = debug('Working with Repo:' zigirep)
  call update_repo_metadata
  if cltime /= null then do
    zerrsm  = 'Clone:' cltime
    zerrlm  = left('Cloning completed for:' zigirep,76) ,
      'Total time to clone was:' cltime
    'setmsg msg(isrz003)'
  end
  'vput (localrep zigirep) shared'
  'tbsort' rtbl 'Fields(dsn,c,a)'
  'tbtop' rtbl
  repo_ztdsels = 0
  rtop = 0
  /* -------------------------------- *
  | Process the Repository Data Sets |
  * -------------------------------- */
  rtop = 0
  repo_save = 0
  do forever
    parse value '' with zsel row
    ztdsels = repo_ztdsels
    if zcmd /= 'ADDDSN' then do
      parse value '' with zsel zcmd row zcmd
      if ztdsels > 1
      then 'TBdispl' rtbl
      else do
        zigpass = 'PASSTHRU'
        'vput (zigpass) shared'
        'tbtop' rtbl
        'tbskip' rtbl 'Number('rtop')'
        'TBdispl' rtbl 'Panel(zigirepo)'
        rtop = ztdtop
      end
      trc = rc
      zigpass = null
      'vput (zigpass) shared'
      if trc > 4 then do
        'tbend' rtbl
        rtbl_open = 0
        return
      end
    end
    repo_ztdsels = ztdsels
    drop so. se.
    zcmd = translate(zcmd)

    if ztdsels = 0 then
    if pnsdef = 'P' then do
      if row = 0 then zcmd = 'O'
      if row > 0 then zsel = '/'
    end

    if row = 0 then zsel = null
    if row <> null then
    if row > 0 then do
      "TBTop " rtbl
      "TBSkip" rtbl "Number("row")"
    end

    if pos('.',zcmd) > 0 then
    parse value zcmd with x'.'zcmd
    if zcmd = 'O' then do
      'Addpop row(4) column(10)'
      'Display Panel(zigiorep)'
      'rempop'
    end

    /* -------------- *
    | Process a Find |
    * -------------- */
    if zcmd = 'RFIND' then do
      zcmd = 'FIND' fstring
      rfs  = rowcnt
    end
    else rfs = 0
    if abbrev('FIND',word(zcmd,1),1) = 1 then do
      fstring = translate(word(zcmd,2))
      zcmd = null
      find = null
      if fstring = null then do
        'Addpop row(4) column(6)'
        'Display Panel(zigifind)'
        drc = rc
        'rempop'
        if drc > 0 then find = null
        fstring = find
      end
      rowcnt = 0
      'tbtop' rtbl
      if rfs > 0 then do
        'tbskip' rtbl 'number('rfs')'
        rowcnt = rfs
      end
      do forever
        'tbskip' rtbl
        if rc > 0 then do
          if rfs > 0 then do
            rfs = 0
            'tbtop' rtbl
            'tbskip' rtbl
            rowcnt = 0
          end
          else do
            zerrsm = 'Not Found'
            zerrlm = fstring 'not found.'
            'setmsg msg(isrz003)'
            leave
          end
        end
        rowcnt = rowcnt + 1
        'tbget' rtbl
        if pos(fstring,translate(fulldsn)) > 0 then do
          rtop = rowcnt
          zerrsm = 'Found'
          zerrlm = fstring 'found in row' rowcnt '-' fulldsn
          'setmsg msg(isrz003)'
          leave
        end
      end
    end

    /* -------- *
    | zigiFlow |
    * -------- */
    if zcmd = 'FLOW' then do
      'addpop row(3) column(4)'
      'display panel(zigiflow)'
      drc = rc
      'rempop'
      if drc > 0 then zcmd = null
    end

    if zcmd /= null then
    Select
      When abbrev("CHECK",zcmd,3) = 1 then do
        check_flag = 1
        call work_with_repo
        zsel = null
      end
      /* -------------------------------- *
      | Branch dialog - create or change |
      * -------------------------------- */
      When abbrev('BRANCH',zcmd,2) = 1 then do
        if words(save_zigirep) > 0 then do
          zerrsm = 'Invalid.'
          zerrlm = 'Branch is not supported in subdirectories.'
          'setmsg msg(isrz003)'
        end
        else call Branch_it
      end
      /* ----------------------- *
      | Convert a non-zigi Repo |
      * ----------------------- */
      When abbrev('CONVREPO',zcmd,4) = 1 then do
        parse value '' with zcmd ans
        'display panel(zigivcnv)'
        drc = rc
        if ans /= 'Y' then drc = 4
        if drc > 0 then do
          zerrsm = 'Canceled.'
          zerrlm = 'Conversion canceled.'
          'setmsg msg(isrz003)'
        end
        else do
          if branch = 'master' then do
            convdir = localrep'/'zigirep
            cmd = 'cd' convdir '&& git checkout -b zigi-master'
            x = docmd(cmd)
          end
          call convert_repo
          x = docmd(cmd)
          defcpush = 'N'
          call work_with_repo
        end
      end
      /* ----------------- *
      | Git command prompt |
      * ------------------ */
      When abbrev('GITCMD',zcmd,4) = 1 then
      'Select cmd(%zigigcmd)'
      /* ------------------------- *
      | Invoke the GitHelp dialog |
      * ------------------------- */
      When abbrev('GITHELP',word(zcmd,1),4) = 1 then
      Address TSO '%githelp' subword(zcmd,2)
      /* -------------------------------- *
      | View output of git log           |
      * -------------------------------- */
      When abbrev('GITLOG',zcmd,2) = 1 then call do_gitlog
      /* -------------------------------- *
      | View summary info of repository  |
      * -------------------------------- */
      When abbrev('INFO',zcmd,2) = 1 then do
        'addpop row(3) column(2)'
        'display panel(zigiinfo)'
        'rempop'
      end
      /* ------------------------- *
      | Update/Set zigi repo info |
      * ------------------------- */
      When abbrev('SET',zcmd,1) = 1 then call do_rset
      /* ---------------------------- *
      | View (UDList) the repository |
      * ---------------------------- */
      When abbrev('VIEW',zcmd,1) = 1 then
      'SELECT PGM(ISRDSLST) PARM(UDL' localrep'/'zigirep') SUSPEND'
      /* -------------------------------- *
      | Merge a branch into current branch|
      * -------------------------------- */
      When abbrev('MERGE',zcmd,2) = 1 then do
        if words(save_zigirep) > 0 then do
          zerrsm = 'Invalid.'
          zerrlm = 'Merge is not supported in subdirectories.'
          'setmsg msg(isrz003)'
        end
        else call Merge_it
      end
      /* -------------------------------- *
      | Show the network graph            |
      * -------------------------------- */
      When abbrev('NETWORK',zcmd,2) = 1 then do
        cmd = 'cd' localdir' && git log --graph --oneline'
        cmd = cmd '--format="%h %<(50,trunc)%f"'
        x = docmd(cmd)
        if so.0 + se.0 > 1
        then call view_std
      end
      /* -------------------------------- *
      | Push current branch to origin    |
      * -------------------------------- */
      When abbrev('PUSH',zcmd,2) = 1 then do
        if zigi_offline = 0 then call do_push
        else do
          zerrsm = 'Offline.'
          zerrlm = 'Push is not allowed when offline.'
          'Setmsg msg(isrz003)'
        end
      end
      /* --------------------------------------------------------- *
      | Pull latest version of remote current branch from origin  |
      * --------------------------------------------------------- */
      When abbrev('PULL',zcmd,3) = 1 then
      if zigi_offline = 1 then do
        zerrsm = 'Offline.'
        zerrlm = 'Pull is not allowed when offline.'
        'Setmsg msg(isrz003)'
      end
      else do
        call pop 'Pulling from remote'
        cmd = 'cd' localdir' && git pull -v'
        x = docmd(cmd)
        if x > 0 then call view_std 'B'
        parse value '' with pulldsns pullmems. deletes.
        deletes.0 = 0
        pulled = 0
        do pi = 1 to so.0
          if left(so.pi,1) /= ' ' then iterate
          if pos(' changed,',so.pi) > 0 then do
            pullmsg = so.pi
            pulled = 1
            iterate
          end
          if word(so.pi,1) = 'rename' then do
            if pos('/',so.pi) > 0 then do
              parse value so.pi with . dd'/{'dm '=>' nm'}' .
              dc = deletes.0 + 1
              deletes.dc = strip(dd)'/'strip(dm)
              deletes.0 = dc
              if wordpos(dd,pulldsns) = 0 then do
                pulldsns = pulldsns dd
                pullmems.dd = nm
              end
              else pullmems.dd = pullmems.dd nm
            end
            else do
              parse value so.pi with . dd '=>' nd .
              dc = deletes.0 + 1
              deletes.dc = strip(dd)
              deletes.0 = dc
              if wordpos(nd,pulldsns) = 0 then
              pulldsns = pulldsns nd
            end
          end
          if word(so.pi,1) = 'delete' then
          if word(so.pi,2) = 'mode' then do
            delds = word(so.pi,4)
            dhit = 1
            if left(delds,1) = '.' then dhit = 0
            if dsnvalid(delds) = 'NO' then dhit = 0
            if dhit = 1 then do
              dc = deletes.0 + 1
              deletes.dc = delds
              deletes.0 = dc
            end
          end
          if left(so.pi,5) = 'From' then leave
          pidsn = word(so.pi,1)
          if left(pidsn,1) = '.' then iterate
          parse value pidsn with pidsn'/'pimem
          if wordpos(pidsn,pulldsns) = 0 then do
            pulldsns = pulldsns pidsn
            pullmems.pidsn = pimem
          end
          else pullmems.pidsn = pullmems.pidsn pimem
        end
        /* ------------------------------------------------- *
        | Validate all the Pulldsns and remove if not valid |
        * ------------------------------------------------- */
        do ip = words(pulldsns) to 1 by -1
          w = word(pulldsns,ip)
          if dsnvalid(w) = 'OK' then iterate
          pulldsns = delword(pulldsns,ip,1)
        end
        /* create the ispf variable with member names for
        the dataset using the dataset offset in pulldsns
        for the variable suffix */
        if qualignr = 0
        then delhlq = pdshlq
        else do
          delhlq = translate(pdshlq,' ','.')
          if qualignr /= '*' then
          delhlq = subword(delhlq,1,qualignr)
          delhlq = translate(delhlq,'.',' ')
        end
        do zz = 1 to words(pulldsns)
          zd = word(pulldsns,zz)
          zw = words(pullmems.zd)
          ldsn = "'"delhlq"."zd"'"
          x = listdsi(ldsn "dir")
          /* check if a PDSE and bypass the full Replace or if not
          a PDSE then check of more than 25% of members being
          updated and if so then nullify the member list so a full
          Replace will occur for the dataset */
          if x = 0 then
          if sysmembers /= null then
          if sysadirblk /= 'NO_LIM' then
          if sysmembers/zw < 4 then pullmems.zd = ''
          interpret 'zv'zz '= (pullmems.zd)'
          'vput zv'zz
        end
        if pulldsns /= null then do
          call Replace localrep zigirep pdshlq qualignr pulldsns
          'Verase pulldsns Both'
          call outtrap 'x.'
          if deletes.0 > 0 then do dc = 1 to deletes.0
            if pos('/',deletes.dc) = 0
            then do
              delds =  "'"pdshlq"."deletes.dc"'"
              dm.dc = delds
              Address TSO 'Delete' delds
              cmd = 'cd' localrep'/'zigirep
              cmd = cmd '&& rm' deletes.dc
            end
            else do
              parse value deletes.dc with delds'/'mem
              dm.dc = "'"pdshlq"."delds"("mem")'"
              call delete_member "'"pdshlq"."delds"'" mem
              cmd = 'cd' localrep'/'zigirep'/'delds
              cmd = cmd '&& rm' mem
              x = bpxwunix(cmd)
            end
          end
          call outtrap 'off'
          do id = 1 to deletes.0
            so.id = 'Deleted:' dm.id
          end
          so.0 = deletes.0
          se.0 = 0
          call view_std
          call update_repo_metadata
        end
        else do
          if pulled = 0 then do
            zerrsm = 'Nothing'
            zerrlm = 'Nothing to pull.'
            'setmsg msg(isrz003)'
          end
          else call update_repo_metadata
        end
        if pulled > 0 then do
          zerrsm = 'Successful.'
          zerrlm = left('Pull was a success.',76) pullmsg
          'setmsg msg(isrz003)'
        end
      end
      /* -------------------------------- *
      | Fetch Remote Repo Updates        |
      * -------------------------------- */
      When abbrev('FETCH',zcmd,2) = 1 then do
        zs1 = 'Performing the git fetch . . .'
        zs2 = 'Please standby'
        call do_popup
        cmd = 'cd' localrep'/'zigirep
        x = docmd(cmd '&& git fetch && git status')
        fetch_flag = 1
        branch = word(so.1,3)
        if so.0 > 1 then do
          branch_status = word(so.2,4)
          parse var so.2 bstat","baction
        end
        else do
          parse value '' with branch_status bstat baction
        end
      end
      /* -------------------------------- *
      | Replace z/OS datasets            |
      * -------------------------------- */
      When abbrev('REPLACE',zcmd,3) = 1 then do
        if words(save_zigirep) > 0 then do
          zerrsm = 'Invalid.'
          zerrlm = 'Replace is not supported in subdirectories.'
          'setmsg msg(isrz003)'
        end
        else do
          zcmd = null
          refa = 'NO'
          call pfshow 'off'           /* make sure pfshow is off */
          'Addpop row(4) column(12)'
          'Display Panel(zigipopr)'
          prc = rc
          'Rempop'
          call pfshow 'reset'         /* restore pfshow setting */
          if prc > 0 then refa = 'NO'
          if refa = 'YES' then do
            call Replace localrep zigirep pdshlq qualignr
            call update_repo_metadata
          end
          else do
            zerrsm = 'Canceled.'
            zerrlm = 'Replace canceled.'
            'setmsg msg(isrz003)'
          end
        end
      end
      /* -------------------------------- *
      | Rollback to a Commit Tab         |
      * -------------------------------- */
      When abbrev('ROLLBACK',zcmd,2) = 1 then do
        if words(save_zigirep) > 0 then do
          zerrsm = 'Invalid.'
          zerrlm = 'Rollback is not supported in subdirectories.'
          'setmsg msg(isrz003)'
        end
        else call do_rollback
      end
      When abbrev('STASH',zcmd,4) = 1 then call stash_it
      When zcmd = 'STASHL' then call stash_list
      /* -------------------------------- *
      | Snapshot the current repository  |
      * -------------------------------- */
      When abbrev('SNAPSHOT',zcmd,2) = 1 then do
        do forever
          parse value '' with zcmd path snaphlq gtag sans
          'display panel(zigisnap)'
          if rc > 0 then leave
          'Addpop row(4) column(10)'
          'Display Panel(zigisnpq)'
          drc = rc
          'rempop'
          if drc > 0 then leave
          if sans = 'Y' then do
            cmd = 'cd' localrep'/'zigirep
            cmd = cmd '&& git tag' gtag
            zs1 = 'Performing the git tag'
            zs2 = 'Please standby'
            call do_popup
            x = docmd(cmd)
            zs1 = 'Copying' localrep'/'zigirep
            zs2 = 'To:' path
            call do_popup
            cmd = 'cp -rp' localrep'/'zigirep path
            x = bpxwunix(cmd,,so.,se.)
            if x > 0 then call view_std 'B'
            zs1 = 'Performing the cleanup of git files'
            zs2 = 'Please standby'
            call do_popup
            cmd = 'cd' path
            cmd = cmd '&& rm .gitattributes && rm -rf .git && rm -rf .zigi'
            x = bpxwunix(cmd,,so.,se.)
            if x > 0 then call view_std 'B'
            /*  create a git log in the snapshot directory */
            cmd = 'cd' localrep'/'zigirep
            cmd = cmd "&& echo 'Git Tag for this Snapshot is:' >" ,
              path'gitlog.txt'
            cmd = cmd '&& git tag -l' gtag '>>' path'gitlog.txt'
            cmd = cmd "&& echo ' ' >>" path'gitlog.txt'
            cmd = cmd "&& echo 'Recent Git Log Entries:' >>" path'gitlog.txt'
            cmd = cmd "&& echo ' ' >>" path'gitlog.txt'
            cmd = cmd '&& git log -n 10'
            cmd = cmd '>>' path'gitlog.txt'
            x = docmd(cmd)
            if x > 0 then call view_std 'B'

            call Replace localrep zigirep snaphlq '*'
            /* now view both the omvs directory and snaphlq */
            sans = null
            'Addpop row(4) column(10)'
            'Display Panel(zigisnpr)'
            drc = rc
            'rempop'
            if drc > 0 then sans = 'N'
            if sans = 'N' then do
              zerrsm = 'Completed.'
              zerrlm = 'Snapshot completed - tag:' gtag
              'setmsg msg(isrz003)'
              leave
            end
            'SELECT PGM(ISRDSLST) PARM(UDL' path') SUSPEND'
            "SELECT PGM(ISRDSLST) PARM(DSL '"snaphlq"') SUSPEND"
            zerrsm = 'Completed.'
            zerrlm = 'Snapshot completed - tag:' gtag
            'setmsg msg(isrz003)'
            leave
          end
        end
      end
      When abbrev('TAG',zcmd,2) = 1 then do
        parse value '' with tagid tagmsg
        'addpop row(4) column(6)'
        'display panel(zigitag)'
        drc = rc
        'rempop'
        if drc = 0 then do
          if tagmsg = null then
          cmd = 'git tag' tagid
          else cmd = 'git tag -a' tagid '-m "'tagmsg'"'
          cmd = 'cd' localrep'/'zigirep '&&' cmd
          if pos('no remote',remote1) = 0
          then if zigi_offline = 0
          then cmd = cmd '&& git push origin' tagid
          cmd = cmd '&& git show' tagid
          x = docmd(cmd)
          if x = 0 then do
            zerrsm = 'Tagged.'
            zerrlm = tagid 'has been tagged to the current' ,
              'repository.'
            'setmsg msg(isrz003)'
          end
          else call view_std 'B'
        end
      end
      When abbrev('TAGLIST',zcmd,2) = 1 then call do_taglist
      /* --------------------------------------------------------- *
      | Add a PDS or a Sequential File to "Working Directory"     |
      * --------------------------------------------------------- */
      When abbrev('ADDDSN',zcmd,3) = 1 then do
        if words(save_zigirep) > 0 then do
          zerrsm = 'Invalid.'
          zerrlm = 'ADDDSN is not supported in subdirectories.'
          'setmsg msg(isrz003)'
        end
        else call Add_Dataset
      end
      /* ----------------------- *
      | Add All Untracked to Git |
      * ------------------------ */
      When abbrev('ADDALL',zcmd,4) = 1 then do
        'tbtop' rtbl
        x = debug('ADDALL started:' zigirep)
        do forever
          'tbskip' rtbl
          if rc > 0 then leave
          hit = 0
          if pos('[M',dsnstat) > 0 then hit = 1
          if pos('M]',dsnstat) > 0 then hit = 1
          if pos('Untracked',dsnstat) > 0 then hit = 1
          if hit = 0 then iterate
          call git_add
        end
        cmd = 'cd' localrep'/'zigirep
        cmd = cmd '&& git add .'
        x = docmd(cmd)
        call update_repo_metadata
        zcmd = null
        x = debug('ADDALL completed' zigirep)
      end
      /* -------------------------------- *
      | View output of git status        |
      * -------------------------------- */
      When abbrev('STATUS',zcmd,2) = 1 then call do_status
      /* -------------------------------- *
      | GIT GREP                         |
      * -------------------------------- */
      When abbrev('GREP',zcmd,2) = 1 then do
        parse value  '' with zcmd grepstr grepopt
        grepdir = localrep'/'zigirep
        gds = 'Dataset/File'
        call do_grep grepdir
      end
      /* -------------------------------- *
      | Commit to current branch         |
      * -------------------------------- */
      When abbrev('COMMIT',zcmd,3) = 1 then call do_commit
      /* -------------------------------- *
      | Add/replace remote URI (origin)  |
      * -------------------------------- */
      When abbrev('REMOTE',zcmd,3) = 1 then do
        zcmd = null
        'display panel(zigiremo)'
        if rc > 0 then do
          zerrsm = 'Canceled.'
          zerrlm = 'Remote update canceled.'
          'setmsg msg(isrz003)'
        end
        else do
          'tbmod zigirepo order'
          'TBSAVE zigirepo REPLCOPY LIBRARY('isptabl')'
          parsedURI = parseGitURI(origin)
          parse var parsedURI user host port repo
          if port /= 22 then extrabits = '-p 'port
          else extrabits = null
          cmd = 'touch 'home'/.ssh/known_hosts && '
          cmd = cmd 'if ! grep 'host
          cmd = cmd home'/.ssh/known_hosts >/dev/null;'
          cmd = cmd 'then ssh-keyscan 'extrabits' -t rsa,dsa 'host
          cmd = cmd ' 2>/dev/null >> 'home'/.ssh/known_hosts ;'
          cmd = cmd 'fi'
          x = bpxwunix(cmd,,so.,se.)
          cmd = 'cd' localrep'/'zigirep
          x = docmd(cmd '&& git remote add origin 'origin)
          call View_std 'B'
          cmd = 'cd' localrep'/'zigirep
          if zigi_offline = 0 then do
            x = docmd(cmd '&& git push -vu origin 'branch)
            call View_std 'B'
            gitcmd = 'git remote -v | sed -e "s/[[:space:]]\+/ /g"'
            x = docmd('cd 'localrep'/'zigirep' && 'gitcmd)
            if so.0 > 0 then
            remote1 = word(so.1,1)' 'word(so.1,2)
            'tbmod zigirepo order'
            'TBSAVE zigirepo REPLCOPY LIBRARY('isptabl')'
          end
          call update_repo_metadata
        end
      end
      /* -------------------------------- *
      | Select a zigiflow to work on     |
      * -------------------------------- */
      When abbrev('FLOWSEL',zcmd,5) = 1 then do
        x = check_clean()
        if x = 'NO' then do
          zedsmsg= 'Not Clean'
          zedlmsg= "Can't switch flows in dirty workspace"
          'setmsg msg(isrz001)'
        end
        else do
          call flowselect
        end
      end
      /* -------------------------------- *
      | Start a zigiflow                 |
      * -------------------------------- */
      When abbrev('FLOWGO',zcmd,5) = 1 then do
        x = check_clean()
        if x = 'NO' then do
          zedsmsg= 'Not Clean'
          zedlmsg= "Can't start flow in dirty workspace"
          'setmsg msg(isrz001)'
        end
        else do
          'Addpop row(3) column(4)'
          'Display Panel(zigifgo)'
          drc = rc
          'rempop'
          if drc > 0 then do
            zerrsm = 'Canceled.'
            zerrlm = 'FlowGo was canceled.'
            'setmsg msg(isrz003)'
          end
          else do
            cmd = 'cd' localrep'/'zigirep
            cmd = cmd || ' && git checkout master &&'
            cmd = cmd || ' git checkout -b 'flowname
            cmd = cmd || ' && git checkout -b zigiflow-'flowname
            cmd = cmd || ' && git tag 'flowname
            x = docmd(cmd)
            call Replace localrep zigirep pdshlq qualignr
            call update_repo_metadata
          end
        end
      end
      /* -------------------------------- *
      | Finish a zigiflow                |
      * -------------------------------- */
      When abbrev('FLOWEND',zcmd,5) = 1 then do
        /* what flow are we in? */
        cmd = 'cd' localrep'/'zigirep
        cmd = cmd || ' && git rev-parse --abbrev-ref HEAD'
        x = docmd(cmd)
        currbranch = so.1
        if substr(currbranch,1,8) = 'zigiflow' then do
          /* We're in a zigiflow...continue */
          x = check_clean()
          if x = 'NO' then do
            /* working dir not clean. abort */
            zedsmsg= 'Not Clean'
            zedlmsg= "Can't finish flow. Uncommited changes"
            'setmsg msg(isrz001)'
          end
          else do
            /* all looks good, let's merge to the feature */
            flowname = substr(currbranch,10)
            /* get the commit messages in */
            cmd = 'cd' localrep'/'zigirep
            cmd = cmd || ' && git log --pretty=format:%s'
            cmd = cmd || ' 'flowname'...HEAD'
            x = docmd(cmd)
            m.1 = flowname': '
            do prepcom = 1 to so.0
              cid = prepcom + 1
              m.cid = so.prepcom
            end
            m.0 = cid
            /* execute the merge */
            cmd = 'cd' localrep'/'zigirep
            cmd = cmd || ' && git checkout 'flowname
            cmd = cmd || ' && git merge --squash zigiflow-'flowname
            'Addpop row(3) column(4)'
            'Display Panel(zigifend)'
            drc = rc
            'rempop'
            if drc > 0 then do
              zerrsm = 'Canceled.'
              zerrlm = 'FlowEnd canceled.'
              'Setmsg msg(isrz003)'
            end
            else do
              x = docmd(cmd)
              /* perform the commit */
              call do_commit 'x'
              /* delete the work branch */
              cmd = 'cd' localrep'/'zigirep
              cmd = cmd || ' && git branch -D zigiflow-'flowname
              x = docmd(cmd)
              /* Get things updated */
              call update_repo_metadata
              call Replace localrep zigirep pdshlq qualignr
            end
          end
        end
        else do
          /* error for when not in zigiflow */
          zedsmsg= 'No zigiflow'
          zedlmsg= "You're not working in a zigiflow"
          'setmsg msg(isrz001)'
        end
      end
      when zcmd = 'VIEWD' then call view_debug
      Otherwise do
        zerrsm = 'Unknown'
        zerrlm = zcmd 'is not a recognized command.'
        'setmsg msg(isrz003)'
      end
    end

    if zsel = '/' then do
      'Addpop row(3) column(4)'
      'Display Panel(zigirrep)'
      'rempop'
    end

    /* flag for USS file or ZOS dataset */
    zosflg = 1
    if filetype = '(D)' then do
      if zsel = 'B' then zsel = 'S'
      if zsel = 'V' then zsel = 'S'
    end
    if zsel /= null then
    Select
      when zsel = 'D' then do
        /* -------------------------------- *
        | Show the diff for the file       |
        * -------------------------------- */
        dtest = 0
        if left(fulldsn,1) = "'" then do
          x = listdsi(fulldsn)
          if sysdsorg = 'PO' then do
            zerrlm = 'Diff does not work on Partitioned Datasets'
            zerrsm = 'Error.'
            'setmsg msg(isrz003)'
            dtest = 1
          end
        end
        else if filetype = '(D)' then do
          zerrlm = 'Diff does not work on directories'
          zerrsm = 'Error.'
          'setmsg msg(isrz003)'
          dtest = 1
        end
        if dtest = 0 then do
          cmd = 'cd' localrep'/'zigirep
          x = docmd(cmd ' && git diff 'dsn)
          if so.0 + se.0 > 0
          then call View_std 'X' 'V'
          else do
            zerrsm = 'No Diff'
            zerrlm = 'No differnce found.'
            'Setmsg msg(isrz003)'
          end
        end
      end
      When zsel = 'H' then do
        htest = 0
        if left(fulldsn,1) = "'" then do
          x = listdsi(fulldsn)
          if sysdsorg = 'PO' then do
            zerrlm = 'History does not work on Partitioned Datasets'
            zerrsm = 'Error.'
            'setmsg msg(isrz003)'
            htest = 1
          end
        end
        if htest = 0 then
        call do_history dsn
      end
      When zsel = 'B' then do
        'control display save'
        if left(fulldsn,1) = "'" then do
          x = listdsi(fulldsn)
          if sysdsorg = 'PO' then do
            'LMInit Dataid(zigdid) Dataset('fulldsn')'
            "Memlist Dataid("zigdid") Default(B)"
            "LMfree Dataid("zigdid")"
          end
          else 'Browse Dataset('fulldsn')'
        end
        else Address TSO 'Obrowse' localrep'/'zigirep'/'fulldsn
        'control display restore'
      end
      When zsel = 'V' then do
        'control display save'
        if left(fulldsn,1) = "'" then do
          x = listdsi(fulldsn)
          if sysdsorg = 'PO' then do
            'LMInit Dataid(zigdid) Dataset('fulldsn')'
            "Memlist Dataid("zigdid") Default(V)"
            "LMfree Dataid("zigdid")"
          end
          else 'View Dataset('fulldsn')'
        end
        else do
          ofile = localrep'/'zigirep'/'fulldsn
          'View File(ofile)'
        end
        'control display restore'
      end
      /* ------------------------ *
      | Rename the element in git|
      | and OMVS and z/OS        |
      * ------------------------ */
      When zsel = 'RN' then do
        newdsn = fulldsn
        fulldsnq = fulldsn
        if dsnvalid(fulldsn) = 'OK' then zos = 1
        else zos = 2
        do forever
          'Addpop row(4) column(6)'
          if zos = 1 then
          'display panel(zigirena)'
          else
          'display panel(zigireno)'
          drc = rc
          'rempop'
          if drc > 0 then leave
          if zos = 1 then do
            x = listdsi(newdsn)
          end
          else x = 1
          if x = 0 then do
            zerrsm = 'Error'
            zerrlm = newdsn 'currently exists. Select a different' ,
              'dataset name for the rename operation.'
            'setmsg msg(isrz003)'
          end
          else do
            zs1 = 'Renaming:' fulldsn
            zs2 = 'To:      ' newdsn
            call do_popup
            if left(fulldsn,1) = "'"  /* z/OS rename */
            then Address TSO 'Rename' fulldsn newdsn
            else do
              cmd = 'cd' localrep'/'zigirep
              cmd = cmd '&& mv' '"'fulldsn'" "'newdsn'"'
              x = bpxwunix(cmd,,so.,se.)
            end
            cmd = 'cd' localrep'/'zigirep
            newdsns = usssafe(newdsn)
            fulldsns = usssafe(fulldsn)
            zs1 = 'Renaming:' fulldsns
            zs2 = 'To:      ' newdsns
            call do_popup
            if left(fulldsn,1) /= "'"
            then cmd = cmd '&& git mv' '"'fulldsns'" "'newdsns'"'
            else do
              x = listdsi(newdsn)
              oldfile = remove_dsn_hlq(fulldsn)
              newfile = remove_dsn_hlq(newdsn)
              oldfiles = usssafe(oldfile)
              newfiles = usssafe(newfile)
              cmd = cmd '&& git mv' oldfiles newfiles
            end
            x = docmd(cmd)
            if sysdsorg = 'PO' then do
              zs1 = 'Renaming:' '.zigi/'oldfiles
              zs2 = 'To:      ' '.zigi/'newfiles
              call do_popup
              /* still weird with rename of statsfile? */
              cmd = 'cd' localrep'/'zigirep'/.zigi'
              cmd = cmd '&& git mv' oldfiles newfiles
              x = docmd(cmd)
            end
            if x > 0 then
            call view_std 'B'
            'tbdelete' rtbl
            fulldsn = newdsn
            dsn = newfile
            dsnstat = '[R ] Renamed in index'
            'tbadd' rtbl 'Order'
            bstat = 'Changes to be committed:'
            baction = null
            zerrsm = 'Renamed.'
            zerrlm = fulldsns 'has been renamed in zigi, git, z/OS, and OMVS.'
            'setmsg msg(isrz003)'
            leave
          end
        end
      end
      /* -------------------------------- *
      | Remove a Dataset or File         |
      | - git rm -f file                 |
      | - OMVS file just rm -f file      |
      | - PS Dataset                     |
      |   Delete dataset                 |
      |   rm -f file                     |
      | - PDS Dataset                    |
      |   Delete dataset                 |
      |   rm -frv file                   |
      |   rm -f .zigi/file (ispf stats)  |
      |    - git rm -f .zigi/file        |
      * -------------------------------- */
      When zsel = 'RM' then do
        rc = confirm_remove(fulldsn)
        if rc > 0 then do
          zerrsm = 'Canceled.'
          zerrlm = 'Removal of' fulldsn 'canceled.'
          'setmsg msg(isrz003)'
        end
        else do
          rtype = null
          localdir =  localrep'/'zigirep
          if left(fulldsn,1) /= "'" then rtype = 'OMVS'
          /* only listdsi on zOs datsets */
          if rtype = null then do
            x = listdsi(fulldsn)
            if rc = 0 & sysdsorg = 'PS' then rtype = 'PS'
            if rc = 0 & sysdsorg = 'PO' then rtype = 'PO'
          end
          if rtype = null then do
            zs1 = fulldsn 'is not recogizned.'
            zs2 = sysmsglvl2
            zs3 = null
            zs4 = 'Press Enter to continue.'
            call do_popup4p
          end
          else Select
            when rtype = 'OMVS' then do
              cmd = 'cd' localdir '&& git rm -rf' '"'usssafe(fulldsn)'"'
              cmd = cmd '&& git add -u'
              x = docmd(cmd,,so.,se.)
            end
            when rtype = 'PS' then do
              call outtrap 'x.'
              Address TSO ,
                'Delete' fulldsn
              call outtrap 'off'
              cmd = 'cd' localdir '&& git rm -rf' usssafe(dsn)
              x = docmd(cmd,,so.,se.)
            end
            when rtype = 'PO' then do
              call outtrap 'x.'
              Address TSO ,
                'Delete' fulldsn
              call outtrap 'off'
              cmd = 'cd' localdir '&& git rm -rf' usssafe(dsn)
              cmd = cmd '&& rm -f .zigi/'usssafe(dsn)
              cmd = cmd '&& rm -f' usssafe(dsn)
              x = docmd(cmd,,so.,se.)
            end
            Otherwise nop
          end
          dsnstat = '*Removed'
          'tbmod' rtbl
          zerrsm = 'Removed.'
          zerrlm = fulldsn 'has been removed from zigi, from git, and has' ,
            'been deleted from z/OS and OMVS.'
          'setmsg msg(isrz003)'
        end
      end
      /* -------------------------------- *
      | Work with a repo item            |
      * -------------------------------- */
      When zsel = 'S' & left(fulldsn,1) /= "'" then do
        zosflg = 0
        ofile = localrep'/'zigirep'/'fulldsn
        cur_date = get_fd_date(ofile)
        if filetype /= '(D)' then do
          'control display save'
          'Edit file(ofile)'
          'control display restore'
          new_date = get_fd_date(ofile)
          if cur_date /= new_date then
          if ztdsels < 2 then
          call update_repo_metadata
        end
        else do
          save_zigirep = save_zigirep zigirep
          x = debug('Entering subdirectory - save_zigirep:' save_zigirep)
          zigirep = zigirep'/'dsn
          'tbend' rtbl
          rtbl_open = 0
          call work_with_repo
          zigirep = word(save_zigirep,words(save_zigirep))
          save_zigirep = subword(save_zigirep,1,words(save_zigirep)-1)
          x = debug('Return from subdirectory - save_zigirep:' save_zigirep)
          call work_with_repo
        end
      end
      When zsel = 'S' & zosflg = 1 then do
        dhit = 1
        call outtrap 'x.'
        if sysdsn(fulldsn) /= 'OK' then dhit = 0
        call outtrap 'off'
        if dhit = 0 then do
          zerrsm = 'Error'
          zerrlm = fulldsn 'does not exist. This should not have happened.' ,
            'Somehow it may have been deleted.'
          'Setmsg msg(isrz003)'
        end
        else do
          'control display save'
          call work_with_repo_file
          'control display restore'
        end
      end
      /* -------------------------------- *
      | Add repo item to staging area    |
      * -------------------------------- */
      When zsel = 'A' then do
        call git_add
        if ztdsels < 2 then do
          call update_repo_metadata
        end
      end
      /* -------------------------------- *
      | Un-Modify entire dataset         |
      * -------------------------------- */
      When zsel = 'U' then do
        x = listdsi(fulldsn)
        if sysdsorg = 'PS' then call do_undo 'D'
        else do
          zerrsm = 'Invalid.'
          zerrlm = 'Undo is not valid on a complete PDS - Select the PDS' ,
            'and use Undo on the invididual members.'
          'setmsg msg(isrz003)'
        end
      end
      Otherwise nop
    end
  end
  if ztdsels < 2 then do
    'tbend' rtbl
    rtbl_open = 0
    call work_with_repo
  end
  return

Setup_Selective_Replace:
  parse arg ssrmsg
  parse value '' with pulldsns pullmems. deletes.
  deletes.0 = 0
  pulled = 0
  ptype = 0
  do pi = 1 to so.0
    so.pi = translate(so.pi,' ','05'x)
    if word(so.pi,1) = 'Removing' then do
      if left(w,1) = '.' then iterate
      dc = deletes.0 + 1
      deletes.dc = w
      deletes.0 = dc
    end
    if word(so.pi,1) = 'deleted:' then do
      if left(w,1) = '.' then iterate
      dc = deletes.0 + 1
      deletes.dc = w
      deletes.0 = dc
      if pos('/',w) > 0 then do
        parse value w with w'/'.
        if wordpos(w,pulldsns) = 0 then
        pulldsns = pulldsns w
      end
    end
    if pos('new file:',so.pi) > 0 then do
      w = word(so.pi,3)
      if left(w,1) = '.' then iterate
      if pos('/',w) > 0 then do
        parse value w with w'/'m
        if wordpos(w,pulldsns) = 0 then
        pulldsns = pulldsns w
        pullmems.w = pullmems.w m
      end
      else if wordpos(w,pulldsns) = 0 then
      pulldsns = pulldsns w
    end
    if pos('modified:',so.pi) > 0 then do
      w = word(so.pi,2)
      if left(w,1) = '.' then iterate
      if pos('/',w) > 0 then do
        parse value w with w'/'m
        if wordpos(w,pulldsns) = 0 then
        pulldsns = pulldsns w
        pullmems.w = pullmems.w m
      end
      else if wordpos(w,pulldsns) = 0 then
      pulldsns = pulldsns w
    end
    if ptype = 1 then do  /* status report */
      if left(so.pi,1) /= ' ' then iterate
      if pos(' changed,',so.pi) > 0 then do
        pullmsg = so.pi
        pulled = 1
        iterate
      end
      if word(so.pi,1) = 'rename' then do
        if pos('/',so.pi) > 0 then do
          parse value so.pi with . dd'/{'dm '=>' nm'}' .
          dc = deletes.0 + 1
          deletes.dc = strip(dd)'/'strip(dm)
          deletes.0 = dc
          if wordpos(dd,pulldsns) = 0 then do
            pulldsns = pulldsns dd
            pullmems.dd = nm
          end
          else pullmems.dd = pullmems.dd nm
        end
        else do
          parse value so.pi with . dd '=>' nd .
          dc = deletes.0 + 1
          deletes.dc = strip(dd)
          deletes.0 = dc
          if wordpos(nd,pulldsns) = 0 then
          pulldsns = pulldsns nd
        end
      end
      if word(so.pi,1) = 'delete' then
      if word(so.pi,2) = 'mode' then do
        delds = word(so.pi,4)
        dhit = 1
        if left(delds,1) = '.' then dhit = 0
        if dsnvalid(delds) = 'NO' then dhit = 0
        if dhit = 1 then do
          dc = deletes.0 + 1
          deletes.dc = delds
          deletes.0 = dc
        end
      end
      if left(so.pi,5) = 'From' then leave
      pidsn = word(so.pi,1)
      if left(pidsn,1) = '.' then iterate
      parse value pidsn with pidsn'/'pimem
      if wordpos(pidsn,pulldsns) = 0 then do
        pulldsns = pulldsns pidsn
        pullmems.pidsn = pimem
      end
      else pullmems.pidsn = pullmems.pidsn pimem
    end
    if ptype = 2 then do  /* stash report */
      w = word(so.pi,1)
      if left(w,1) = '.' then iterate
      if pos('/',w) = 0 then do
        if pos('=>',so.pi) = 0 then do
          if wordpos(w,pulldsns) = 0 then
          pulldsns = pulldsns w
        end
        else do
          parse value so.pi with wd '=>' w
          dc = deletes.0 + 1
          deletes.dc = wd
          deletes.0 = dc
          if wordpos(w,pulldsns) = 0 then
          pulldsns = pulldsns w
        end
      end
      else do
        parse value w with w'/'m
        if pos('{',m) > 0 then do
          parse value m with '{'dm '=>' nm'}' .
          dc = deletes.0 + 1
          deletes.dc = w'/'dm
          deletes.0 = dc
          pullmems.w = pullmems.w nm
          if wordpos(w,pulldsns) = 0 then
          pulldsns = pulldsns w
        end
        else do
          pullmems.w = pullmems.w m
          if wordpos(w,pulldsns) = 0 then
          pulldsns = pulldsns w
        end
      end
    end
  end
  call do_post_pull 'Stash Pop'
  return

Do_Post_Pull:
  if strip(pulldsns) = null then do
    zerrsm = 'Nothing'
    zerrlm = 'No updates to process for' ssrmsg
    'setmsg msg(isrz003)'
    return
  end
  /* ------------------------------------------------- *
  | Validate all the Pulldsns and remove if not valid |
  * ------------------------------------------------- */
  do ip = words(pulldsns) to 1 by -1
    w = word(pulldsns,ip)
    if dsnvalid(w) = 'OK' then iterate
    pulldsns = delword(pulldsns,ip,1)
  end
  /* create the ispf variable with member names for
  the dataset using the dataset offset in pulldsns
  for the variable suffix */
  if qualignr = 0
  then delhlq = pdshlq
  else do
    delhlq = translate(pdshlq,' ','.')
    if qualignr /= '*' then
    delhlq = subword(delhlq,1,qualignr)
    delhlq = translate(delhlq,'.',' ')
  end
  do zz = 1 to words(pulldsns)
    zd = word(pulldsns,zz)
    zw = words(pullmems.zd)
    ldsn = "'"delhlq"."zd"'"
    x = listdsi(ldsn "dir")
    /* check if a PDSE and bypass the full Replace or if not
    a PDSE then check of more than 25% of members being
    updated and if so then nullify the member list so a full
    Replace will occur for the dataset */
    if x = 0 then
    if sysmembers /= null then
    if sysadirblk /= 'NO_LIM' then
    if sysmembers/zw < 4 then pullmems.zd = ''
    interpret 'zv'zz '= (pullmems.zd)'
    'vput zv'zz
  end
  if pulldsns /= null then do
    call Replace localrep zigirep pdshlq qualignr pulldsns
    if qualignr = 0
    then delhlq = pdshlq
    else do
      delhlq = translate(pdshlq,' ','.')
      if qualignr /= '*' then
      delhlq = subword(delhlq,1,qualignr)
      delhlq = translate(delhlq,'.',' ')
    end
    'Verase pulldsns Both'
    call check_for_more_deletes
    call outtrap 'x.'
    if deletes.0 > 0 then
    do dc = 1 to deletes.0
      if pos('/',deletes.dc) = 0
      then do
        delds =  "'"delhlq"."deletes.dc"'"
        dm.dc = delds
        Address TSO 'Delete' delds
        cmd = 'cd' localrep'/'zigirep
        cmd = cmd '&& rm' deletes.dc
        x = bpxwunix(cmd,,so.,se.)
      end
      else do
        parse value deletes.dc with delds'/'mem
        mem = strip(mem)
        dm.dc = "'"delhlq"."delds"("mem")'"
        call delete_member "'"delhlq"."delds"'" mem
        cmd = 'cd' localrep'/'zigirep'/'delds
        cmd = cmd '&& rm -f' mem
        x = bpxwunix(cmd,,so.,se.)
      end
    end
    call outtrap 'off'
    do id = 1 to deletes.0
      so.id = 'Deleted:' dm.id
    end
    so.0 = deletes.0
    se.0 = 0
    call update_repo_metadata
  end
  if pulled > 0 then do
    zerrsm = 'Successful.'
    zerrlm = left(ssrmsg 'was a success.',76) pullmsg
    'setmsg msg(isrz003)'
  end
  return

  /* ----------------------- *
  | Git Add Dataset Routine |
  * ----------------------- */
git_add:
  zs1 = 'Adding' fulldsn
  zs2 = 'Making it ready to Commit'
  call do_popup
  if left(dsn,1) = "'"
  then d = usssafe(dsn)
  else d = '"'usssafe(dsn)'"'
  cmd = 'cd' localrep'/'zigirep
  drop so. se.
  x = docmd(cmd ' && git add -v 'd)
  if dsnvalid(fulldsn) = "OK" then do
    /* Only get the stats if it's a z/OS dataset
    Don't do it for the USS files
    */
    x = listdsi(fulldsn)
    if x = 0 then do
      if sysdsorg /= 'PS' then do
        statfile = remove_dsn_hlq(fulldsn)
        cmd = 'cd' localrep'/'zigirep'/.zigi/'
        stats = usssafe(statfile)
        x = zigistat(fulldsn localrep'/'zigirep'/.zigi/'stats 'S')
        x = docmd(cmd '&& git add -v 'stats)
        if x > 0 then call view_std 'B'
      end
    end
  end
  return

  /* ------------------------------------------------- *
  | Stash the current workspace                       |
  | git stash push -u -a -m "date time"               |
  | then                                              |
  | git stash show (to get the affected datasets)     |
  |                                                   |
  | generate a replace based on the affected datasets |
  * ------------------------------------------------- */
Stash_IT:
  stashmsg = null
  'addpop row(3) column(4)'
  'display panel(zigistaq)'
  drc = rc
  'rempop'
  if drc > 0 then do
    zerrsm = 'Canceled.'
    zerrlm = 'Stash canceled.'
    'setmsg msg(isrz003)'
    return
  end
  zs1 = 'Initiating git stash processing.'
  zs2 = 'Please be patient while git does its thing.'
  'addpop row(3) column(4)'
  'control display lock'
  'display panel(zigipop)'
  'rempop'
  cmd = 'cd' localrep'/'zigirep
  cmd = cmd '&& git stash push -a -u -m "'date() time() stashmsg'"'
  cmd = cmd '&& git stash show'
  x = docmd(cmd)
  call view_std 'B'
  parse value '' with deletes. pulldsns pullmems. renames.
  deletes.0 = 0
  renames.0 = 0
  dc = 0
  do i = 1 to so.0
    if pos('|',so.i) = 0 then iterate
    parse value so.i with w '|' c
    w = strip(w)
    if left(w,1) = '.' then iterate
    Select
      when pos('->',c) > 0 then do
        if pos('0 bytes',c) > 0 then do
          if pos('/',w) = 0 then do
            cmd = 'cd' localrep'/'zigirep
            cmd = cmd '&& rm' usssafe(w)
            x = bpxwunix(cmd)
          end
          else do
            parse value w with w'/'m
            cmd = 'cd' localrep'/'zigirep'/'usssafe(w)
            cmd = cmd '&& rm' usssafe(w)
            x = bpxwunix(cmd)
            if wordpos(w,pulldsns) = 0 then
            pulldsns = pulldsns w
          end
        end
      end
      when pos('{',w) > 0 then do   /* rename */
        parse value w with w'/'m
        if wordpos(w,pulldsns) = 0 then
        pulldsns = pulldsns w
        parse value m with '{'dm '=>' nm'}' .
        pullmems.w = pullmems.w nm
        rn = renames.0 + 1
        renames.rn = w'/'dm w'/'nm
        renames.0 = rn
      end
      when pos('=>',w) = 0 then do
        if pos('/',w) = 0 then
        if wordpos(w,pulldsns) = 0 then
        pulldsns = pulldsns w
        if pos('/',w) > 0 then do
          parse value w with w'/'m
          if wordpos(w,pulldsns) = 0 then
          pulldsns = pulldsns w
          pullmems.w = pullmems.w m
        end
      end
      when pos('=>',w) > 0 then do   /* Rename */
        parse value w with wd '=>' w
        w = strip(w)
        if pos('/',w) = 0 then
        if wordpos(w,pulldsns) = 0 then
        pulldsns = pulldsns w
        if pos('/',w) > 0 then do
          parse value w with w'/'m
          if wordpos(w,pulldsns) = 0 then
          pulldsns = pulldsns w
          pullmems.w = pullmems.w m
        end
        else do
          rn = renames.0 + 1
          renames.rn = wd w
          renames.0 = rn
        end
      end
      Otherwise nop
    end
  end
  call do_post_pull 'Stash Push/Save'
  do i = 1 to renames.0
    parse value renames.i with newname oldname
    if pos('/',newname) = 0 then do
      call outtrap 'x.'
      address tso ,
        'rename' Add_DSN_HLQ(oldname) Add_DSN_HLQ(newname)
      call outtrap 'off'
    end
    else do
      parse value newname with d'/'m
      newname = Add_DSN_HLQ(d'('m')')
      parse value oldname with d'/'m
      oldname = Add_DSN_HLQ(d'('m')')
      call outtrap 'x.'
      address tso ,
        'rename' Add_DSN_HLQ(oldname) Add_DSN_HLQ(newname)
      call outtrap 'off'
    end
  end
  zerrsm = 'Complete.'
  zerrlm = 'Stash Push (save) completed.'
  'setmsg msg(isrz003)'
  return

  /* ---------------------------------------------------------- *
  | Add_DSN_HLQ take the input dataset name, the active pdshlq |
  | and qualignr. Then returns the fully qualified, in quotes, |
  | dataset name.                                              |
  |                                                            |
  | Calling parm: OMVS-filename HLQ                            |
  | where HLQ is optional and will default to the active       |
  | pdshlq value.                                              |
  * ---------------------------------------------------------- */
Add_DSN_HLQ:
  arg addsn newhlq
  if newhlq = null
  then adwhlq = pdshlq
  else adwhlq = newhlq
  if qualignr = 0
  then nhlq = adwhlq
  else do
    nhlq = translate(adwhlq,' ','.')
    if qualignr /= '*' then
    nhlq = subword(nhlq,1,qualignr)
    nhlq = translate(nhlq,'.',' ')
  end
  addsn = "'"nhlq"."addsn"'"
  return addsn

Remove_DSN_HLQ:
  arg rmdsn
  rmdsn = translate(strip(rmdsn,'B',"'"),' ','.')
  if qualignr > 0 then
  rmdsn = subword(rmdsn,qualignr+1)
  rmdsn = translate(rmdsn,'.',' ')
  return rmdsn

  /* ------------------------------------------------ *
  | Process the stashl (stash list) command:         |
  | - issue git stash list to get a list of stashes  |
  | - display them in a table                        |
  | - selection commands will be:                    |
  |   BRanch - git stash branch-name stash-#   (B)   |
  |     - do a replace for affected datasets         |
  |   DIFF - git stash show # -p (then view)   (D)   |
  |   Remove - git stash drop stash-#          (R)   |
  |   POP  - git stash pop #                   (P)   |
  |   SHOW - git stash show #                  (S)   |
  | - Commands                                       |
  |   CLEAR - git stash clear  (removed ALL stashes) |
  * ------------------------------------------------ */
Stash_List:
  cmd = 'cd' localrep'/'zigirep
  cmd = cmd '&& git stash list'
  x = docmd(cmd)
  hit = 0
  do i = 1 to so.0
    if left(so.i,5) /= 'stash' then iterate
    parse value so.i  with stashid':' stashcmt
    if hit = 0 then do
      stab = 'STAB'random(9999)
      'tbcreate' stab 'names(stashid stashcmt) nowrite'
    end
    'tbadd' stab 'order'
    hit = 1
  end
  if hit = 0 then do
    zerrsm = 'Nothing.'
    zerrlm = 'No stashes have been found.'
    'setmsg msg(isrz003)'
    return
  end
  ztop = 1
  ztdsels = 0
  do forever
    zsel = null
    if ztdsels > 1 then do
      'tbdispl' stab
    end
    else do
      'tbtop' stab
      'tbskip' stab 'number(ztop)'
      'tbdispl' stab 'panel(zigistab)'
    end
    if rc > 4 then do
      'tbend' stab
      return
    end
    ztop = ztdtop
    if zcmd = 'CLEAR' then do
      'tbend' stab
      cmd = 'cd' localrep'/'zigirep
      cmd = cmd '&& git stash clear'
      x = docmd(cmd)
      zerrsm = 'Cleared.'
      zerrlm = 'All stashes have been removed from the repository.'
      'setmsg msg(isrz003)'
      return
    end
    if zsel = '/' then do
      'addpop row(3) column(4)'
      'display panel(zigirsth)'
      drc = rc
      'rempop'
      if drc > 0 then zsel = null
    end
    if zsel /= null then
    Select
      When zsel = 'B' then do   /* branch */
        bname = null
        'addpop row(3) column(4)'
        'display panel(zigistbq)'
        drc = rc
        'rempop'
        if drc > 0 then do
          zerrsm = 'Canceled.'
          zerrlm = 'Stash Branch canceled.'
          'setmsg msg(isrz003)'
        end
        else do
          cmd = 'cd' localrep'/'zigirep
          cmd = cmd '&& git stash branch' bname stashid
          x = docmd(cmd)
          call view_std 'B'
          call Setup_Selective_Replace 'Stash Branch'
        end
      end
      When zsel = 'P' then do   /* pop */
        abort = 0
        pass = 0
        stash_hit = do_stash_pop()
        if stash_hit = 1 then do
          'Addpop row(3) column(4)'
          'display panel(zigispbd)'
          'rempop'
        end
        else do
          'tbdelete' stab
          call Setup_Selective_Replace 'Stash Pop'
          zerrsm = 'Completed.'
          zerrlm = 'Stash pop processing completed for' stashid
          'setmsg msg(isrz003)'
        end
      end
      When zsel = 'R' then do   /* remove/drop */
        cmd = 'cd' localrep'/'zigirep
        cmd = cmd '&& git stash drop' stashid
        x = docmd(cmd)
        call view_std 'B'
        sid = stashid
        'tbdelete' stab
        zerrsm = 'Removed.'
        zerrlm = 'Stash entry removed.' sid
        'setmsg msg(isrz003)'
      end
      When zsel = 'S' then do   /* show */
        cmd = 'cd' localrep'/'zigirep
        cmd = cmd '&& git stash show' stashid
        x = docmd(cmd)
        call view_std 'B'
      end
      When zsel = 'D' then do   /* show diff */
        cmd = 'cd' localrep'/'zigirep
        cmd = cmd '&& git stash show -p' stashid
        x = docmd(cmd)
        call view_std 'B' 'V'
      end
      Otherwise do
        zerrsm = 'Unknown.'
        zerrlm = zsel 'is an unknown line selection - try again.'
        'setmsg msg(isrz003)'
      end
    end
  end /* end of do forever */
  return

Do_Stash_Pop:
  x = git_clean_check()
  if x > 0 then return 1
  cmd = 'cd' localrep'/'zigirep
  cmd = cmd '&& git stash pop' stashid
  zs1 = 'Initiating git stash pop processing.'
  zs2 = 'Please be patient while git does its thing.'
  'addpop row(3) column(4)'
  'control display lock'
  'display panel(zigipop)'
  'rempop'
  xrc = docmd(cmd)
  if xrc > 0 then do call view_std 'B'
  end
  Return 1

Git_Clean_Check:
  lcmd = 'cd' localrep'/'zigirep
  cmd = lcmd '&& git status'
  x = docmd(cmd)
  if so.0 = 2 then return 0
  return 1

  /* -------------------------------------- *
  | Set/Confirm/Change Repository Settings |
  | for Push and Userid Change             |
  * -------------------------------------- */
Do_Rset:
  zcmd = null
  pdshlqn = pdshlq
  hlq_change = 0
  'Addpop row(4) column(4)'
  'Display Panel(zigirset)'
  drc = rc
  'rempop'
  if drc > 0 then return
  if defcpush = 'Y' then zpush = 'Y'
  else zpush = 'N'
  if pdshlqn /= pdshlq then do
    hlq_change = 1
    hlqnw = words(translate(pdshlqn,' ','.'))
    lr = localrep'/'zigirep
    'tbtop' rtbl
    do forever
      'tbskip' rtbl
      if rc > 0 then leave
      if left(fulldsn,1)/= "'" then iterate
      oldfile = fulldsn
      newfile = strip(fulldsn,'B',"'")
      newfile = translate(newfile,' ','.')
      newfile = "'"pdshlqn'.'subword(newfile,hlqnw+1)"'"
      newfile = translate(newfile,'.',' ')
      zs1 = 'Renaming:' oldfile
      zs2 = 'To:      ' newfile
      call do_popup
      Address TSO ,
        'Rename' oldfile newfile
      oldfile = remove_dsn_hlq(oldfile)
      newfile = remove_dsn_hlq(newfile)
      if newfile /= oldfile then do
        zs1 = 'Renaming:' lr'/'oldfile
        zs2 = 'To:      ' lr'/'newfile
        call do_popup
        address syscall 'lstat' lr'/'oldfile s.
        cmd = 'cd' lr
        cmd = cmd '&& git mv' oldfile newfile
        if s.1 = 1 then do
          cmd = cmd '&& cd .zigi'
          cmd = cmd '&& git mv' oldfile newfile
        end
        x = docmd(cmd)
        if x > 0 then call view_std 'B'
      end
    end
    pdshlq = pdshlqn
  end
  'tbmod zigirepo order'
  'TBSAVE zigirepo REPLCOPY LIBRARY('isptabl')'
  if defcpush = 'Y' then zpush = 'Y'
  else zpush = 'N'
  zerrsm = 'Updated.'
  zerrlm = 'Repository default actions updates and saved.'
  'setmsg msg(isrz003)'
  if hlq_change = 1 then
  call work_with_repo
  return

  /* --------------------------------------------- *
  | Process Tag List Request with optional create |
  * --------------------------------------------- */
Get_TagList:
  cmd = 'cd' localrep'/'zigirep
  cmd = cmd "&& git for-each-ref --format" ,
    "'%(creatordate) %(refname) %(subject)'" ,
    "refs/tags"
  x = docmd(cmd)
  'TBCreate' zcrtbl 'Keys(ctag) Names(cdatetim ctitle sortdate sorttime)' ,
    'nowrite share'
  do cri = 1 to so.0
    if left(strip(so.cri),4) = 'refs' then do
      parse value so.cri with ctag ctitle
      cdatetim = 'no date'
      sortdate = 0
      sorttime = 0
    end
    else do
      parse value so.cri with day mm dd time yy gmt ctag ctitle
      cdatetim = yy mm dd time
      zd = dd mm yy
      sortdate = date('b',zd,'n')
      sorttime = left(time,2)''substr(time,4,2)
    end
    ctag = translate(ctag,' ','/')
    ctag = word(ctag,3)
    'tbadd' zcrtbl
  end
  return

  /* -------------- *
  | Do Tag Summary |
  * -------------- */
Do_TAGLIST:
  zcmd = null
  crcnt = 10
  ocrcnt = 10
  zcrtbl = 'ZT'time('s')
  call get_TAGLIST
  ztdsels = 0
  ztdtop = 1
  'tbsort' zcrtbl 'fields(sortdate,n,d,sorttime,n,d)'
  'tbtop' zcrtbl
  do forever
    zsel = null
    if ztdsels > 1
    then 'tbdispl' zcrtbl
    else do
      'tbtop' zcrtbl
      'tbskip' zcrtbl 'number('ztdtop')'
      'tbdispl' zcrtbl 'panel(zigitagt)'
    end
    if rc > 4 then leave

    if ztdsels = 0 then
    if pnsdef = 'P' then do
      if row = 0 then zcmd = 'O'
      if row > 0 then zsel = '/'
    end

    if pos('.',zcmd) > 0 then
    parse value zcmd with x'.'zcmd

    if zcmd = 'O' then do
      'Addpop row(4) column(10)'
      'Display Panel(zigiotag)'
      'rempop'
    end

    if zsel = '/' then do
      'Addpop row(3) column(4)'
      'Display Panel(zigirtag)'
      'rempop'
    end

    if row /= null then do
      'tbtop' zcrtbl
      'tbskip' zcrtbl    'number('row')'
    end

    Select
      When abbrev('Replace',word(zcmd,1),1) = 1 then do
        'tbend' zcrtbl
        call get_TAGLIST
      end
      When abbrev('ONLY',word(zcmd,1),1) = 1 then do
        if words(zcmd) = 1 then do
          'addpop row(3) column(4)'
          'display panel(zigionly)'
          drc = rc
          'rempop'
          if drc > 0 then leave
          zcmd = 'O' filter
        end
        'tbtop' zcrtbl
        ohit = 0
        fw = subword(zcmd,2)
        ztdtop = 0
        do forever
          'tbskip' zcrtbl
          if rc > 0 then
          if ohit = 1 then do
            ztdtop = 1
            leave
          end
          if rc > 0 then do
            'tbend' zcrtbl
            call get_TAGLIST
            zerrsm = 'Not Found.'
            zerrlm = fw 'not found in the rollback log.'
            'Setmsg msg(isrz003)'
            ztdtop = 1
            leave
          end
          ztdtop = ztdtop + 1
          if pos(fw,translate(ctag ctitle)) = 0 then 'tbdelete' zcrtbl
          else ohit = 1
        end
      end
      when zsel = 'X' then do
        tags = ctag
        do forever
          'tbskip' zcrtbl 'number(-1)'
          if rc > 0 then leave
          tags = ctag tags
        end
        call do_tag_extract
      end
      when zsel = 'S' then do
        cmd = 'cd' localrep'/'zigirep
        cmd = cmd '&& git show' ctag
        x = docmd(cmd)
        call view_std 'X' 'V'
      end
      when zsel = 'C' then do
        zcmd  = null
        newbr = null
        rolla = 'Cancel'
        call pfshow 'off'           /* make sure pfshow is off */
        'Addpop row(4) column(12)'
        'Display Panel(zigitagq)'
        prc = rc
        'Rempop'
        call pfshow 'reset'         /* restore pfshow setting */
        call get_branches
        bad = 0
        do bi = 1 to bl.0
          if newbr = bl.bi then bad = 1
        end
        if bad = 1 then do
          zerrsm = 'Invalid.'
          zerrlm = newbr 'branch currently exists - pick a different' ,
            'name for the branch and try again.'
          'setmsg msg(isrz003)'
          prc = 1
          newbr = null
        end
        if prc = 0 then
        if newbr /= null then do
          cmd = 'cd' localrep'/'zigirep
          drop combine.
          combine.0 = 0
          call add_combine cmd
          x = docmd(cmd ' && git checkout' ctag '-b' newbr)
          call add_combine 'git checkout' ctag '-b' newbr
          call combine_msgs
          if left(remote1,1) /= '<' then
          if zigi_offline = 0 then do
            cmd = 'cd' localrep'/'zigirep
            x = docmd(cmd ' && git push origin 'newbr)
            call add_combine 'git push origin' newbr
            branch = newb
            call combine_msgs
          end
          if combine.0 > 0 then call view_std 'C'
          call Replace localrep zigirep pdshlq qualignr
          call work_with_repo
        end
        if prc > 0 then do
          zerrsm = 'Canceled.'
          zerrlm = 'Creating a new branch from the Tag level canceled.'
          'setmsg msg(isrz003)'
          ztdsels = 1
        end
      end
      Otherwise nop
    end
  end
  'tbend' zcrtbl
  drop cr.
  return

Do_Rollback:
  zcmd = null
  crcnt = 10
  ocrcnt = 10
  zcrtbl = 'ZR'time('s')
  call do_rollback_log
  ztdsels = 0
  ztdtop = 1
  'tbtop' zcrtbl
  'tbsort' zcrtbl 'fields(gdsn,c,a)'
  do forever
    zsel = null
    if ztdsels > 1
    then 'tbdispl' zcrtbl
    else do
      'tbtop' zcrtbl
      'tbskip' zcrtbl 'number('ztdtop')'
      'tbdispl' zcrtbl 'panel(zigiroll)'
    end
    if rc > 4 then leave

    if ztdsels = 0 then
    if pnsdef = 'P' then do
      if row = 0 then zcmd = 'O'
      if row > 0 then zsel = '/'
    end

    if zsel = '/' then do
      'Addpop row(4) column(10)'
      'Display Panel(zigirrol)'
      'rempop'
    end

    if zcmd = 'O' then do
      zcmd = null
      'Addpop row(4) column(6)'
      'Display Panel(zigiorol)'
      'rempop'
    end

    if crcnt /= ocrcnt then do
      ocrcnt = crcnt
      'tbend' zcrtbl
      call do_rollback_log
      ztdtop = 1
      zsel = null
      ztdsels = 0
    end
    if row /= null then do
      'tbtop' zcrtbl
      'tbskip' zcrtbl    'number('row')'
    end
    Select
      When abbrev('REPLACE',word(zcmd,1),1) = 1 then do
        'tbend' zcrtbl
        call do_rollback_log
      end
      When abbrev('ONLY',word(zcmd,1),1) = 1 then do
        if words(zcmd) = 1 then do
          'addpop row(3) column(4)'
          'display panel(zigionly)'
          drc = rc
          'rempop'
          if drc > 0 then leave
          zcmd = 'O' filter
        end
        'tbtop' zcrtbl
        ohit = 0
        fw = subword(zcmd,2)
        ztdtop = 0
        do forever
          'tbskip' zcrtbl
          if rc > 0 then
          if ohit = 1 then do
            ztdtop = 1
            leave
          end
          if rc > 0 then do
            'tbend' zcrtbl
            call do_rollback_log
            zerrsm = 'Not Found.'
            zerrlm = fw 'not found in the rollback log.'
            'Setmsg msg(isrz003)'
            ztdtop = 1
            leave
          end
          ztdtop = ztdtop + 1
          if pos(fw,translate(ctitle)) = 0 then 'tbdelete' zcrtbl
          else ohit = 1
        end
      end
      when zsel = 'S' then do
        soo = 0
        drop so.
        do si = 1 to cr.ctag.0
          soo = soo + 1
          so.soo = cr.ctag.si
          so.0 = soo
        end
        se.0 = 0
        call view_std 'X' 'V'
      end
      when zsel = 'R' then do
        zcmd  = null
        newbr = null
        rolla = 'Cancel'
        call pfshow 'off'           /* make sure pfshow is off */
        'Addpop row(4) column(12)'
        'Display Panel(zigipoph)'
        prc = rc
        'Rempop'
        call pfshow 'reset'         /* restore pfshow setting */
        call get_branches
        bad = 0
        do bi = 1 to bl.0
          if newbr = bl.bi then bad = 1
        end
        if bad = 1 then do
          zerrsm = 'Invalid.'
          zerrlm = newbr 'branch currently exists - pick a different' ,
            'name for the branch and try again.'
          'setmsg msg(isrz003)'
          prc = 1
          newbr = null
        end
        if prc = 0 then
        if newbr /= null then do
          cmd = 'cd' localrep'/'zigirep
          drop combine.
          combine.0 = 0
          call add_combine cmd
          x = docmd(cmd ' && git checkout -b' newbr ctag)
          call add_combine 'git checkout -b' newbr ctag
          call combine_msgs
          if zigi_offline = 0 then
          if left(remote1,1) /= '<' then do
            cmd = 'cd' localrep'/'zigirep
            x = docmd(cmd ' && git push origin 'newbr)
            call add_combine 'git push origin' newbr
            branch = newb
            call combine_msgs
          end
          if combine.0 > 0 then call view_std 'C'
          call Replace localrep zigirep pdshlq qualignr
          call work_with_repo
        end
        if prc > 1 then do
          zerrsm = 'Canceled.'
          zerrlm = 'Rollback canceled.'
          'setmsg msg(isrz003)'
          ztdsels = 1
        end
        if prc > 1 then leave
      end
      Otherwise nop
    end
  end
  'tbend' zcrtbl
  drop cr.
  return

Do_Rollback_Log:
  cmd = 'cd' localdir
  x = docmd(cmd '&& git log --cc -m -n' ocrcnt)
  'TBCreate' zcrtbl 'Keys(ctag) Names(cdatetim ctitle) nowrite share'
  do cri = 1 to so.0
    if word(so.cri,1) = 'commit' then do
      ctag = word(so.cri,2)
      crc = 1
      cr.ctag.crc = so.1
      cr.ctag.0 = crc
    end
    else do
      crc = crc + 1
      if so.cri = null then so.cri = ' '
      cr.ctag.crc = so.cri
      cr.ctag.0 = crc
      if word(so.cri,1) = 'Date:' then do
        parse value so.cri with 'Date:' dow mon day time year .
        mon = wordpos(mon,'Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec')
        cdatetim = year'/'right(mon+100,2)'/'right(day+100,2) time
        ctc = cri + 2
        ctitle = strip(so.ctc)
        'tbadd' zcrtbl
      end
    end
  end
  return

  /* ------------------- *
  | Grep the repository |
  * ------------------- */
do_grep:
  parse arg grepdir
  zcmd = null
  do forever
    'display panel(zigigrep)'
    if rc > 0 then leave
    cmd = 'cd' grepdir
    x = docmd(cmd '&& git grep -i "'grepstr'"')
    select
      when x = 1 then do
        zerrsm = null
        zerrlm = 'grep search found nothing.'
        'setmsg msg(isrz003)'
      end
      when grepopt = 'R' then do
        call View_std 'B'
      end
      when grepopt = 'D' then do
        pdshlqt = translate(pdshlq,' ','.')
        if qualignr > 0 then
        pdshlqt = subword(pdshlqt,1,qualignr)
        pdshlqt = translate(pdshlqt,'.',' ')
        parse value '' with dsntbl gstat gcount
        zgreptbl = 'ZG'time('s')
        'TBCreate' zgreptbl 'Keys(gdsn) Names(gstat gcount) nowrite share'
        do si = 1 to so.0
          if left(so.si,1) = '.' then iterate
          mem = null
          parse value so.si with gdsn":" .
          if pos('/',gdsn) > 0 then do
            parse value gdsn with gdsn'/'mem':' .
            if dsnvalid(gdsn) = 'OK'
            then gdsn = gdsn'('mem')'
            else gdsn = gdsn'/'mem
          end
          gdsnt = "'"pdshlqt"."strip(gdsn)"'"
          if pos('/',gdsnt) = 0 then do
            call outtrap 'x.'
            if sysdsn(gdsnt) = 'OK' then gdsn = gdsnt
            call outtrap 'off'
          end
          if wordpos(gdsn,dsntbl) > 0
          then do
            gcount = gcount + 1
            'tbmod' zgreptbl
          end
          else do
            gcount = 1
            'tbadd' zgreptbl
            dsntbl = dsntbl gdsn
          end
        end
        ztdsels = 0
        ztdtop = 1
        file_changed = 0
        'tbtop' zgreptbl
        'tbsort' zgreptbl 'fields(gdsn,c,a)'
        do forever
          if ztdsels > 1
          then 'tbdispl' zgreptbl
          else do
            'tbtop' zgreptbl
            'tbskip' zgreptbl 'number('ztdtop')'
            'tbdispl' zgreptbl 'panel(zigigrds)'
          end
          if rc > 4 then leave

          if ztdsels = 0 then
          if pnsdef = 'P' then do
            if row = 0 then zcmd = 'O'
            if row > 0 then zsel = '/'
          end

          if zsel = null then iterate
          if row /= null then do
            'tbtop' zgreptbl
            'tbskip' zgreptbl  'number('row')'
          end
          if zsel = '/' then do
            'Addpop row(4) column(6)'
            'Display Panel(zigirgrp)'
            'rempop'
          end
          if zsel = 'S' then zsel = 'E'
          Select
            When zsel = 'B' then do
              if left(gdsn,1) = "'"
              then do
                'Browse dataset('gdsn')'
                gstat = '*Browse'
              end
              else do
                Address TSO 'OBrowse' grepdir'/'gdsn
                gstat = '*OBrowse'
              end
              'tbmod' zgreptbl
            end
            When zsel = 'E' then do
              if left(gdsn,1) = "'"
              then do
                'Edit dataset('gdsn')'
                gstat = '*Edit'
                if rc = 0 then file_changed = 1
              end
              else do
                ofile = grepdir'/'gdsn
                'Edit file(ofile)'
                gstat = '*Edit'
                if rc = 0 then file_changed = 1
              end
              'tbmod' zgreptbl
            end
            When zsel = 'V' then do
              if left(gdsn,1) = "'"
              then do
                'View dataset('gdsn')'
                gstat = '*View'
              end
              else do
                ofile = grepdir'/'gdsn
                'View file(ofile)'
                gstat = '*View'
              end
              'tbmod' zgreptbl
            end
            Otherwise nop
          end
          zsel = null
        end
        'tbend' zgreptbl
        zsel = null
        if file_changed = 1 then call update_repo_metadata
      end
      otherwise nop
    end
  end
  return

  /* ---------------------- *
  | Display the git Status |
  * ---------------------- */
Do_Status:
  zcmd = null
  cmd = 'cd' localrep'/'zigirep
  x = docmd(cmd '&& git status')
  call view_std
  return

  /* ------------------- *
  | Display the Git Log |
  * ------------------- */
Do_GitLog:
  zcmd = null
  call pfshow 'off'           /* make sure pfshow is off */
  'vget (lcnt logdfrom logdto greplog lbv incldiff) profile'
  if incldiff = null then incldiff = 'N'
  'Addpop row(4) column(6)'
  'Display Panel(zigilog)'
  drc = rc
  'Rempop'
  call pfshow 'reset'         /* restore pfshow setting */
  if drc = 0 then do
    lopts = null
    if incldiff = 'Y' then lopts = '--cc -m'
    if lcnt /= null then lopts = lopts '-n' lcnt
    if logdfrom /= null then lopts = lopts '--after="'logdfrom'"'
    if logdto   /= null then lopts = lopts '--until="'logdto'"'
    if greplog /= null then lopts = lopts '--grep='greplog '-i'
    lopts = translate(lopts,'-','/')
    cmd = 'cd' localdir' && git log' lopts
    'vput (lcnt logdfrom logdto greplog lbv incldiff) profile'
    x = docmd(cmd)
    htitle = 'GitLog Results'
    'vput (htitle)'
    if so.0 + se.0 > 1
    then call view_std 'X' lbv
    else do
      zerrsm = null
      zerrlm = 'GitLog filters resulted in an empty report.'
      'setmsg msg(isrz003)'
    end
  end
  return

  /* ----------------------------------------------- *
  | Reset USERIDs for all members                   |
  | May be called with a userid to be used and that |
  | will bypass the prompt.                         |
  * ----------------------------------------------- */
Do_Resetid:
  arg resetid
  if resetid = null then do
    call pfshow 'off'
    'Addpop row(4) column(12)'
    'display panel(zigirsid)'
    xrc = rc
    'Rempop'
    call pfshow 'reset'
  end
  else xrc = 0
  if xrc = 0 then do
    save_top = ztdtop
    'tbtop' rtll
    "LMINIT DATAID(zstats) DATASET("fulldsn")"
    "LMOPEN DATAID("zstats") OPTION(INPUT)"
    do forever
      'tbskip' rtll
      if rc > 3 then leave
      if zluser = resetid then iterate
      zluser = resetid
      'LMMSTATS DATAID('zstats') Member('mem') user('zluser')'
      'tbput' rtll
    end
    "LMClose Dataid("zstats")"
    "LMFree  Dataid("zstats")"
    ztdtop = save_top
    statfile = translate(strip(fulldsn,'B',"'"),' ','.')
    if qualignr > 0 then
    statfile = subword(statfile,qualignr+1)
    statfile = translate(statfile,'.',' ')
    x = zigistat(fulldsn localrep'/'zigirep'/.zigi/'statfile 'S')
    statfiles = usssafe(statfile)
    x = docmd('cd' localrep'/'zigirep '&& git add .zigi/'statfiles)
  end
  return

  /* ------------------------ *
  | Do the Commit Processing |
  * ------------------------ */
Do_Commit:
  arg copt
  zcmd = null
  x = debug('Starting Commit:' zigirep)
  parse value '' with tagid msg1 cmsg
  cmtab = 'zc'random(99999)
  'tbcreate' cmtab 'names(cmsg) nowrite'
  if datatype(m.0) = 'NUM' then do
    if copt /= null then do
      msg1 = m.1
      do i = 2 to m.0
        cmsg = m.i
        'tbadd' cmtab
      end
    end
    cmsg = ''
  end
  do i = 1 to 15
    'tbadd' cmtab
  end
  ctop = 0
  ztdmark = Center('Use F3 to Continue - Cancel if Title blank',79,'-')
  do forever
    if ztdsels > 1 then 'tbdispl' cmtab
    else do
      parse value '' with zsel zcmd
      'tbtop' cmtab
      'tbskip' cmtab 'number('ctop')'
      'tbdispl' cmtab 'panel(zigicom)'
    end
    if rc > 4 then leave
    if translate(zcmd) = 'CANCEL' then leave
    ctop = ztdtop
    if left(translate(zcmd),1) = 'I' then
    if words(zcmd) = 1 then
    zcmd = left(zcmd,1) substr(zcmd,2)
    if abbrev('INSERT',translate(word(zcmd,1)),1) = 1 then do
      c = word(zcmd,2)
      if c = null then c = 1
      'tbquery' cmtab 'rownum(cr)'
      'tbtop' cmtab
      'tbskip' cmtab 'number('cr')'
      cmsg = ' '
      do i = 1 to c
        'tbadd' cmtab
      end
    end
    select
      when zsel = 'D' then 'tbdelete' cmtab
      when left(zsel,1) = 'D' & length(zsel) > 1 then do
        dc = substr(zsel,2)
        if datatype(dc) /= 'NUM' then dc = 1
        do i = 1 to dc
          'tbdelete' cmtab
        end
      end
      when zsel = 'I' then do
        cmsg = ' '
        'tbadd' cmtab
      end
      when left(zsel,1) = 'I' then do
        c = substr(zsel,2,1)
        if datatype(c) /= 'NUM' then c = 1
        cmsg = ' '
        do i = 1 to c
          'tbadd' cmtab
        end
      end
      when zsel = null then
      'tbput' cmtab
      Otherwise if zsel /= null then do
        zedsmsg = 'Invalid.'
        zedlmsg = zsel 'is an invalid line selection. Try again with a valid' ,
          'line selection of I, I#,or D.'
        'setmsg msg(isrz001)'
      end
    end
  end

  drop ztdmark

  if translate(zcmd) = 'CANCEL' then msg1 = null
  if strip(msg1) = null then do
    x = debug('Commit canceled:' zigirep)
    zerrsm = 'Canceled.'
    zerrlm = 'Commit canceled due to an empty title message.'
    'setmsg msg(isrz003)'
    return
  end

  /* find last row */
  'tbbottom' cmtab
  do forever
    'tbskip' cmtab 'number(-1)'
    if rc > 0 then leave
    if strip(cmsg) /= null then leave
  end
  'tbquery' cmtab 'position(lastrow)'

  cmessage = value('msg1')
  cmsg.1 = cmessage
  cmsg.2 = left('-',length(cmsg.1),'-')
  io = 2

  'tbtop' cmtab
  if lastrow > 0 then
  do forever
    'tbskip' cmtab
    if rc > 0 then leave
    'tbquery' cmtab 'position(crp)'
    io = io + 1
    cmsg.io = strip(cmsg,'T') ' '
    if crp = lastrow then leave
  end
  cmsg.0 = io

  'tbend' cmtab

  if defruid /= null then call fixup_userids
  drop combine.
  combine.0 = 0
  /* ------------------------------- *
  | If > 1 msg line then use a file |
  * ------------------------------- */
  if io > 2 then do
    file = 'cmsg'random(999)
    fdd  = file
    if sysvar('syspref') = null
    then filem = sysvar('sysuid')'.'file
    else filem = file
    file = localrep'/'file
    file = "'"file"'"
    address tso
    'alloc f('fdd') new spa(1,1) tr recfm(f b) lrecl(72) blksize(0)',
      'ds('filem')'
    'execio * diskw' fdd '(finis stem cmsg.'
    'free  f('fdd')'
    call outtrap 'x.'
    'oput' filem file 'Text'
    'delete' filem
    call outtrap 'off'
    address ispexec
    cmd = 'cd' localrep'/'zigirep
    cmd = cmd '&& git commit -F' file
    if zigi_offline = 0 then
    if zpush = 'Y' then
    cmd = cmd '&& git push -v'
    cmd = cmd '&& rm' file
    x = docmd(cmd)
    call add_combine cmd
    call combine_msgs
  end
  /* ------------------------------------- *
  | If cmsg.0 = 2 then use commit -m msg   |
  | remove quotes for this msg             |
  * -------------------------------------- */
  else do
    cmsg.1 = translate(cmsg.1,' ',"'" '"')
    cmd = 'cd' localrep'/'zigirep
    cmd = cmd "&& git commit -vm '"cmsg.1"'"
    if zigi_offline = 0 then
    if zpush = 'Y' then
    cmd = cmd '&& git push -v'
    x = docmd(cmd)
    call add_combine cmd
    call combine_msgs
  end
  if tagid /= null then do
    parse value so.1 with '['.  ctag']' .
    cmd = 'cd' localrep'/'zigirep
    cmd = cmd '&& git tag' tagid ctag
    if zigi_offline = 0 then
    if remote1 /= '<no remote defined>' then
    cmd = cmd '&& git push origin' tagid
    cmd = cmd '&& git show' tagid
    x = docmd(cmd)
    call add_combine cmd
    call combine_msgs
  end
  if x > 0 then do
    call view_std 'C'
  end
  call update_repo_metadata
  if left(remote1,1) /= '<' then
  if zpush = 'N' then do
    zerrsm = 'Push Needed.'
    zerrlm = 'The commit has completed and a push is now required to' ,
      'update the Git remote repository.'
    if zigi_offline = 1 then
    zerrlm = zerrlm 'Which will require not being in Offline mode.'
    'setmsg msg(isrz003)'
  end
  x = debug('Commit completed:' zigirep)
  return

  /* ------------------------------------------------------ *
  | If the default userid is not null then                 |
  | 1. git status to see what pds files were modified      |
  | 2. reset the userids in all pds files                  |
  * ------------------------------------------------------ */
fixup_userids:
  cmd = 'cd' localrep'/'zigirep  '&& git status'
  x = docmd(cmd)
  dsns = null
  members. = null
  hlq = translate(pdshlq,' ','.')
  if qualignr > 0 then
  hlq = subword(hlq,1,qualignr)
  hlq = translate(hlq,'.',' ')
  do i = 1 to so.0
    if word(so.i,1) = 'Untracked' then leave
    if word(so.i,1) = 'Changes not' then leave
    if left(so.i,1) /= '05'x then iterate
    if pos('new file',so.i) = 0
    then parse value so.i with . file .
    else parse value so.i with . . file .
    if left(file,1) = '.' then iterate
    parse value file with file'/'mem .
    if wordpos(file,dsns) = 0 then do
      dsns = dsns file
    end
    members.file = members.file mem
  end
  do iw = 1 to words(dsns)
    file = word(dsns,iw)
    workdsn = "'"hlq"."file"'"
    x = listdsi(workdsn)
    if sysdsorg /= 'PO' then iterate
    "LMINIT DATAID(reset) DATASET("workdsn")"
    "LMOPEN DATAID("reset") OPTION(INPUT)"
    do im = 1 to words(members.file)
      member = word(members.file,im)
      "LMMFind DATAID("reset") Member("member") STATS(YES)"
      if rc > 7 then iterate
      if zluser /= defruid then do
        zluser = defruid
        'LMMSTATS DATAID('reset') Member('member') user('zluser')'
      end
    end
    "LMClose Dataid("reset")"
    "LMFree  Dataid("reset")"
    statfile = translate(strip(workdsn,'B',"'"),' ','.')
    if qualignr > 0 then
    statfile = subword(statfile,qualignr+1)
    statfile = translate(statfile,'.',' ')
    x = zigistat(workdsn localrep'/'zigirep'/.zigi/'statfile 'S')
    dir = localrep'/'zigirep
    statfiles = usssafe(statfile)
    x = docmd('cd' dir '&& git add .zigi/'statfiles)
    if x > 0 then
    call view_std 'B'
  end
  return

  /* ---------------------------------- *
  | Push the updates to the remote git |
  * ---------------------------------- */
Do_Push:
  arg opt
  call pop 'Pushing Updates to Remote Git'
  cmd = 'cd' localdir' && git push -v'
  x = docmd(cmd)
  if x > 0 then do
    call view_std 'B'
  end
  call update_repo_metadata
  return

  /* ----------------------------- *
  | Clone a remote repo           |
  * ----------------------------- */
Clone_Repo:
  if zigi_offline = 1 then do
    zerrsm = 'Offline.'
    zerrlm = 'Clone is not allowed when offline.'
    'Setmsg msg(isrz003)'
    return
  end
  parse value '' with pdshlq remotebr defcpush defruid zigicat
  'vget (saverep) profile'
  if saverep /= null then localrep = saverep
  do forever
    zcmd = null
    remote = null
    c_stat = 0
    cc_rc = 0
    'Display Panel(zigicc)'
    if rc > 0 then return
    if localrep = "?" then
    localrep = zigiosel()
    if strip(localrep) = null then do
      zerrsm = 'Canceled.'
      zerrlm = 'Clone canceled as OMVS directory selection canceled.'
      'Setmsg msg(isrz003)'
      return 1
    end
    saverep = localrep
    'vput (saverep) profile'
    parsedURI = parseGitURI(remote)
    parse var parsedURI guser host port zigirep '.git'
    if port /= 22 then extrabits = '-p 'port
    else extrabits = null
    /* Let's clone the remote repo... */
    zs1 = "Cloning "zigirep" by "user
    zs2 = "from "host
    call do_popup
    cmd = 'touch 'home'/.ssh/known_hosts && '
    cmd = cmd 'ssh-keyscan 'extrabits' -t rsa,dsa 'host
    cmd = cmd ' 2>&1 | sort -u - 'home'/.ssh/known_hosts >'
    cmd = cmd ' 'home'/.ssh/tmp_hosts && '
    cmd = cmd 'mv 'home'/.ssh/tmp_hosts 'home'/.ssh/known_hosts'
    x = bpxwunix(cmd,,so.,se.)
    localrep = strip(localrep,'T','/')
    x = time('r')  /* begin timer */
    cmd = 'cd 'localrep
    if remotebr = null
    then cmd = cmd ' && git clone -v 'remote
    else cmd = cmd ' && git clone -vb' remotebr remote
    x = docmd(cmd)
    if x > 0 then do
      c_stat = 1
      call view_std 'B'
      Address ISPExec
      return
    end
    /* Check to see if this is a zigi-managed repo */
    cmd = '[[ ! -d 'localrep'/'zigirep'/.zigi ]] && echo 0'
    x = bpxwunix(cmd,,so.,se.)
    if so.0 = 1 & so.1 = 0 then do
      call do_git_attributes
      'Addpop row(4) column(7)'
      'Display Panel(zigipopn)'
      'Rempop'
      'Select pgm(isptutor) parm(zigih800)'
      non_zigi = 1
    end
    else non_zigi = 0
    Address ISPExec
    if c_stat = 1 then return
    qualignr = words(translate(pdshlq,' ','.'))
    if non_zigi = 0 then
    call Replace localrep zigirep pdshlq qualignr
    zigikey = localrep'/'zigirep
    zigidate = date('n')
    sortdate = date('b')''time('s')
    'tbadd zigirepo order'
    'vget (defrsort) profile'
    'TBSort zigirepo Fields('defrsort')'
    'TBSAVE zigirepo REPLCOPY LIBRARY('isptabl')'
    leave
  end
  e_time = time("E")
  parse value e_time with ss "." uu
  numeric digits 6
  mm = ss % 60   /* get minutes integer */
  ss = ss // 60  /* get seconds integer */
  uu = uu // 100 /* get micro seconds integer */
  cltime = right(mm+100,2)':'right(ss+100,2)'.'right(uu+100,2)
  call work_with_repo
  return

  /* ---------------------------------------- *
  | Process the selected dataset (PDS or PS) |
  * ---------------------------------------- */
Work_with_repo_file:
  remc = 'NO'
  x = debug('Working with Repo File:' zigirep'/'dsn)
  x = listdsi(fulldsn)
  if sysdsorg /= 'PS' then do
    zs1 = 'Building list of library statuses....'
    zs2 = 'Patience . . .'
    call do_popup
  end
  /* Determine if the repo item is a PDS or a flat-file */
  if sysdsorg = 'PS' then do
    call edit_ps
  end
  else do
    /* Do this if it's a PDS */
    localdir = localrep'/'zigirep
    'TBCreate' rtll 'Keys(mem) Names(memstat zlcnorc' ,
      'zlmdate zlmtime zluser mtype)',
      'replace NoWrite'
    rtll_open = 1
    cmd = 'ls -laT' localrep'/'zigirep'/'usssafe(dsn)
    x = bpxwunix(cmd,,root.,re.)
    address ispexec
    "LMINIT DATAID(DID) Dataset("fulldsn")"
    "LMOPEN DATAID("did")"
    cmd = 'cd' localrep'/'zigirep
    x = docmd(cmd '&& git status --porcelain')
    dstat = dsnstat
    do i = 1 to root.0
      if left(root.i,1) = ' ' then iterate
      if word(root.i,1) = 'total' then iterate
      do
        mem = word(root.i,12)
        if zdsn.dsn /= null then do
          parse value mem with mem'.'.
          mem = translate(mem)
        end
        memstat = null
        if word(root.i,2) = 'binary'
        then mtype = 'B'
        else mtype = 'T'
        do ii = 1 to so.0
          /* see if we have this file in git status */
          stat = substr(so.ii,1,2)
          thepath = word(so.ii,2)
          parse var thepath FOLDER"/"MEMBER
          if folder /= dsn then iterate
          if mem = MEMBER then do
            memstat = porcelain(stat)
            if FOLDER = "./" & stat = "??" then
            memstat = '[??] Untracked'
            leave
          end
        end
      end
      /* ------------------------------------------------------- *
      |  The files in OMVS have some chars changed due to cp -M |
      |  So we fix the name before we save to table :)          |
      * ------------------------------------------------------- */
      /* ---------------------------------------------- *
      | No get ISPF stats for each member for the list |
      * ---------------------------------------------- */
      "LMMFind DATAID("did") Member("mem") STATS(YES)"
      'tbadd' rtll
    end
    "LMCLOSE DATAID("did")"
    "LMFREE DATAID("did")"
    'tbsort' rtll 'Fields(mem,c,a)'
    /* ---------------------------------- *
    | Process the Member list until done |
    * ---------------------------------- */
    save_rtll = 0
    save_ztdsels = ztdsels
    Do Forever
      if rtll_open = 0 then leave
      parse value '' with zsel zcmd row
      ztdsels = save_rtll
      if ztdsels > 1 then
      'tbdispl' rtll
      else do
        'tbtop' rtll
        'tbskip' rtll 'number('list_top')'
        'TBdispl' rtll 'Panel(zigilist)'
      end
      if rc > 4 then do
        if rtll_open = 1 then
        'tbend' rtll
        rtll_open = 0
        leave
      end
      /* Make sure we edit (and copy) right dataset when we have
      a prefix set */
      list_top = ztdtop
      save_rtll = ztdsels
      edsn = strip(fulldsn,'B',"'")

      if ztdsels = 0 then
      if pnsdef = 'P' then do
        if row = 0 then zcmd = 'O'
        if row > 0 then zsel = '/'
      end

      if row = 0 then zsel = null
      if row <> null then
      if row > 0 then do
        'TBTop' rtll
        'TBSkip' rtll 'Number('row')'
      end

      if pos('.',zcmd) > 0 then
      parse value zcmd with x'.'zcmd
      lstloc = null
      if zcmd = 'O' then do
        zcmd = null
        'Addpop row(4) column(6)'
        'Display Panel(zigiolst)'
        'rempop'
      end

      if zcmd /= null then
      Select
        When abbrev('ADDALL',zcmd,2) = 1 then do
          'tbtop' rtll
          x = debug('ADDALL started:' zigirep)
          do forever
            'tbskip' rtll
            if rc > 0 then leave
            hit = 0
            if pos('Untracked',memstat) > 0 then hit = 1
            if pos('[M',memstat) > 0 then hit = 1
            if pos('M]',memstat) > 0 then hit = 1
            if hit = 0 then iterate
            zs1 = 'Adding' mem
            zs2 = 'Making it ready to Commit'
            call do_popup
            call git_add_member
          end
          call git_add_member_stats
          cmd = 'cd' localrep'/'zigirep
          cmd = cmd '&& git add .'
          x = docmd(cmd)
          zcmd = null
          x = debug('ADDALL completed:' zigirep)
        end
        When abbrev('COMMIT',zcmd,3) = 1 then do
          zsel = null
          call do_commit
          call work_with_repo_file
        end
        When abbrev('GITHELP',word(zcmd,1),4) = 1 then
        Address TSO '%githelp' subword(zcmd,2)
        When abbrev('GITCMD',zcmd,4) = 1 then
        'Select cmd(%zigigcmd)'
        When abbrev('GITLOG',zcmd,2) = 1 then call do_gitlog
        When abbrev('GREP',zcmd,2) = 1 then do
          gds = 'PDS Member'
          call do_grep localdir'/'dsn
        end
        When abbrev('STATUS',zcmd,2) = 1 then call do_status
        When abbrev('RESET',zcmd,2) = 1 then call do_resetid
        When abbrev('SORT',word(zcmd,1),2) = 1 then call do_lsort
        When abbrev("LOCATE",translate(word(zcmd,1)),1) = 1 then do
          if words(zcmd) = 1 then do
            'addpop row(3) column(4)'
            'display panel(zigilocq)'
            drc = rc
            'rempop'
            if drc > 0 then leave
            zcmd = 'L' filter
          end
          mem = translate(word(zcmd,2))
          zcmd = null
          'tbtop' rtll
          'tbsarg' rtll
          'tbscan' rtll 'arglist(mem) position(scanrow) condlist(ge)'
          if rc = 0 then do
            save_top = scanrow
            zerrsm = null
            zerrlm = mem 'was found in row' scanrow + 0
            'Setmsg msg(isrz003)'
            ztdsels = 1
          end
          else do
            zerrsm = null
            zerrlm = word(zcmd,2) 'was not found'
            'Setmsg msg(isrz003)'
          end
        end
        when zcmd = 'VIEWD' then call view_debug
        Otherwise do
          zerrsm = 'Unknown'
          zerrlm = zcmd 'is not a recognized command.'
          'setmsg msg(isrz003)'
        end
        zsel = null
        zcmd = null
      end

      if zsel = '/' then do
        'Addpop row(4) column(6)'
        'Display Panel(zigirlst)'
        'rempop'
      end

      if zsel /= null then
      if zsel = 'E' then zsel = 'S'
      Select
        when zsel = 'B' then do
          'control display save'
          /* -------------------------------- *
          | Browse PDS member or PS dataset  |
          * -------------------------------- */
          x = listdsi(fulldsn)
          edsn = strip(fulldsn,'B',"'")
          r = usssafe(dsn)
          if sysdsorg = 'PS'
          then "Browse Dataset('"edsn"')"
          else "Browse Dataset('"edsn"("mem")'"
          'control display restore'
        end
        when zsel = 'V' then do
          /* -------------------------------- *
          | View PDS member or PS dataset    |
          * -------------------------------- */
          x = listdsi(fulldsn)
          edsn = strip(fulldsn,'B',"'")
          r = usssafe(dsn)
          if is_binfile(r'/'mem) = 1 then do
            zerrsm = 'Invalid'
            zerrlm = 'Unable to View a binary dataset.'
            'setmsg msg(isrz003)'
            leave
          end
          'control display save'
          if sysdsorg = 'PS'
          then "View Dataset('"edsn"')"
          else "View Dataset('"edsn"("mem")'"
          'control display restore'
        end
        when zsel = 'S' then do
          /* -------------------------------- *
          | Edit PDS member or PS dataset    |
          * -------------------------------- */
          x = listdsi(fulldsn)
          edsn = strip(fulldsn,'B',"'")
          r = usssafe(dsn)
          eok = 1
          if is_binfile(r'/'mem) = 1 then do
            zerrsm = 'Invalid'
            zerrlm = 'Unable to Edit a binary dataset.'
            'setmsg msg(isrz003)'
            eok = 0
            zsel = null
          end
          if eok = 1 then do
            'control display save'
            if sysdsorg = 'PS'
            then "Edit Dataset('"edsn"')"
            else "Edit Dataset('"edsn"("mem")'"
            erc = rc
            'control display restore'
          end
          else erc = 1
          if erc = 0 then do
            if ztdsels = 1 then do
              m = strip(mem)
              if zdsn.dsn /= null then
              rm = lower(m)'.'zdsn.dsn
              m = usssafe(m)
              e = usssafe(edsn)
              r = usssafe(dsn)
              /* Binary v1, check if PDS is a bin, then copy binary */
              if is_binfile(r'/*') = 1 then do
                binopt = '-B'
              end
              else do
                binopt = null
              end
              if is_binfile(r'/'m) = 1 then do
                binopt = '-B'
              end
              else do
                binopt = null
              end
              if sysdsorg = 'PS'
              then copycmd = "//'"e"'"
              else copycmd = "//'"e"("m")'"
              if sysdsorg = 'PO'
              then r = r'/'rm
              else r = r'/'
              copycmd = '"'copycmd'"'
              copycmd = "cp "binopt" -U -v" copycmd" "localrep"/"zigirep
              copycmd = copycmd || "/"r
              x = bpxwunix(copycmd,,so.,se.)
              if x > 0 then call view_std 'B'
              x = debug('Copy:' copycmd)
              if binopt = '-B' then do
                tagcmd = 'chtag -b 'localrep'/'zigirep'/'r
                x = bpxwunix(tagcmd,,so.,se.)
              end
              if ztdsels = 1 then do
                call update_repo_metadata
                call work_with_repo_file
              end
            end
          end
        end
        when zsel = 'H' then do
          call do_history dsn'/'mem
        end
        when zsel = 'RN' then do
          /* ------------------- *
          | reName a PDS Member |
          * ------------------- */
          do forever
            newmem = mem
            'Addpop row(4) column(6)'
            'display panel(zigirenm)'
            drc = rc
            'rempop'
            if drc > 0 then leave
            olddsn = "'"strip(fulldsn,'B',"'")"("mem")'"
            newdsn = "'"strip(fulldsn,'B',"'")"("newmem")'"
            call outtrap 'x.'
            rc = sysdsn(newdsn)
            call outtrap 'off'
            if rc = 'OK' then do
              zerrsm = 'Error'
              zerrlm = newmem 'currently exists. Select a different' ,
                'member name for the rename operation.'
              'setmsg msg(isrz003)'
            end
            else do
              Address TSO 'Rename' olddsn newdsn
              cmd = 'cd' localrep'/'zigirep'/'dsn
              cmd = usssafe(cmd)
              if zdsn.dsn /= null then do
                rnmem = lower(mem)'.'zdsn.dsn
                rnnewmem = lower(newmem)'.'zdsn.dsn
              end
              else do
                rnmem = mem
                rnnewmem = newmem
              end
              cmd = cmd '&& git mv' usssafe(rnmem) usssafe(rnnewmem)
              x = docmd(cmd)
              call view_std 'B'
              'tbdelete' rtll
              memstat = '[R ] Renamed in index'
              mem = newmem
              bstat = 'Changes to be committed:'
              baction = null
              'tbadd' rtll 'Order'
              zerrsm = 'Renamed.'
              zerrlm = mem 'has been renamed in zigi, git, z/OS, and OMVS.'
              'setmsg msg(isrz003)'
              statfile = translate(strip(fulldsn,'B',"'"),' ','.')
              if qualignr > 0 then
              statfile = subword(statfile,qualignr+1)
              statfile = translate(statfile,'.',' ')
              statfiles = usssafe(statfile)
              x = zigistat(fulldsn localrep'/'zigirep'/.zigi/'statfiles 'S')
              cmd = 'cd' localrep'/'zigirep
              x = docmd(cmd '&&git add .zigi/'statfiles)
              leave
            end
          end
        end
        when zsel = 'RM' then do
          /* --------------------------------- *
          | Remove a PDS member from the Repo |
          * --------------------------------- */
          localdir =  localrep'/'zigirep'/'dsn
          call outtrap 'x.'
          rdsn = strip(fulldsn,'B',"'")
          rdsn = "'"rdsn"("mem")'"
          rc = confirm_remove(rdsn)
          if rc = 0 then do
            Address TSO ,
              'Delete' rdsn
            call outtrap 'off'
            if zdsn.dsn /= null then do
              rmem = lower(mem)'.'zdsn.dsn
            end
              else rmem = mem
            m = usssafe(rmem)
            xldir = usssafe(localdir)
            cmd = 'cd' xldir '&& git rm -f "'usssafe(m)'"'
            x = docmd(cmd,,so.,se.)
            memstat = '*Removed'
            'tbmod' rtll
            zerrsm = 'Removed.'
            zerrlm = m 'has been removed from zigi, from git, and has' ,
              'been deleted from z/OS and OMVS.'
            'setmsg msg(isrz003)'
            statfile = translate(strip(fulldsn,'B',"'"),' ','.')
            if qualignr > 0 then
            statfile = subword(statfile,qualignr+1)
            statfile = translate(statfile,'.',' ')
            cmd = 'cd' localrep'/'zigirep'/.zigi/'
            stats = usssafe(statfile)
            x = zigistat(fulldsn localrep'/'zigirep'/.zigi/'stats 'S')
            cmd = 'cd' localrep'/'zigirep
            cmd = cmd || '&& git add -v .zigi/'stats
            x = docmd(cmd)
            if x > 0 then call view_std 'B'
          end
          else do
            zerrsm = 'Canceled.'
            zerrlm = 'Removal of' rdsn 'canceled.'
            'setmsg msg(isrz003)'
          end
        end
        when zsel = 'A' then do
          /* -------------------------------- *
          | Add member of PDS to staging area|
          * -------------------------------- */
          call git_add_member
          if ztdsels = 1 then call git_add_member_stats
        end
        when zsel = 'AB' then do
          /* --------------------------------- *
          | Add member of PDS to staging area |
          | as a binary member and copy/tag it|
          * --------------------------------- */
          dsna = translate(strip(fulldsn,'B',"'"),' ','.')
          add_count = 0
          dsnapfx = pdshlq
          sa_dsna = dsna
          dsna = strip(fulldsn,'B',"'")'('mem')'
          call do_add_copy 'binary'
          parse value dsn with dsn'/'mem
          dsna = sa_dsna
          call git_add_member
          if ztdsels < 2 then do
            call get_binfiles
            call git_add_member_stats
          end
        end
        when zsel = 'U' then call do_undo 'M'
        when zsel = 'D' then do
          /* -------------------------------- *
          | Show the diff for the member     |
          * -------------------------------- */
          d = usssafe(dsn)
          cmd = 'cd' localrep'/'zigirep'/'d
          m = './'usssafe(mem)
          x = docmd(cmd ' && git diff 'm)
          if so.0 + se.0 > 0
          then call View_std 'X' 'V'
          else do
            zerrsm = 'No Diff'
            zerrlm = 'No differnce found.'
            'Setmsg msg(isrz003)'
          end
        end
        otherwise nop
      end
    end
  end
  ztdsels = save_ztdsels
  zsel = null
  return

  /* -------------------------------- *
  | Add Member to Git for Committing |
  * -------------------------------- */
Git_Add_Member:
  d = usssafe(dsn)
  cmd = 'cd' localrep'/'zigirep
  x = docmd(cmd ' && git add -v 'd'/'usssafe(mem))
  return

  /* ---------------------------------- *
  | Update stats file after member add |
  * ---------------------------------- */
Git_Add_Member_Stats:
  statfile = translate(strip(fulldsn,'B',"'"),' ','.')
  x = debug('Add member stats:' statfile)
  if qualignr > 0 then
  statfile = subword(statfile,qualignr+1)
  statfile = translate(statfile,'.',' ')
  cmd = 'cd' localrep'/'zigirep'/.zigi/'
  statfiles = usssafe(statfile)
  x = cmd '&& git add -v 'statfiles
  x = docmd(cmd)
  x = zigistat(fulldsn ,
    localrep'/'zigirep'/.zigi/'statfiles 'S')
  statfiles = usssafe(statfile)
  x = docmd('cd' localrep'/'zigirep '&& git add .zigi/'statfiles)
  call work_with_repo_file
  x = debug('Add member stats completed.')
  return

  /* ------------------------- *
  | Copy a PS dataset to OMVS |
  * ------------------------- */
Edit_PS:
  arg noedit
  edsn = strip(fulldsn,'B',"'")
  /* Do this if it's a regular file (sequential in z/OS) */
  if is_binfile(dsn) = 1 then do
    zerrsm = 'Invalid'
    zerrlm = 'Unable to Edit a binary dataset.'
    'setmsg msg(isrz003)'
    return
  end
  "Edit Dataset('"edsn"')"
  /* so after the edit, we should update it to working directory */
  if rc = 0 then do
    edsn = usssafe(edsn)
    copcm = "//'"edsn"'"
    /* -M was replaced with -v in all CP commands */
    copcm = 'cp -U -v "'copcm'" 'localrep'/'zigirep'/'usssafe(dsn)
    x = bpxwunix(copcm,,so.,se.)
    if x > 0 then call view_std 'B'
    if ztdsels < 2 then
    call update_repo_metadata
  end
  return

  /* ------------------------------- *
  | Sort the member list (zigilist) |
  * ------------------------------- */
Do_LSort:
  parse value zcmd with x sort_field sort_order sf sc
  save_lsorto
  zcmd = null
  if sort_field = null then do
    call pfshow 'off'           /* make sure pfshow is off */
    'Addpop row(4) column(6)'
    'Display Panel(zigilsrt)'
    drc = rc
    'Rempop'
    if drc > 0 then return
    sort_field = sf
    sort_order = sc
    call pfshow 'reset'         /* restore pfshow setting */
  end
  if sort_order = null then
  if save_lsorto = null then do
    sort_order = 'A'
  end
  else do
    if save_lsorto = 'A' then sort_order = 'D'
    else sort_order = 'A'
  end
  save_lsorto = sort_order
  /* support abbreviations in field names */
  Select
    When abbrev('MEMBER',sort_field,2) = 1 then sort_field = 'MEMBER'
    When abbrev('STATUS',sort_field,2) = 1 then sort_field = 'STATUS'
    When abbrev('SIZE',sort_field,2)   = 1 then sort_field = 'SIZE'
    When abbrev('DATE',sort_field,2)   = 1 then sort_field = 'DATE'
    When abbrev('TIME',sort_field,2)   = 1 then sort_field = 'TIME'
    When abbrev('USERID',sort_field,2) = 1 then sort_field = 'USERID'
    Otherwise nop
  end
  /* 1st validate sort_field */
  if wordpos(sort_field,'MEMBER STATUS SIZE DATE TIME USERID') = 0
  then do
    zerrsm = 'Invalid.'
    zerrlm = sort_field 'is an invalid sort field. Valid names are:' ,
      'MEMBER STATUS SIZE DATE TIME USERID'
    'Setmsg msg(isrz003)'
    return
  end
  /* 2nd validate the sort_order A or D */
  if pos(sort_order,'AD') = 0 then do
    zerrsm = 'Invalid.'
    zerrlm = sort_order 'is an invalid sort order. Must be either' ,
      'A for ascending or D for descending.'
    'Setmsg msg(isrz003)'
    return
  end
  sw = wordpos(sort_field,'MEMBER STATUS SIZE DATE TIME USERID')
  sort_field = subword('mem memstat zlcnorc zlmdate zlmtime zluser',sw,1)
  if sw = 3 then sort_type = 'N'
  else sort_type = 'C'
  if sort_field /= zlmdate
  then 'tbsort' rtll 'fields('sort_field','sort_type','sort_order')'
  else 'tbsort' rtll 'fields('sort_field','sort_type','sort_order',' ,
    'zlmtime,'sort_type','sort_order')'
  return

  /* ----------------------------- *
  | Replace z/OS side of repo     |
  * ----------------------------- */
Replace:
  parse arg localrep zigirep pdshlq qualignr pulldsns
  zs1 = "Replacing from repository"
  zs2 = "   OMVS -> z/OS      "
  call do_popup

  ckotdir = localrep'/'zigirep
  if qualignr /= '*' then
  if datatype(qualignr) /= 'NUM' then qualignr = 0
  if qualignr = 0
  then ckothlq = pdshlq
  else do
    ckothlq = translate(pdshlq,' ','.')
    if qualignr /= '*' then
    ckothlq = subword(ckothlq,1,qualignr)
    ckothlq = translate(ckothlq,'.',' ')
  end
  ckotqual = qualignr
  'vput (ckotdir ckothlq pulldsns ckotqual)'
  'Select cmd(%zigickot)'
  return

  /* ----------------------------- *
  | Branch management             |
  * ----------------------------- */
Branch_it:
  if rtbb_open = 1 then 'tbend' rtbb
  'TBCreate' rtbb 'keys(bname) Names(brstatus) Replace NoWrite'
  rtbb_open = 1
  localdir = localrep'/'zigirep
  if zigi_offline = 0 then do
    cmd = ' && git remote prune origin > /dev/null 2>&1 && git branch -a'
    x = docmd('cd 'localdir cmd)
  end
  else parse value '0 0' with so.0 se.0
  if so.0 + se.0 = 0 then do
    cmd = '&& git branch -a'
    x = docmd('cd 'localdir cmd)
  end
  bl. = null
  bl.0 = 0
  do i = 1 to so.0
    b1 = strip(so.i,'B')
    if pos('/',b1) > 0 then do
      /* this is a remote branch we (maybe) have never checked out */
      seen_this_branch = 0
      parse var b1 remotes'/'origin'/'bname zooi
      bname = strip(bname)
      do ii = 1 to bl.0
        if bl.ii = bname then seen_this_branch = 1
      end
      if seen_this_branch = 1 then do
        sbname = bname
        'tbtop' rtbb
        do forever
          'tbskip' rtbb
          if rc > 0 then leave
          if sbname = bname then do
            brstatus = 'Local/Remote'
            'tbmod' rtbb
            leave
          end
        end
      end
      /* but only add it to table if we haven't yet */
      if seen_this_branch = 0 then do
        if bname <> branch & bname <> "HEAD" then do
          ni = bl.0 + 1
          bl.ni = bname
          bl.0 = ni
          brstatus = 'Remote'
          'tbadd' rtbb
        end
      end
    end
    else do
      /* this is already a local branch */
      if pos('*',b1) = 0 then do
        /* Add it to the table if it's not the current (*) branch */
        bname = strip(so.i)
        ni = bl.0 + 1
        bl.ni = b1
        bl.0 = ni
        brstatus = 'Local'
        'tbadd' rtbb
      end
    end
  end
  'tbsort' rtbb 'fields(bname,c,a)'
  'tbtop' rtbb
  save_btop = 0
  do forever
    zcmd = null
    cc_rc = 0
    newb = null
    zsel = null
    if save_btop > 0 then do
      'tbtop' rtbb
      'tbskip' rtbb 'number('save_btop')'
    end
    'tbdispl' rtbb 'panel(zigibra)'
    if rc > 4 then leave
    save_btop = ztdtop
    if abbrev('GITHELP',word(zcmd,1),4) = 1 then
    Address TSO '%githelp' subword(zcmd,2)
    if newb <> null then do
      /* ----------------------------- *
      | Create this new branch, switch|
      * ----------------------------- */
      bad = 0
      do bi = 1 to bl.0
        if newb = bl.bi then bad = 1
      end
      if bad = 1 then do
        zerrsm = 'Invalid.'
        zerrlm = newb 'branch already exists - select a new name.'
        'setmsg msg(isrz003)'
      end
      else do
        localdir = localrep'/'zigirep
        x = docmd('cd 'localdir' && git checkout -b 'newb)
        /* TODO only do this when there is a remote? */
        if zigi_offline = 0 then
        x = docmd('cd 'localdir' && git push -u origin 'newb)
        branch = newb
        leave
      end
    end
    /* ----------------------------- *
    | Checkout the selected bname   |
    * ----------------------------- */
    if zsel = "C" then do
      x = docmd('cd 'localdir' && git status --porcelain')
      if so.0 > 0 then do
        zs1 = 'Cannot checkout branch.'
        zs2 = so.1
        call pfshow 'off'           /* make sure pfshow is off */
        'Addpop row(4) column(12)'
        'Display Panel(zigipop)'
        'Rempop'
        call pfshow 'reset'         /* restore pfshow setting */
        call view_std 'B'
      end
      else do
        x = docmd('cd 'localdir' && git checkout 'bname)
        call Replace localrep zigirep pdshlq qualignr
        call update_repo_metadata
        branch = bname
      end
      leave
    end
    if zsel = "D" then do
      if brstatus = 'Remote' then do
        zerrsm = 'Invalid.'
        zerrlm = 'Unable to delete a remote only branch.' ,
          'That can only be done at the remote repository.'
        'setmsg msg(isrz003)'
      end
      else do
        'Addpop row(4) column(6)'
        'display panel(zigibrdq)'
        drc = rc
        'Rempop'
        if ans = 'N' then drc = 4
        if drc > 0 then do
          ans = 'N'
          zerrsm = 'Canceled.'
          zerrlm = 'Branch delete canceled.'
          'setmsg msg(isrz003)'
        end
        if ans = 'Y' then do
          x = docmd('cd 'localdir' && git branch -D 'bname)
          if pos('Remote',brstatus) = 0 then do
            'tbdelete' rtbb
            zerrsm = 'Deleted.'
            zerrlm = 'Branch 'bname' succesfully deleted'
            'Setmsg msg(isrz003)'
          end
          else do
            zerrsm = 'Local Deleted.'
            zerrlm = 'Branch 'bname' succesfully deleted from the local' ,
              'repository but remains on the remote.'
            'Setmsg msg(isrz003)'
            brstatus = 'Remote'
            'tbmod' rtbb
          end
        end
      end
    end
  end
  'tbend' rtbb
  rtbb_open = 0
  ztdsels = 0
  return

  /* ----------------------------- *
  | Merging things...             |
  * ----------------------------- */
Merge_it:
  'tbquery' rtbm
  if rc = 0 then 'tbend' rtbm
  'TBCreate' rtbm 'keys(bname) Names(brstatus) Replace NoWrite'
  localdir = localrep'/'zigirep
  zsel = null
  if zigi_offline = 0 then do
    cmd = ' && git remote prune origin > /dev/null 2>&1 && git branch -a'
    x = docmd('cd 'localdir cmd)
  end
  else parse value '0 0' with so.0 se.0
  if so.0 + se.0 = 0 then do
    cmd = '&& git branch -a'
    x = docmd('cd 'localdir cmd)
  end
  bl. = null
  bl.0 = 0
  do i = 1 to so.0
    b1 = strip(so.i,'B')
    if pos('/',b1) > 0 then do
      /* this is a remote branch we (maybe) have never checked out */
      seen_this_branch = 0
      parse var b1 remotes'/'origin'/'bname zooi
      bname = strip(bname)
      do ii = 1 to bl.0
        if bl.ii = bname then seen_this_branch = 1
      end
      if seen_this_branch = 1 then do
        sbname = bname
        'tbtop' rtbm
        do forever
          'tbskip' rtbm
          if rc > 0 then leave
          if sbname = bname then do
            brstatus = 'Local/Remote'
            'tbmod' rtbm
            leave
          end
        end
      end
      /* but only add it to table if we haven't yet */
      if seen_this_branch = 0 then do
        if bname <> branch & bname <> "HEAD" then do
          ni = bl.0 + 1
          bl.ni = bname
          bl.0 = ni
          brstatus = 'Remote'
          'tbadd' rtbm
        end
      end
    end
    else do
      /* this is already a local branch */
      if pos('*',b1) = 0 then do
        /* Add it to the table if it's not the current (*) branch */
        bname = strip(so.i)
        ni = bl.0 + 1
        bl.ni = b1
        bl.0 = ni
        brstatus = 'Local'
        'tbadd' rtbm
      end
    end
  end
  'tbsort' rtbm 'fields(bname,c,a)'
  'tbtop' rtbm
  save_btop = 0
  do forever
    zcmd = null
    cc_rc = 0
    newb = null
    zsel = null
    if save_btop > 0 then do
      'tbtop' rtbm
      'tbskip' rtbm 'number('save_btop')'
    end
    'tbdispl' rtbm 'panel(zigimer)'
    if rc > 4 then leave
    save_btop = ztdtop
    if abbrev('GITHELP',word(zcmd,1),4) = 1 then
    Address TSO '%githelp' subword(zcmd,2)
    /* ----------------------------- *
    | Checkout the selected bname   |
    * ----------------------------- */
    if zsel = "M" then do
      tmp_bname = 'trial'RANDOM(9999)
      cmd = 'cd 'localdir' && git merge --no-commit --no-ff'
      cmd = cmd || ' refs/heads/'bname
      x = docmd(cmd)
      if so.1 = 'Already up-to-date.' then do
        /* No need to merge! */
        zs1 = "Merge not needed"
        zs2 = "Branches are the same"
        zs3 = ""
        zs4 = "Press Enter/F3 to continue"
        call do_popup4p
        leave
      end
      parse var se.1 "Automatic merge went well; stopped" rest
      if rest /= "" then do
        /* No issues. Commit the merge then execute a Replace */
        /* Maybe popup a panel here for the commit message? */
        x = docmd('cd 'localdir' && git commit -m "Merge 'bname'"')
        call Replace localrep zigirep pdshlq qualignr
        call update_repo_metadata
      end
      else do
        /* Merge went fubar */
        zcmd = null
        'Addpop row(4) column(6)'
        'Display Panel(zigimrgq)'
        drc = rc
        'Rempop'
        if drc > 0 then zcmd = 3
        if zcmd = 3 then do
          cmd = 'cd' localdir
          cmd = cmd '&& git merge --abort'
          x = docmd(cmd)
          zerrsm = 'Canceled.'
          zerrlm = "Merge canceled and git merge --abort executed."
          'setmsg msg(isrz003)'
        end
        mrgtype = zcmd
        if zcmd = 2 then zcmd = 1
        /* --------------------------------------------------------------- *
        | If option 1 then setup for the user to resolve the conflicts    |
        | using ispf edit.                                                |
        |                                                                 |
        | 1. parse merge conflict messages for the merge files            |
        | 2. if a file is a PDS then process then add the file name       |
        |    to fix_stats for later and edit to retain only merge records |
        | 3. display the files for selection and correction               |
        | 4. if ALL files have been resolved (edit saved) then            |
        |    process any fix_stats files:                                 |
        |    - run zigistat 'S'                                           |
        |    - git add it                                                 |
        |                                                                 |
        | If option 1 then don't do any processing just display the       |
        | files for editing and manual resolution.  But still fix the     |
        | ISPF stats files                                                |
        * --------------------------------------------------------------- */
        if zcmd = 1 then do
          pdshlqt = translate(pdshlq,' ','.')
          if qualignr > 0 then
          pdshlqt = subword(pdshlqt,1,qualignr)
          pdshlqt = translate(pdshlqt,'.',' ')
          parse value '' with dsntbl mstat
          zmergtbl = 'ZG'time('s')
          zmcount = 0
          fix_stats = null
          'TBCreate' zmergtbl 'Keys(mdsn)' ,
            'Names(mfile mstat) nowrite share'
          mrgdir = localrep'/'zigirep
          do si = 1 to so.0
            mem = null
            if word(so.si,1) /= 'CONFLICT' then iterate
            mrgm = 'Merge conflict in'
            parse value so.si with x (mrgm) mdsn .
            mfile = mrgdir'/'mdsn
            if mdsn /= '.zigi/dsn' then
            if left(mdsn,6) = '.zigi/' then do
              if pos(mfile,fix_stats) = 0 then
              fix_stats = fix_stats mfile
              parm = 'M'
              'vput (mrgdir mdsn mfile) shared'
              'Edit file(mfile) macro(zigimrgm) parm(parm)'
              iterate
            end
            if wordpos(mdsn,dsntbl) > 0
            then do
              'tbmod' zmergtbl
            end
            else do
              'tbadd' zmergtbl
              dsntbl = dsntbl mdsn
              zmcount = zmcount + 1
            end
          end
          ztdsels = 0
          ztdtop = 1
          zsel = null
          file_changed = 0
          drop so. se.
          'tbtop' zmergtbl
          'tbsort' zmergtbl 'fields(mdsn,c,a)'
          do forever
            if ztdsels > 1
            then 'tbdispl' zmergtbl
            else do
              'tbtop' zmergtbl
              'tbskip' zmergtbl 'number('ztdtop')'
              'tbdispl' zmergtbl 'panel(zigimrds)'
            end
            if rc > 4 then leave
            if zsel = null then iterate
            if row /= null then do
              'tbtop' zmergtbl
              'tbskip' zmergtbl  'number('row')'
            end
            if zsel = '/' then do
              'Addpop row(4) column(6)'
              'Display Panel(zigirmrg)'
              'rempop'
            end

            if ztdsels = 0 then
            if pnsdef = 'P' then do
              if row = 0 then zcmd = 'O'
              if row > 0 then zsel = '/'
            end

            if zsel = 'S' then zsel = 'E'
            Select
              When zsel = 'B' then do
                Address TSO 'OBrowse' mrgdir'/'mdsn
                mstat = '*OBrowse'
                'tbmod' zmergtbl
              end
              When zsel = 'E' then do
                ofile = mrgdir'/'mdsn
                if mrgtype = 1 then do
                  mrgfile = '/tmp/'userid()'.merge'
                  md = usssafe(mrgdir)
                  mdsns = usssafe(mdsn)
                  cmd = 'cd' md '&& cp' mdsns mrgfile
                  x = bpxwunix(cmd)
                  parm = 'M'
                  'vput (mrgdir mdsn mrgfile) shared'
                  'Edit file(mrgfile) macro(zigimrgm) parm(parm)'
                  'Edit file(ofile) macro(zigimrgm)'
                  mstat = '*Edit'
                end
                else do
                  'Edit file(ofile) panel(zigiedit) macro(zigiem)'
                end
                if rc = 0 then do
                  file_changed = 1
                  zmcount = zmcount - 1
                  cmd = 'cd' mrgdir '&& git add' mdsn
                  x = docmd(cmd)
                  mstat = '*Updated'
                end
                'tbmod' zmergtbl
                cmd = 'rm' mrgfile
                x = bpxwunix(cmd)
              end
              When zsel = 'V' then do
                ofile = mrgdir'/'mdsn
                'View file(ofile)'
                mstat = '*View'
                'tbmod' zmergtbl
              end
              Otherwise nop
            end
            zsel = null
          end
          'tbend' zmergtbl
          zsel = null
          if zmcount = 0 then do
            if fix_stats /= null
            then do fs = 1 to words(fix_stats)
              sfile = usssafe(word(fix_stats,fs))
              pds = usssafe(pdshlqt'.'substr(sfile,7))
              Address TSO '%zigistat' "'"pds"'" sfile 'S'
              x = docmd('cd' localrep'/'zigirep '&& git add' sfile)
            end
            cmd = 'cd' mrgdir '&& git commit -m "Resolve merge conflicts"'
            x = docmd(cmd)
            if x > 0 then
            call view_std 'B'
            call Replace localrep zigirep pdshlq qualignr
            call update_repo_metadata
          end
          else do
            zs1 = 'Not all conflicts have been resolved.'
            zs2 = 'Merge request is now aborted.'
            zs3 = null
            zs4 = 'Press Enter to exit merge.'
            call do_popup4p
            cmd = 'cd' localdir
            cmd = cmd  '&& git merge --abort'
            x = docmd(cmd)
            call view_std 'B'
          end
        end
      end
      leave
    end
  end
  'tbend' rtbm
  ztdsels = 1
  zsel = null
  return

  /* --------------------------------------- *
  | Delete a PDS Member using ISPF Services |
  * --------------------------------------- */
Delete_member: Procedure
  arg dsn mem
  "LMInit Dataid(test) dataset("dsn") enq(shrw)"
  "LMOpen Dataid("test") Option(Output)"
  "LMMDel  Dataid("test") Member("mem") NoEnq"
  "LMClose Dataid("test")"
  "LMFree Dataid("test")"
  return

  /* ------------------------ *
  | Get the branches for use |
  * ------------------------ */
get_branches:
  localdir = localrep'/'zigirep
  if zigi_offline = 0 then do
    cmd = ' && git remote prune origin > /dev/null 2>&1 && git branch -a'
    x = docmd('cd 'localdir cmd)
  end
  else parse value '0 0' with so.0 se.0
  if so.0 + se.0 = 0 then do
    cmd = '&& git branch -a'
    x = docmd('cd 'localdir cmd)
  end
  bl. = null
  bc = 0
  do i = 1 to so.0
    branch = strip(so.i)
    if word(branch,1) = '*' then branch = word(branch,2)
    if pos('->',branch) > 0 then iterate
    if pos('/',branch) > 0 then do
      branch = translate(branch,' ','/')
      branch = word(branch,words(branch))
    end
    bc = bc + 1
    bl.bc = branch
  end
  bl.0 = bc
  return

  /* ----------------------- *
  | Create a new Repository |
  * ----------------------- */
Create_Repo:
  'vget (saverep) profile'
  if saverep /= null then localrep = saverep
  do forever
    parse value '' with zerrsm zcmd zigirep cc_rc pdshlq ,
      defcpush defruid qualignr zigicat encoding
    'Display Panel(ziginew)'
    if rc > 0 then return 8
    if localrep = '?' then
    localrep = zigiosel()
    if localrep = null then do
      zerrsm = 'Canceled.'
      zerrlm = 'Create canceled as OMVS directory selection canceled.'
      'setmsg msg(isrz003)'
      return 1
    end
    localrep = strip(localrep,'T','/')
    /* ---------------------------------------------------- *
    | We do some basic git repo setup here...              |
    | Fair warning, it's going to be very verbose.         |
    | But that eases feature adding :)                     |
    * ---------------------------------------------------- */
    /* encoding given? */
    if encoding = null then encoding = 'ibm-1047'
    /* test if localrep is present */
    cmd = '[[ -d 'localrep' ]] && echo 1'
    x = bpxwunix(cmd,,so.,se.)
    if so.0 = 1 & so.1 = 1 then do
      /* ok, localrep is there. better not have zigirep */
      cmd = '[[ -d 'localrep'/'zigirep' ]] && echo 1'
      x = bpxwunix(cmd,,so.,se.)
      if so.0 = 1 & so.1 = 1 then do
        zerrsm = "Failed."
        zerrlm = "Error: "localrep"/"zigirep" exists and must not."
        'setmsg msg(isrz003)'
        leave
      end
    end
    saverep = localrep
    'vput (saverep) profile'
    /* If we made it here, we can freely git init */
    zs1 = 'Creating your repository'
    zs2 = 'Please standby'
    call do_popup
    x = docmd('cd 'localrep' && git init 'zigirep)
    call do_git_attributes

    Address ISPExec
    zigikey = localrep'/'zigirep
    zigidate = date('n')
    sortdate = date('b')''time('s')
    'tbadd zigirepo order'
    zpush = defcpush
    'vget (defrsort) profile'
    'TBSort zigirepo Fields('defrsort')'
    'TBSAVE zigirepo REPLCOPY LIBRARY('isptabl')'
    leave
  end
  return 0

do_git_attributes:
  /* The git repo is initialized. Time to stick a
  .gitattributes (ASCII) in there */
  cmd = 'ls' localrep'/'zigirep'/.gitattributes'
  x = bpxwunix(cmd,,so.,se.)
  if so.0 = 1 then return
  call syscalls 'ON'
  address syscall
  path = localrep"/"zigirep"/.ga"
  'open' path,
    O_rdwr+O_creat+O_trunc,
    660
  if retval = -1 then do
    Address ISPExec
    zs1 = "Something bad when creating .gitattributes. Make errormsg"
    zs4 = 'Press F3 to close this popup and exit.'
    parse value '' with zs2 zs3
    call do_popup4
    return
  end
  fd = retval  /* as I think it's weird to write to a retval lol */
  call write_fd ,
    "# This .gitattributes file is autogenerated with zigi" ver
  call write_fd ,
    "*   git-encoding=iso8859-1 zos-working-tree-encoding="encoding
  ga3a = ".gitattributes    "
  ga3b = "git-encoding=iso8859-1 zos-working-tree-encoding=iso8859-1"
  ga3  = ga3a || ga3b
  call write_fd ga3
  ga4a = ".gitignore        "
  ga4b = "git-encoding=iso8859-1 zos-working-tree-encoding=iso8859-1"
  ga4  = ga4a || ga4b
  call write_fd  ga4
  binaries = '*.docm *.docx *.doc *.dotx *.pdf *.epub *.mobi *.azw3' ,
    '*.jpg *.jpeg *.png *.gif *.zip *.gzip *.tz *.z *.Z *.pax' ,
    '*.ppt *.pptx *.xls *.xlsx *.xlsm *.obj *.bin'
  do gai = 1 to words(binaries)
    ga = word(binaries,gai) 'binary'
    call write_fd ga
  end
  'close' fd
  call syscalls 'OFF'
  /* -------------------- .gitattributes written ----------- */
  /*             UNFORTUNATELY, IT'S IN EBCDIC :(            */
  /* ------------------------------------------------------- */
  reporoot = localrep'/'zigirep'/'
  /* convert to iso8859-1 */
  cmd = 'cd 'localrep'/'zigirep' && '
  cmd = cmd 'iconv -f ibm-1047 -t iso8859-1 .ga'
  cmd = cmd ' > .gitattributes'
  x = bpxwunix(cmd,,so.,se.)

  /* delete the .ga file */
  cmd = 'cd 'localrep'/'zigirep' && rm -rf .ga'
  x = bpxwunix(cmd,,so.,se.)

  /* tag it and bag it */
  cmd = 'cd 'localrep'/'zigirep' && '
  cmd = cmd 'chtag -tc iso8859-1 .gitattributes'
  x = bpxwunix(cmd,,so.,se.)

  /* Create the .zigi folder in the repo and add the dsn-file */
  cmd = 'cd 'localrep'/'zigirep' && mkdir .zigi'
  x = bpxwunix(cmd,,so.se.)

  /* Fill dsn file with the comments */
  path = localrep"/"zigirep"/.zigi/dsn"
  'open' path,
    O_rdwr+O_creat+O_trunc,
    660
  if retval = -1 then do
    Address ISPExec
    zs1 = "Something bad when creating .zigi/dsn."
    zs4 = 'Press F3 to close this popup and exit.'
    parse value '' with zs2 zs3
    call do_popup4
    return
  end
  fd = retval  /* as I think it's weird to write to a retval lol */
  call write_fd "# zigi dsn-file"
  call write_fd "# This file needs to be here."
  call write_fd "# Don't edit unless you know what you're doing :)"
  call write_fd '#  '
  call write_fd '# record format is (case insensitive):'
  call write_fd '#  '
  call write_fd '# Position - description'
  call write_fd '#  '
  call write_fd '# 1 - directory name which will be prefixed by the'
  call write_fd '#     defined HLQ to create the z/OS dataset'
  call write_fd '#     (* defines the default)'
  call write_fd '# 2 - PS or PO (dataset organization)'
  call write_fd '#     PS for a flat file'
  call write_fd '#     PO for a directory and thus a partitioned dataset'
  call write_fd '# 3 - record format (FB or VB)'
  call write_fd '# 4 - lrecl'
  call write_fd '# 5 - blksize'
  call write_fd '#     0 is allowed if system determined blksize is enabled'
  call write_fd '# 6 - extension (optional - if used then no period)'
  call write_fd '#     file extension to be used for PDS members in USS'
  call write_fd '#  '
  call write_fd '# Default DSORG and DCB info'
  call write_fd '* PO FB 80 32720'
  'close' fd

  /* ------------------ Let's make our first commit :)       */
  x = docmd('cd 'reporoot' && git add .gitattributes')

  x = docmd('cd 'reporoot' && git add .zigi/dsn')

  commitmsg = "added by zigi"
  x = docmd('cd 'reporoot' && git commit -m "'commitmsg'"')
  return

  /* ---------------------------------------------------------- *
  | Generalized routine to view stdout. (so.) or stderr. (se.) |
  | based on the parm passed                                   |
  * ---------------------------------------------------------- */
view_std:
  arg stdopt viewopt
  if stdopt = null then viewopt = 'B'
  if viewopt = null then viewopt = 'B'
  if stdopt = 'X' then stdopt = null
  if datatype(so.0) /= 'NUM' then so.0 = 0
  if datatype(se.0) /= 'NUM' then se.0 = 0
  if viewopt = 'B' then if so.0 + se.0 = 0 then return
  /* ------------------------------- *
  | Randomly define a DDName to use |
  * ------------------------------- */
  dd = 'zd'random(9999)
  /* --------------------------------------- *
  | Get lrecl to determine dcb for temp d/s |
  * --------------------------------------- */
  if stdopt /= 'C' then do
    vlrecl = 0
    do li  = 1 to so.0
      so.li = strip(so.li,'T')
      if length(so.li) > vlrecl then vlrecl = length(so.li)
      if so.li = null then so.li = ' '
    end
    do li  = 1 to se.0
      se.li = strip(se.li,'T')
      if length(se.li) > vlrecl then vlrecl = length(se.li)
      if se.li = null then se.li = ' '
    end
    sec = so.0 + se.0
  end
  else do
    do li = 1 to combine.0
      if length(combine.li) > vlrecl then vlrecl = length(combine.li)
    end
    sec = combine.0
  end
  if vlrecl < 81 then vlrecl = 80
  /* ------------------------------------------ *
  | Allocate a temporary data set for our data |
  * ------------------------------------------ */
  Address TSO
  /* calculate space needed with avg 50 bytes per record */
  prim = (((so.0 + se.0) * 50) % 56000) + 1
  if prim < 2 then prim = 5
  if viewopt = 'V' then do
    if sysvar('syspref') = null then pref = userid()'.'
    else pref = null
    vdsn = pref'work.zigi.gitdata'
  end
  else vdsn = null
  x = listdsi(vdsn)
  if x = 0 then do
    call outtrap 'x.'
    'delete' vdsn
    call outtrap 'off'
  end
  if vdsn /= null then vdsnp = 'da('vdsn') unit(3390)'
  else vdsnp = null
  if vlrecl > 255 then vlrecl = 251
  'Alloc f('dd') new spa('prim','prim') tr' ,
    'recfm(v b) lrecl('vlrecl+4') blksize(0)' vdsnp
  /* ----------------------------- *
  | If stdopt is 'B' then do both |
  * ----------------------------- */
  if stdopt /= 'C' then do
    stdopt = null
    sc = so.0
    do xi = 1 to se.0
      sc = sc + 1
      so.sc = se.xi
    end
    so.0 = sc
  end
  /* ----------------------- *
  | Write out the stem data |
  * ----------------------- */
  if stdopt = 'C' then do
    'Execio * diskw' dd '(finis stem combine.'
    drop combine.
    combine.0 = 0
  end
  if stdopt /= 'C' then do
    if stdopt = null
    then do
      'Execio * diskw' dd '(finis stem so.'
    end
    else do
      'Execio * diskw' dd '(finis stem se.'
    end
  end
  /* -------------------------------------------------- *
  | Access the Temporary Data Set using ISPF           |
  | Library Services.                                  |
  | Then using ISPF Browse service to browse the data. |
  | And use Library Services to Free the Data Set.     |
  * -------------------------------------------------- */
  Address ISPExec
  if sec > 0 then if viewopt = 'B' then do
    'lminit dataid(ddb) ddname('dd')'
    'browse dataid('ddb') panel(zigibrow)'
    'lmfree dataid('ddb')'
  end
  else do
    vmac = 'Panel(zigiedit) macro(zigivmac)'
    'view dataset('vdsn')' vmac
    vtitle = null
    'verase vtitle'
  end
  /* ----------------------------- *
  | Last Free the z/OS Allocation |
  * ----------------------------- */
  call outtrap 'x.'
  Address TSO ,
    'Free f('dd')'
  if vdsn /= null then
  Address TSO 'Delete' vdsn
  call outtrap 'off'
  return

  /* -------------------------------------------------------- *
  | This routine will generate the users personal SSH Public |
  | Key.                                                     |
  * -------------------------------------------------------- */
Build_SSH:
  parse value '' with zigissh
  zs1 = 'Building SSH Key'
  zs2 = 'Patience . . .'
  do forever
    call do_popup
    call catsshk
    if zigissh /= null then leave
  end
  return

  /* ------------------------------ *
  | Cat the current ssh key if any |
  * ------------------------------ */
catsshk:
  drop so. se.
  cmd = 'cat' keyfile
  x = bpxwunix(cmd,,so.,se.)
  if se.0 = 0
  then do
    zigissh = so.1
    'vput (zigissh) profile'
  end
  else zigissh = null
  return

dsnvalid: Procedure Expose null
  /* Tests for a 'potentially valid' z/OS datasetname */
  parse arg val_dsn
  if strip(val_dsn) = null then return 'NO'
  val_dsn = strip(val_dsn,'B',"'")
  upp = TRANSLATE(val_dsn,".ABCDEFGHIJKLMNOPQRSTUVWXYZ",,
    ".abcdefghijklmnopqrstuvwxyz")
  tdsn = translate(val_dsn,' ','.')
  retval = 'OK'   /* asssume good */
  do i = 1 to words(tdsn)
    w = word(tdsn,i)
    if length(w) > 8 then retval = 'NO'
    if pos(left(w,1),'ABCDEFGHIJKLMNOPQRSTUVWXYZ$#@') = 0 then retval = 'NO'
    w = translate(w,left(' ',39,' '), ,
      'ABCDEFGHIJKLMNOPQRSTUVWXYZ-$#@0123456789')
    w = strip(w)
    if w /= null then retval = 'NO'
  end
  if retval /= 'NO' then
  if upp = val_dsn then do
    smsg = msg()
    call msg 'OFF'
    if sysdsn(val_dsn) = "OK" | sysdsn(val_dsn) = "DATASET NOT FOUND"
    then retval = 'OK'
    else retval = "NO"
    call msg smsg
  end
  return retval

  /* ------------------------------------------------- *
  |                                                  |
  | String replace routine                           |
  | input string                                     |
  | from string                                      |
  | to string                                        |
  | translate is input to from                       |
  * ------------------------------------------------- */
strreplace: Procedure
  string  = arg(1)
  strfrom = arg(2)
  strto   = arg(3)
  if pos(strfrom,string) = 0 then return string
  newString = ''
  do i = 1 to length(string)
    if substr(string,i,1) /= strfrom
    then newstring = newstring''substr(string,i,1)
    else  newstring = newstring''strto
  end
  return newstring

update_repo_metadata:
  save_fulldsn = fulldsn
  x = debug('update_repo_metadata: zcmd:'zcmd ,
    'zsel:' zsel 'zigirep:' zigirep)
  save_dsn = dsn
  if rtbl_open = 1 then do
    'tbend' rtbl
    rtbl_open = 0
    ztdsels = 0
    rtop = 0
  end
  if rtbl_open = 0 then
  'TBCreate' rtbl 'Keys(fulldsn) Names(dsnstat dsn filetype)' ,
    'Replace NoWrite'
  rtbl_open = 1
  call get_dsn_info
  /* We always fetch when we start to work on a repo */
  if fetch_flag = 1 then crflag = 1
  if zigi_offline = 1 then crflag = 1
  if crflag = 0 then do
    fetch_flag = 1
    x = debug('fetching remote')
    zs1 = 'Fetching Remote info'
    zs2 = 'Patience . . .'
    call do_popup
    /* get the remote info.....but */
    /* we have to get rid of the tab in git output */
    x = debug('getting the remotes')
    gitcmd = 'git remote -v | sed -e "s/[[:space:]]\+/ /g"'
    localdir = localrep'/'zigirep
    x = docmd('cd 'localdir' && 'gitcmd)
    if so.0 > 0 then
    remote1 = word(so.1,1)' 'word(so.1,2)
    if so.0 = 0 then do
      remote1 = "<no remote defined>"
      remote2 = null
    end
  end
  cmd = 'cd' localrep'/'zigirep
  /* Fetch only if there's a remote */
  if zigi_offline = 0 then
  if remote1 /= '<no remote defined>' then
  x = docmd(cmd '&& git fetch')
  x = debug('...done fetching remotes')
  fetch_flag = 1
  /* now we get the status for all in the repo */
  if zigi_offline = 0 then
  if crflag = 0 then  do
    if se.0 > 1 then fetchmsg = "Remote updates, check status"
    else fetchmsg = "No remote updates"
    zs1 = 'Updating Repo and/or Getting Stats'
    zs2 = 'Patience . . .'
    call do_popup
  end
  /* get all the files that are in the repo */
  x = debug('getting all files in repo-1')
  address syscall
  'readdir 'localrep'/'zigirep' root.'
  /* check for .zigi/dsn */
  'lstat' localrep'/'zigirep'/.zigi/dsn st.'
  if st.0 = 0 then nonzigi = 1
  else nonzigi = 0
  address ispexec
  if check_flag = 1 then do
    x = debug('Checking z/OS dataset last reference dates.')
    zs1 = 'Checking z/OS dataset change status.'
    zs2 = 'Patience . . .'
    call do_popup
    check_files = zigirefd(localrep'/'zigirep pdshlq qualignr 'C')
    x = debug('Check complete.')
  end
  else check_files = '*'
  do i = 1 to root.0
    if root.i = "." | root.i = ".." then do
      iterate
    end
    else do
      /* not the . and .. things */
      if dsnvalid(root.i) = "OK" then do
        /* and only for valid z/OS-datasets (skip README.md et al) */
        r = usssafe(root.i)
        x = debug('   check file or dir')
        cmd = '[ -d 'localrep'/'zigirep'/'r' ] && echo "DIR"'
        so.1 = null
        x = bpxwunix(cmd,,so.,se.)
        y = debug('   done')
        fulldsn = add_dsn_hlq(root.i)
        edsn = strip(fulldsn,'B',"'")
        if check_files /= null then
        if wordpos(edsn,check_files) = 0 then iterate
        zs1 = 'Checking' fulldsn
        zs2 = 'Patience . . .'
        call do_popup
        if so.1 = "DIR" & x = 0 then do
          x = debug('its a dir...lmmstat all the things' edsn)
          Address TSO
          /* Oh yeah we need this */
          root.i = usssafe(root.i)
          statpath = localrep'/'zigirep'/.zigi/'root.i
          statfile = root.i
          mem_delta = zigistat("'"edsn"'" statpath 'C')
          if mem_delta = 0 then mem_delta = null
          Address ISPExec
          mem_hit = 0
          do im = 1 to words(mem_delta)
            mem = word(mem_delta,im)
            file = root.i
            m = strip(mem)
            m = usssafe(m)
            e = usssafe(edsn)
            r = usssafe(file)
            if zdsn.file /= null
            then rm = lower(strip(mem)'.'zdsn.file)
            else rm = m
            /* Binary v1, check if PDS is a bin, then copy binary */
            if is_binfile(r'/*') = 1 then do
              binopt = '-B'
            end
            else do
              binopt = null
            end
            if is_binfile(r'/'m) = 1 then do
              binopt = '-B'
            end
            else do
              binopt = null
            end
            copycmd = "//'"e"("m")'"
            copycmd = '"'copycmd'"'
            copycmd = "cp "binopt" -U -v" copycmd" "localrep"/"zigirep
            copycmd = copycmd || "/"r"/"rm
            x = bpxwunix(copycmd,,so.,se.)
            if x > 0 then call view_std 'B'
            x = debug('Copy:' copycmd)
            if binopt = '-B' then do
              tagcmd = 'chtag -b 'localrep'/'zigirep'/'r'/'rm
              x = bpxwunix(tagcmd,,so.,se.)
            end
            mem_hit = 1
          end
          /* ------------------------------------------------------- *
          | If any files in the directory do not have a counterpart |
          | in the PDS that indicates the member was deleted from   |
          | the PDS prior to zigi. Need to remove it from OMVS      |
          | and git.                                                |
          * ------------------------------------------------------- */
          address syscall 'readdir' localrep'/'zigirep'/'r rd.
          mem_omvs = null
          'vget (allmems)'
          do im = 1 to rd.0
            if left(rd.im,1) = '.' then iterate
            m = strip(rd.im)
            if zdsn.r /= null
            then do
              parse value m with m'.'.
              m = translate(m)
            end
            if wordpos(m,allmems) = 0 then do
              mem_omvs = mem_omvs m
            end
          end
          'verase (allmems)'
          if strip(mem_omvs) /= null then do
            x = debug('PDS members deleted - removing from OMVS:' ,
              mem_omvs)
            mem_hit = 1
            cmd = 'cd' localrep'/'zigirep'/'r
            cmd = cmd '&& git rm -f' usssafe(mem_omvs)
            x = docmd(cmd)
          end
          /* --------------------------------------------------------- *
          | If members were updated then need to update the stat file |
          * --------------------------------------------------------- */
          if mem_hit = 1 then do
            cmd = 'cd' localrep'/'zigirep'/.zigi'
            cmd = cmd '&& git add .'
            x = zigistat("'"edsn"'" statpath 'S')
          end
        end
        else if nonzigi = 0 then do
          /* It must be a PS, just copy it over to OMVS */
          x = listdsi(fulldsn)
          if x = 0 then do
            s = usssafe(fulldsn)
            if is_binfile(r) = 1 then do
              binopt = '-B'
            end
            else do
              binopt = null
            end
            copycmd = "//"s
            copycmd = '"'copycmd'"'
            copycmd = "cp "binopt" -U -v" copycmd" "localrep"/"zigirep
            copycmd = copycmd || "/"r
            x = bpxwunix(copycmd,,so.,se.)
            if x > 0 then call view_std 'B'
            x = debug('Copy:' copycmd)
            if binopt = '-B' then do
              tagcmd = 'chtag -b 'localrep'/'zigirep'/'r
              x = bpxwunix(tagcmd,,so.,se.)
            end
          end
        end
      end
    end
  end

  if check_flag = 1 then do
    zs1 = 'Updating z/OS Dataset Last Access Information.'
    zs2 = 'Patience . . .'
    call do_popup
    x = debug('Calling zigirefd to update last access info.')
    x = zigirefd(localrep'/'zigirep pdshlq qualignr 'U')
    x = debug('Completed the last access update.')
    check_flag = 0
  end
  zs1 = 'Building List of repository Data Sets'
  zs2 = fetchmsg
  call do_popup
  x = debug('get the status')
  cmd = 'cd' localrep'/'zigirep
  x = docmd(cmd '&& git status --porcelain')
  x = debug('done')
  /* get the stuff from the repo-file */
  x = debug('get all the files (again?)')
  address syscall
  'readdir 'localrep'/'zigirep' root. rstat.'
  address ispexec
  x = debug('done')
  x = debug('iterate the files')
  do i = 1 to root.0
    zs1 = 'Updating dataset and file Git status to display.'
    zs2 = 'Patience . . .'
    call do_popup
    dsnstat = null
    if root.i = "." | root.i = ".." then do
      iterate
    end
    else do
      if dsnvalid(root.i) = "OK" then do
        x = debug('Get the git status and fill dsnstat' root.i)
        dsn = root.i
        do ii = 1 to so.0
          stat = substr(so.ii,1,2)
          PATH = substr(so.ii,4)
          dsnstat = null
          if pos('/',path) > 0
          then parse value path with test'/'.
          else test = path
          if dsn = test then do
            dsnstat = porcelain(stat)
            leave
          end
        end
        x = debug('done')

        if qualignr = null then do
          'tbmod zigirepo order'
          qualignr = 0
        end
        fulldsn = add_dsn_hlq(dsn)
        if nonzigi = 0 then do
          call outtrap 'x.'
          if sysdsn(fulldsn) /= ok then dsnstat = 'Missing z/OS Dataset'
          call outtrap 'off'
        end
        else if sysdsn(fulldsn) /= 'OK' then fulldsn = dsn
        'tbadd' rtbl
      end
      /* -------------------------------------------------- *
      | If NOT a z/OS dataset then it must be an OMVS file |
      | make sure it isn't a . file and then add it        |
      * -------------------------------------------------- */
      else do
        if left(root.i,1) /= '.' then do
          dsn = root.i
          if rstat.i.1 = 1 then filetype = '(D)'
          else filetype = null
          fulldsn = dsn
          do ii = 1 to so.0
            stat = substr(so.ii,1,2)
            PATH = substr(so.ii,4)
            if left(path,1) = '"' then
            path = strip(path,'B','"')
            spos = POS('/',zigirep)
            cutrep = substr(zigirep,spos+1)
            trywith = cutrep'/'fulldsn
            if pos(dsn, PATH) = 1 then do
              dsnstat = porcelain(stat)
              leave
            end
            if pos(trywith, PATH) = 1 then do
              dsnstat = porcelain(stat)
              leave
            end
            /* Ugly fix for uss files with a space */
            if pos('"'dsn'"', PATH) = 1 then do
              dsnstat = porcelain(stat)
              leave
            end
            /* end of ugly fix */
          end
          'tbadd' rtbl
          filetype = null
        end
      end
    end
  end

  /* --------------------------- *
  | Get the current branch info |
  * --------------------------- */
  zs1 = 'Getting current Git Status.'
  zs2 = 'Patience . . .'
  call do_popup
  x = debug('getting git status for current branch')
  x = docmd('cd 'localdir' && git status')
  branch = word(so.1,3)
  if so.0 > 1 then do
    branch_status = word(so.2,4)
    parse var so.2 bstat","baction
  end
  else do
    parse value '' with branch_status bstat baction
  end
  'tbsort' rtbl 'fields(dsn,c,a)'
  fulldsn = save_fulldsn
  'tbmod zigirepo order'
  dsn = save_dsn
  x = debug('Done with update_repo_metadata' zigirep)
  return

porcelain:
  parse arg stat

  /* parse git status --short as documented in
  https://www.git-scm.com/docs/git-status#_short_format */

  Select
    When stat == " M" then res = "Modified"
    When stat == " D" then res = "Deleted"
    When stat == " R" then res = "Renamed"
    When stat == " C" then res = "Copied"
    When stat == "M " then res = "Ready to commit"
    When left(stat,1) == " " then res = "Not Updated"
    When left(stat,1) == "M" then res = "Updated in index"
    When left(stat,1) == "A" then res = "Added to index"
    When left(stat,1) == "D" then res = "Deleted from index"
    When left(stat,1) == "R" then res = "Renamed in index"
    When left(stat,1) == "C" then res = "Copied in index"
    When stat == "??" then res = "Untracked"
    When stat == "MM" then res = "Modified"
    When stat == "AM" then res = "Modified"
    When stat == "RM" then res = "Modified"
    When stat == "CM" then res = "Modified"
    When stat == "MD" then res = "Deleted"
    When stat == "AD" then res = "Deleted"
    When stat == "RD" then res = "Deleted"
    When stat == "CD" then res = "Deleted"
    When stat == "DR" then res = "Renamed"
    When stat == "DC" then res = "Copied"
    When stat == "??" then res = "Untracked"
    When stat == "!!" then res = "Ignored"
    Otherwise res = null
  end
  return '[' || stat || '] ' || res

usssafe: procedure
  parse arg dsn
  if pos('$',dsn) = 0 then return dsn
  /* Let's not usssafe it twice :) */
  if pos('\$',dsn) > 0 then return dsn
  dsn = strreplace(dsn, '$', '\$')
  return dsn

  /* ------------------------------------------------------ *
  | The pfshow routine will:                               |
  | 1. check to see the passed option                      |
  | 2. if Off then it will save the current pfshow setting |
  |    - save the current setting                          |
  |    - turn off pfshow                                   |
  | 3. if the option is Reset then it will                 |
  |    - test if pfshow was on and turn it back on         |
  * ------------------------------------------------------ */
pfshow:
  if zpfshow = 'OFF' then return
  arg pfkopt
  if pfkopt = 'RESET' then do
    if pfkeys = 'ON' then
    'select pgm(ispopf) parm(FKA,ON)'
  end
  if pfkopt = 'OFF' then do
    'vget (zpfshow)'
    pfkeys = zpfshow
    if pfkeys /= 'OFF' then
    'select pgm(ispopf) parm(FKA,OFF)'
  end
  return

  /* ------------------------------- *
  | Add a dataset to the repository |
  * ------------------------------- */
Add_Dataset:
  parse value '' with zcmd what list dsnapfx zsel
  call get_dsn_info
  dsnapfx = pdshlq
  lc_count = 0
  add_count = 0
  last_find = 0
  top = 0
  save_top = 0
  dsnatbl = 'ZIGID'random(999)
  call tbcreate_dsnatbl
  if dsnapfx = null then qualignr = null
  do forever
    parse value '' with zsel zcmd row
    'tbquery' rtbl 'rownum(rows)'
    if rows = 0
    then dsnapnl = 'zigidsna'
    else do
      dsnapnl = 'zigidsnb'
      if list /= 1 then
      call get_list
    end
    if ztdsels > 1
    then 'tbdispl' dsnatbl
    else do
      select
        when add_count = 0 & list = 1 then csr = 'ZSEL'
        when dsnapfx  = null then csr = 'DSNAPFX'
        when qualignr = null then csr = 'QUALIGNR'
        otherwise csr = 'ZCMD'
      end
      zigpass = 'PASSTHRU'
      'vput (zigpass) shared'
      'tbtop' dsnatbl
      'tbskip' dsnatbl 'number('top')'
      'tbdispl' dsnatbl 'panel('dsnapnl') cursor('csr')'
      trc = rc
      zigpass = null
      'vput (zigpass) shared'
      rc = trc
    end
    top = ztdtop
    if add_count > 0 then
    pdshlq  = dsnapfx
    if rc > 4 then do
      zsel = null
      'tbput' rtbl
      'tbend' dsnatbl
      'tbsort' rtbl 'fields(dsn,c,a)'
      'tbtop' rtbl
      if add_count > 0 then
      'tbmod zigirepo order'
      'TBSAVE zigirepo REPLCOPY LIBRARY('isptabl')'
      return
    end
    if row = 0 then zsel = null
    if row <> null then
    if row > 0 then do
      'TBTop' dsnatbl
      'TBSkip' dsnatbl 'Number('row')'
    end

    zcmd = translate(zcmd)
    rf = 0
    if abbrev('RFIND',word(zcmd,1),2) = 1 then do
      zcmd = 'FIND' finddsn
      rf = 1
      'TBTop' dsnatbl
      'TBSkip' dsnatbl 'Number('last_find+1') rowid(row)'
      if rc > 0 then do
        'TBTop' dsnatbl
        last_find = 0
        'TBSkip' dsnatbl 'Number('last_find+1') rowid(row)'
      end
    end
    if abbrev('FIND',word(zcmd,1),1) = 1 then do
      finddsn = word(zcmd,2)
      if rf = 0 then do
        'TBTop' dsnatbl
        'TBSkip' dsnatbl 'Number('ztdtop') rowid(row)'
        wrap = 0
        found = 0
      end
      save_top = row
      do forever
        if pos(finddsn,dsna) > 0 then do
          found = 1
          zerrsm = 'Found.'
          zerrlm = finddsn 'found in row' row +0
          if wrap = 1 then zerrlm = zerrlm 'Wrap around.'
          'setmsg msg(isrz003)'
          last_find = row
          if datatype(last_find) /= 'NUM' then
          last_find = 0
          top = row
          leave
        end
        /* go to the next row */
        'tbskip' dsnatbl 'rowid(row)'
        if rc > 0 then if found = 0 then do
          zerrsm = 'Not Found.'
          zerrlm = finddsn 'not found.'
          'setmsg msg(isrz003)'
          top = save_top
          last_find = 0
          leave
        end
        if rc > 0 then if found = 1 then do
          wrap = 1
          'tbtop' dsnatbl
          'tbskip' dsnatbl 'rowid(row)'
          last_find = 0
        end
      end
    end

    if zsel /= null then
    Select
      when zsel = 'B' then do
        x = listdsi("'"dsna"'")
        if sysdsorg = 'PO' then do
          "LMInit Dataid(edvbr) dataset('"dsna"')"
          "Memlist Dataid("edvbr") Default(B)"
          mrc = rc
          "LMfree Dataid("edvbr")"
          if mrc > 0 then 'setmsg msg(isrz003)'
        end
        else "Browse Dataset('"dsna"')"
      end
      when zsel = 'S' | zsel = 'A' then do
        call do_add_copy
      end
      when zsel = 'AB' then do
        call do_add_copy 'binary'
        gaupdate = 1
      end
      Otherwise nop
    end

    if list = null then call get_list
    if lc_count = 0 then do
      zerrsm = 'Empty List'
      zerrlm = 'The requested high level qualifier resulted in zero' ,
        'eligible datasets.'
      'setmsg msg(isrz003)'
    end
    'tbtop' dsnatbl
  end
  if ztdels < 2 then
  if gaupdate = 1 then
  call get_binfiles
  return

tbcreate_dsnatbl:
  'tbcreate' dsnatbl 'keys(dsna) names(dastat) nowrite'
  return

Get_List:
  'tbend' dsnatbl
  call tbcreate_dsnatbl
  dsnapfx = strip(dsnapfx)
  if qualignr > 0 then do
    prefix = translate(dsnapfx,' ','.')
    prefix = subword(prefix,1,qualignr)
    prefix = translate(prefix,'.',' ')
  end
  else prefix = dsnapfx
  cmd = 'ls' localrep'/'zigirep
  x = bpxwunix(cmd,,so.,se.)
  Address TSO
  call outtrap 'x.'
  '%zigircsi 'dsnapfx'.**'
  call outtrap 'off'
  Address ISPExec
  do dsni = 1 to x.0
    if word(x.dsni,1) /= 'NONVSAM' then iterate
    dsna = word(x.dsni,2)
    dastat = null
    do gl = 1 to so.0
      if substr(dsna,length(prefix)+2) = word(so.gl,1)
      then dastat = 'Added'
    end
    'tbadd' dsnatbl
    lc_count = lc_count + 1
  end
  if lc_count > 0 then
  list = 1
  return

  /* -------------------------------------------- *
  | Perform the actual copy of the added dataset |
  | or member to the local repository.           |
  * -------------------------------------------- */
Do_Add_Copy:
  arg acopt
  parse arg option with ''
  gabs = 'git-encoding=BINARY zos-working-tree-encoding=BINARY binary'
  zsel = null
  ac_mem = null
  copy_dsna = dsna
  if pos('(',dsna) > 0 then
  parse value dsna with dsna'('ac_mem')'
  what = dsna
  FC = listdsi("'"WHAT"'")
  dsnb = remove_dsn_hlq(dsna)
  if sysdsorg = 'PO' then
  if zdsn.dsnb = null then do
    'addpop row(4) column(6)'
    'display panel(zigiadde)'
    drc = rc
    'rempop'
    if drc = 0 then zdsn.dsnb = ext
  end
  if ac_mem /= null then
  if zdsn.dsnb /= null then do
    ac_mem = lower(ac_mem'.'zdsn.dsnb)
  end
  if ac_mem /= null then dsnb = dsnb'/'ac_mem
  zs1 = 'Copying' copy_dsna
  zs2 = 'to' dsnb 'in OMVS'
  if translate(option) = 'BINARY' then do
    zs3 = 'Copy as Binary'
  end
  else do
    zs3 = 'Copy as Text'
  end
  zs4 = 'Patience . . .'
  call do_popup4
  DIR = localrep'/'zigirep
  if sysrecfm = 'U' then do
    if ztdsels = 1 then do
      zerrsm = 'Invalid'
      zerrlm = 'Dataset' what 'is not a valid Git dataset. Must be' ,
        'RECFM of Fixed or Variable and not U.'
      'Setmsg msg(isrz003)'
    end
    dastat = 'Invalid Recfm'
    'tbmod' dsnatbl
    return
  end
  if SYSDSORG = 'PO' then do
    pds = what
    PDS = strip(PDS,"B","'")
    pdss = usssafe(dsnb)
    pdsc = usssafe(pds)
    if pos('/',pdss) > 0 then
    parse value pdss with pdss'/'.
    mkdir = "mkdir -p "DIR"/"pdss
    x = bpxwunix(mkdir,,so.,se.)
    binopt = null
    if option = 'binary' then
    if bin_already(dsnb) = 0 then do
      binopt = '-B'
      if ac_mem = null then ga_mem = '*'
      else ga_mem = ac_mem
      /* setting the gitattributes file */
      /* first convert the ASCII atrtib file to ebcdic :( */
      cmd = 'cd 'DIR' && iconv -f ISO8859-1 -t IBM-1047 '
      cmd = cmd '.gitattributes > .gae'
      /* then append the binary attrib for this file */
      cmd = cmd '&& echo "'pdss'/'ga_mem' 'gabs'" >> .gae '
      /* convert it back to ascii */
      cmd = cmd '&& iconv -f IBM-1047 -t ISO8859-1 .gae '
      cmd = cmd '> .gitattributes '
      /* add (and commit) .gitattributes to the index */
      cmd = cmd '&& git add .gitattributes '
      cmd = cmd '&& git commit -m "zigi changed .gitattributes"'
      cmd = cmd ".gitattributes"
      /* finally remove the .gae file */
      cmd = cmd '&& rm .gae'
      x = docmd(cmd)
      call get_binfiles
    end
    if zdsn.dsnb = null then do
      if ac_mem /= null then pdsc = pdsc"("ac_mem")"
      copycmd = "//'"pdsc"'"
      copycmd = '"'copycmd'"'
      cmd = "cp -U -v "binopt copycmd" "DIR"/"pdss"/"ac_mem
      x =bpxwunix(cmd,,so.,se.)
    end
    else do
      call outtrap 'cm.'
      address tso 'listd' "'"pds"' m"
      call outtrap 'off'
      do ci = 7 to cm.0
        mem = word(cm.ci,1)
        ussmem = lower(mem)'.'zdsn.dsnb
        zs2 = 'to' dsnb'/'ussmem
        call do_popup4
        pdsc = pds"("mem")"
        copycmd = "//'"pdsc"'"
        copycmd = '"'copycmd'"'
        cmd = "cp -U -v "binopt copycmd" "DIR"/"pdss"/"ussmem
        x =bpxwunix(cmd,,so.,se.)
      end
    end
    if option = 'binary' then do
      /* for some reason the git autotagging due to .gitattributes
      does not work all the time (?? weird) so we tag it if binary
      */
      tagcmd = 'chtag -bR 'DIR'/'pdss'/'ac_mem
      x = bpxwunix(tagcmd,,so.,se.)
    end
    Address TSO '%zigistat' "'"pds"'" dir"/.zigi/"pdss 'S'
    x = docmd('cd' dir '&& git add .zigi/'pdss)
  end
  else do
    W = usssafe(WHAT)
    PSS = usssafe(dsnb)
    binopt = null
    if option = 'binary' then
    if bin_already(dsnb) = 0 then do
      binopt = '-B'
      /* setting the gitattributes file */
      /* first convert the ASCII atrtib file to ebcdic :( */
      cmd = 'cd 'DIR' && iconv -f ISO8859-1 -t IBM-1047 '
      cmd = cmd '.gitattributes > .gae'
      /* then append the binary attrib for this file */
      cmd = cmd '&& echo "'pss gabs'" >> .gae '
      /* convert it back to ascii */
      cmd = cmd '&& iconv -f IBM-1047 -t ISO8859-1 .gae '
      cmd = cmd '> .gitattributes '
      /* add (and commit) .gitattributes to the index */
      cmd = cmd '&& git add .gitattributes '
      cmd = cmd '&& git commit -m "zigi changed .gitattributes"'
      /* finally remove the .gae file */
      cmd = cmd '&& rm .gae'
      x = docmd(cmd)
      call get_binfiles
    end
    copycmd = "//'"W"'"
    copycmd = '"'copycmd'"'
    copycmd = "cp -U -v "binopt copycmd" "DIR"/"pss
    x =bpxwunix(copycmd,,so.,se.)
    if option = 'binary' then do
      /* for some reason the git autotagging due to .gitattributes
      does not work all the time (?? weird) so we tag it if binary
      */
      tagcmd = 'chtag -b 'DIR'/'pss
      x =bpxwunix(tagcmd,,so.,se.)
    end
  end
  dsnstat = '[??] Untracked'
  dsn = dsnb
  fulldsn = "'"what"'"
  pdshlq = dsnapfx
  'tbadd' rtbl
  dastat = 'Added'
  'tbmod' dsnatbl
  add_count = add_count + 1
  call save_dsninfo
  return

  /* ------------------------------------------------------- *
  | Get the DCB and optionally Directory info for the added |
  | dataset and save in the /.zigi/dsn file for use when    |
  | creating/recreating the z/OS dataset.                   |
  |                                                         |
  | Routine uses OGET and OPUT along with ALLOC/EXECIO.     |
  |                                                         |
  | Format is:                                              |
  | dsn PS/PO recfm lrecl blksize extension                 |
  | the extension is optional - no preceeding period        |
  * ------------------------------------------------------- */
save_dsninfo:
  /* better make sure sd. stem is empty before we start :) */
  sd. = ''
  sd.0 = 0
  x = listdsi(fulldsn)
  dsn_record = dsn sysdsorg sysrecfm syslrecl sysblksize zdsn.dsn
  if sysvar('syspref') = null then pref = sysvar('sysuid')'.'
  else pref = null
  sd_dsn = pref'zigi.t'time('s')
  sd_dd  = 'zdd'time('s')
  path = localrep"/"zigirep"/.zigi/dsn"
  address tso
  call outtrap 'x.'
  "oget '"path"'" sd_dsn 'text'
  'alloc f('sd_dd') shr ds('sd_dsn')'
  'execio * diskr' sd_dd '(finis stem sd.'
  do x = 1 to sd.0
    if word(sd.x,1) = dsn then do
      'free f('sd_dd')'
      'delete' sd_dsn
      call outtrap 'off'
      Address ISPExec
      return
    end
  end
  slast = sd.0
  slast = slast + 1
  sd.slast = dsn_record
  sd.0 = slast
  do sx = 1 to sd.0
    sd.sx = translate(sd.sx,' ','0D'x)
  end
  'execio * diskw' sd_dd '(finis stem sd.'
  call outtrap 'x.'
  'oput' sd_dsn "'"path"' text"
  'free f('sd_dd')'
  'delete' sd_dsn
  cmd = 'cd 'localrep'/'zigirep' && git add .zigi/dsn'
  x = docmd(cmd)
  call outtrap 'off'
  Address ISPExec
  return

Write_FD:
  parse arg string
  string = string || ESC_R || ESC_N
  'write' fd 'string' length(string)
  return

  /* ----------------------------------------------------------- *
  | Undo Routine to revert an element in a Modified state prior |
  | to a commit.                                                |
  * ----------------------------------------------------------- */
Do_Undo:
  arg uopt

  if uopt = 'D' then mem = null
  zerrsm = null
  /* -------------------------------- *
  | Undo a commit. eg checkout --    |
  * -------------------------------- */
  d = usssafe(dsn)
  if uopt = 'M' then
  m = usssafe(mem)

  zs1 = 'Un-modiying 'mem
  zs2 = 'This never happened...'
  call do_popup
  address 'SYSCALL' 'SLEEP (1)'

  if uopt = 'M'
  then parse value memstat with '['vm']' vt
  else parse value dsnstat with '['vm']' vt
  if pos('M',vm) = 0 then do
    zerrsm = 'Not Applicable'
    zerrlm = 'Undo is only valid on a status of [M ] or [ M]' ,
      'where the element is modified or Ready for commit.'
    'setmsg msg(isrz003)'
  end

  if zerrsm = null then do
    cmd = 'cd' localrep'/'zigirep
    cmd2 = null
    if pos('Ready to',vt) > 0 then do
      if mem = null
      then cmd2 = '&& git reset HEAD' d
      else do
        cmd2 = '&& git reset HEAD' d'/'m
        cmd2 = cmd2 '&& git reset HEAD .zigi/'d
        cmd2 = cmd2 '&& git checkout -- .zigi/'d
      end
    end
    if uopt = 'M'
    then cmd = cmd cmd2 ' && git checkout -- 'd'/'m
    else cmd = cmd cmd2 ' && git checkout -- 'd
    cmd = cmd '&& echo "----------------------"'
    x = docmd(cmd)
    drop combine.
    combine.0 = 0
    call combine_msgs
    if is_binfile(d) = 1 then cpbin = '-B'
    else cpbin = null
    if uopt = 'M' then do
      cmd = 'cd' localrep'/'zigirep'/'d
      fdsn = strip(fulldsn,'B',"'")
      cmd = cmd '&& echo "Copy results:" && echo " "'
      cmd = cmd '&& cp -Uv' cpbin m ,
        '"//' || "'"usssafe(fdsn)"("m")'" || '"'
    end
    else do
      cmd = 'cd' localrep'/'zigirep
      cmd = cmd '&& echo "Copy results:" && echo " "'
      cmd = cmd '&& cp -Uv' cpbin d ,
        '"//' || "'"usssafe(strip(fulldsn,'B',"'"))"'" || '"'
    end
    cmd = cmd '&& echo " " && echo "after copy status:" && git status'
    x = docmd(cmd)
    call combine_msgs
    call view_std 'C'
    drop combine.
    combine.0 = 0
    if uopt = 'M' then do
      sfile = localrep'/'zigirep'/.zigi/'d
      statmems = mem
      'vput (statmems)'
      Address TSO '%zigistat' fulldsn sfile 'U'
      memstat = null
      'tbmod' rtbl
    end
    call update_repo_metadata
    if uopt = 'D'
    then call work_with_repo
    else call work_with_repo_file
  end
  return

  /* ------------------------- *
  | Do History for an element |
  * ------------------------- */
do_history:
  parse arg element
  zerrlm = null
  zsel = null
  update_flag = 0
  select
    When filetype = '(D)' then zerrlm = 'History does not work on directories'
    When left(element,1) = "'" then do
      x = listdsi(element)
      if sysdsorg = 'PO' then
      zerrlm = 'History does not work on Partitioned Datasets'
    end
    otherwise nop
  end
  if zerrlm /= null then do
    zerrsm = 'Error.'
    'setmsg msg(isrz003)'
    return
  end
  shelement = element
  if pos('/',zigirep) > 0 then do
    parse value zigirep with x'/'zrep
    element = zrep'/'element
  end
  cmd = 'cd' localrep'/'zigirep
  cmd = cmd '&& git log --cc -m -n 9999 --unified=1'
  cmd = cmd '| grep -e commit -e Date -e Author -e' usssafe(element)
  x = docmd(cmd)
  hhit = 0
  hist_tbl = 'ZHIST'random(999)
  'tbcreate' hist_tbl 'Names(hdate hcommit hauthor) nowrite'
  do ih = 1 to so.0
    if left(so.ih,7) = 'commit ' then do
      hcommit = word(so.ih,2)
    end
    if left(so.ih,5) = 'Date:' then do
      parse value so.ih with . d1 d2 d3 time year gmt
      /* now make it pretty */
      hdate = d1 year d2 left(d3,2) time gmt
    end
    if left(so.ih,7) = 'Author:' then
    parse value so.ih with . hauthor '<' .
    if left(so.ih,4) /= '+++ ' then iterate
    parse value so.ih with . '/'shelement .
    if element /= strip(shelement) then iterate
    hhit = 1
    'tbadd' hist_tbl
  end
  if hhit = 0 then do
    zerrsm = 'Warning'
    zerrlm = 'There was no git commit history found.'
    'setmsg msg(isrz003)'
    return
  end
  'control display save'
  if hhit = 1 then do
    delement = element
    if pos('/',delement) > 0 then do
      parse value delement with le'/'re
    end
    'tbtop' hist_tbl
    save_top = ztdtop
    top = 1
    save_ztdsels = ztdsels
    do forever
      zsel = null
      if ztdsels > 1 then 'tbdispl' hist_tbl
      else do
        'tbtop' hist_tbl
        'tbskip' hist_tbl 'number('top')'
        'tbdispl' hist_tbl 'Panel(zigihist)'
      end
      if rc > 4 then leave
      top = ztdtop

      if ztdsels = 0 then
      if pnsdef = 'P' then do
        if row = 0 then zcmd = 'O'
        if row > 0 then zsel = '/'
      end

      if zsel = '/' then do
        'Addpop row(4) column(6)'
        'Display Panel(zigirhst)'
        'rempop'
      end
      Select
        /* -------------------------------------------- *
        | View the commit log for this historical item |
        * -------------------------------------------- */
        When zsel = 'C' then do
          cmd = 'cd' localrep'/'zigirep
          cmd = cmd '&& git log' hcommit '-n 1 --cc'
          x = docmd(cmd)
          'control display save'
          call view_std 'X' 'V'
          'control display restore'
          zsel = null
        end
        /* ----------------------------------------------------------- *
        | Recover the specific historical level of the element. This  |
        | does NOT use git but copies the git level data into the     |
        | provided (prompted) target dataset or dataset(member).      |
        | If the element is a PDS member then it must be recovered to |
        | a PDS member.                                               |
        * ----------------------------------------------------------- */
        When zsel = 'R' then do   /* recovery */
          cmd = 'cd' localrep'/'zigirep
          cmd = cmd '&& git show' strip(hcommit)':'element
          'control display save'
          x = docmd(cmd)
          'control display restore'
          if dsnvalid(fulldsn) = 'NO' then do
            zerrsm = 'Error.'
            zerrlm = 'The recovery of a non-z/OS dataset is not supported' ,
              'at this time. You can use S to view the historical' ,
              'data and then copy it into the clipboard to paste' ,
              'into a OMVS file to recover it.'
            'setmsg msg(isrz003)'
          end
          else do
            if left(fulldsn,1) /= "'" then
            relement = fulldsn
            if left(fulldsn,1) = "'" then do
              if pos('/',element) = 0
              then relement = fulldsn
              else do
                parse value element with .'/'rcmem
                relement = left(fulldsn,length(fulldsn)-1) ,
                  || "("rcmem")'"
              end
            end
            rdsn = relement
            ralc = 'N'
            rans = null
            rover = null
            'Addpop row(4) column(8)'
            'Display Panel(zigiresq)'
            drc = rc
            'Rempop'
            if drc > 0 then leave
            if rans = 'N' then leave
            rcdd = 'RC'random(99999)
            address tso
            if sysdsn(rdsn) = 'DATASET NOT FOUND' then ralloc = 'Y'
            else ralloc = 'N'
            if ralloc = 'N'
            then 'Alloc f('rcdd') shr reuse da('rdsn')'
            else 'Alloc f('rcdd') new like('relement') da('rdsn')'
            save_rdsn = rdsn
            /* fix up the stem convert nulls to blanks lines */
            do rc = 1 to so.0
              if so.rc = null then so.rc = ' '
            end
            'Execio * diskw' rcdd '(finis stem so.'
            'Free f('rcdd')'
            address ispexec
            if pos('(',rdsn) > 0 then do
              parse value rdsn with rdsn"("mem")"
              if left(rdsn,1) = "'" then rdsn = rdsn"'"
              "LMINIT DATAID(zstats) DATASET("rdsn")"
              "LMOPEN DATAID("zstats") OPTION(INPUT)"
              'LMMSTATS DATAID('zstats') Member('mem') user('zluser')'
              "LMClose Dataid("zstats")"
              "LMFree  Dataid("zstats")"
            end
            zerrsm = 'Completed.'
            zerrlm = relement 'successfully recovered into' save_rdsn ,
              left(' ',76) ,
              'the recovered element will be in a Modified state and will' ,
              'need to be added to the staging index and committed if' ,
              'desired.'
            'setmsg msg(isrz003)'
            if fulldsn = rdsn then update_flag = 1
          end
        end
        /* ---------------------------------------------------------- *
        | View the Source for the element at the historical (commit) |
        | point in time.                                             |
        * ---------------------------------------------------------- */
        When zsel = 'S' then do
          cmd = 'cd' localrep'/'zigirep
          cmd = cmd '&& git show' strip(hcommit)':'element
          'control display save'
          x = docmd(cmd)
          'control display restore'
          vtitle = element '\' hdate '\' hauthor '\' fulldsn
          'vput (vtitle)'
          call view_std 'X' 'V'
        end
        Otherwise nop
      end
    end
  end
  'control display restore'
  'tbend' hist_tbl
  ztdsels = save_ztdsels
  ztdtop = save_top
  if update_flag = 1 then do
    if sysdsorg = 'PS' then call work_with_repo
    else do
      call update_repo_metadata
      call work_with_repo_file
    end
  end
  return

  /* ---------------------------------------- *
  | Confirm removal of the requested element |
  * ---------------------------------------- */
Confirm_Remove:
  parse arg rxdsn
  if remc = 'YES' then return 0
  if remc = null then remc = 'NO'
  rema = null
  call pfshow 'off'           /* make sure pfshow is off */
  'Addpop row(4) column(12)'
  'Display Panel(zigiremq)'
  drc = rc
  if rema /= 'YES' then rrc = 4
  else rrc = 0
  'Rempop'
  if drc > 0 then do
    rrc = 4
    remc = 'NO'
  end
  call pfshow 'reset'         /* restore pfshow setting */
  return rrc

  /* ----------------------- *
  | Generalized Pop Message |
  | with msg passed         |
  * ----------------------- */
Pop:
  parse arg zs1 zs2
  add = address()             /* save addressing environment */
  Address ISPExec
  call do_popup
  Address add                 /* restore addressing environment */
  return

  /* ---------------------------------------- *
  | Common routine for normal (2 line) popup |
  * ---------------------------------------- */
Do_Popup:
  call pfshow 'off'           /* make sure pfshow is off */
  'Control Display Lock'
  'Addpop row(4) column(12)'
  'Display Panel(zigipop)'
  'Rempop'
  call pfshow 'reset'         /* restore pfshow setting */
  return

  /* ---------------------------------------- *
  | Common routine for normal (4 line) popup |
  * ---------------------------------------- */
Do_Popup4:
  call pfshow 'off'           /* make sure pfshow is off */
  'Control Display Lock'
  'Addpop row(4) column(6)'
  'Display Panel(zigipop4)'
  'Rempop'
  call pfshow 'reset'         /* restore pfshow setting */
  return

  /* ---------------------------------------- *
  | Common routine for normal (4 line) popup |
  * ---------------------------------------- */
Do_Popup4p:
  call pfshow 'off'           /* make sure pfshow is off */
  'Addpop row(4) column(6)'
  'Display Panel(zigipop4)'
  'Rempop'
  call pfshow 'reset'         /* restore pfshow setting */
  return

  /* ----------------------------------------------------- *
  | Get the users current OMVS enviornment for use in the |
  | bpxwunix commands.                                    |
  * ----------------------------------------------------- */
GETENV:
  x = debug('Starting collection of env variables')
  cmd  = docmdx('env')
  rc = bpxwunix(cmd,,env.,se.)
  envc = env.0
  call add_env '_BPX_SHAREAS=YES'
  call add_env '_BPX_SPAWN_SCRIPT=YES'
  call add_env 'EXPORT _EDC_ADD_ERRORNO2=1'
  env.0 = envc
  drop so. se.
  x = debug('Finished collection of env variables')
  return

  /* -------------------- *
  | Add info to env stem |
  * -------------------- */
add_env:
  parse arg env_val
  envc = envc + 1
  env.envc = env_val
  return

docmd:
  parse arg cmd
  drop so. se.
  if gitenv /= null then do
    cmd = ". "gitenv" > /dev/null 2>&1 && "cmd
  end
  x = bpxwunix(cmd,,so.,se.,env.)
  return x

docmdx:
  /* quircky thing, we need to export HOME as we are
  not running a login shell via bpxwunix */
  parse arg cmd
  drop so. se.
  if rx = null then do
    rx = 'export HOME='home' && . /etc/profile > /dev/null 2>&1 && '
    c = "[[ -f "home"/.profile ]] && echo f"
    x = bpxwunix(c,,o.,e.)
    if o.0 = 1 & o.1 = "f" then do
      rx = rx '. 'home'/.profile > /dev/null 2>&1 && '
    end
  end
  r = rx ' ' cmd
  return r

view_debug:
  if zigidebg = 1 then do
    filev = debugfil
    'view  file(filev)'
  end
  else do
    zerrsm = 'Invalid.'
    zerrlm = 'VIEWD is not supported when debug is not enabled. To' ,
      'enable debug allocate a ZIGIDEBG DD to Dummy and' ,
      'restart zigi.'
    'setmsg msg(isrz003)'
  end
  return

debug:
  if zigidebg  = 1 then do
    parse arg msg
    msg = Date() Time()' : 'msg
    c = 'echo "'msg'" >>' debugfil
    x = bpxwunix(c,,dso.,dse.)
    zigidebg_use = 1
  end
  return 0

  /* --------------------------------- *
  | Add a message to the combine stem |
  * --------------------------------- */
Add_Combine: procedure expose combine. null
  parse arg msg
  c = combine.0
  c = c + 1
  combine.c = '   '
  c = c + 1
  combine.c = msg
  c = c + 1
  combine.c = '   '
  combine.0 = c
  return

  /* --------------------------------------------------------- *
  | Combine the stdout and stderr messages into combine. stem |
  | for viewing.                                              |
  * --------------------------------------------------------- */
Combine_msgs: procedure expose so. se. combine. null
  c = combine.0
  do i = 1 to so.0
    c = c + 1
    combine.c = strip(so.i,'T')
    if combine.c = null then combine.c = ' '
  end
  do i = 1 to se.0
    c = c + 1
    combine.c = strip(se.i,'T')
    if combine.c = null then combine.c = ' '
  end
  combine.0 = c
  return

  /* -------------------------------------------- *
  | Get the date/time for the provided omvs file |
  * -------------------------------------------- */
get_fd_date: procedure expose null
  parse arg file_var
  x = bpxwunix('ls -la' file_var,,so.,se.)
  fdate = subword(so.1,6,3)
  return fdate

Test_Repo_Table_State:
  /* --------------------------------------------- *
  | Test to see if the ZIGIREPO table is for V2R1 |
  | and if not upgrade it.                        |
  * --------------------------------------------- */
  'TBQuery zigirepo Names(names)'
  if pos('BRANCH',names) = 0 then do
    zs1 = 'Upgrading the ZIGI Repository ISPF Table'
    zs2 = 'This should not take long.'
    call do_popup
    if pos('ZIGICAT',names) > 0 then cat = 1
    else cat = 0
    if pos('BRANCH',names) > 0 then tbranch = 1
    else tbranch = 0
    'tbtop zigirepo'
    if tbranch = 0 then do
      branch = null
      remote1 = null
    end
    if cat = 0 then do
      zigicat = null
      sortdate = null
    end
    tc = 0
    do forever
      'tbskip zigirepo'
      if rc > 0 then leave
      'tbget zigirepo'
      tc = tc + 1
      key.tc = zigikey'\'localrep'\'pdshlq'\'qualignr'\'zigirep ,
        '\'defcpush '\'defruid'\'zigidate '\' sortdate '\' zigicat ,
        '\' branch '\' remote1
    end
    key.0 = tc
    'tbend zigirepo'
    'TBErase zigirepo Library('isptabl')'
    call create_zigirepo
    do i = 1 to key.0
      parse value key.i with zigikey'\'localrep'\'pdshlq'\'qualignr'\'zigirep ,
        '\'defcpush'\'defruid'\'zigidate'\'sortdate'\'zigicat ,
        '\'branch'\'remote1
      if right(localrep,1) = '/' then localrep = strip(localrep,'T','/')
      localdir = strip(localdir)
      zigirep  = strip(zigirep)
      zigicat  = strip(zigicat)
      sortdate  = strip(sortdate)
      zigikey = localrep'/'zigirep
      if cat = 0 then
      Select
        when zigidate /= null then do
          zd = subword(zigidate,1,3)
          zt = subword(zigidate,4)
          zigidate = zd
          if strip(zt) = null then zt = 0
          sortdate = date('b',zd,'n') zt
        end
        When words(zigidate) > 3 then do
          zigidate = strip(subword(zigidate,1,3))
          zt = subword(zigidate,4)
          if pos(':',zt) > 0 then zt = left(zt,2)''substr(zt,4,2)
          sortdate = date('b',strip(zigidate),'n') zt
        end
        When words(zigidate) = 3 then do
          sortdate = date('b',strip(zigidate),'n') 0
        end
        Otherwise sortdate = date('b')''time('s')
      end
      'tbadd zigirepo order'
      if cat = 0 then do
        sortdate = null
        zigicat = null
      end
    end
  end
  Return

parseGitURI:
  /* --------------------------------------------- *
  | Parse the various forms of git repo uri's into|
  | <user> <site> <port> <repo>                   |
  * --------------------------------------------- */
  parse arg uri
  if pos('ssh://',uri) = 1 then
  uri = substr(uri,pos('ssh://', uri) + 6)

  parse var uri user '@' site ':' portorrealuser '/' repo
  if datatype(portorrealuser) = 'NUM' then port = portorrealuser
  else do
    port = 22
    user = portorrealuser
  end
  return user site port repo

  /* -------------------------------------------------- *
  | Routine to update git with the user name and email |
  * -------------------------------------------------- */
Update_Config:
  /* dunno if we still need these in the profile?? */
  'VPut (zigiuid zigimail zigissh) Profile'
  /* maybe we could use the ispprof for some lazy caching */
  /* now that we've had the user see the settings.
  set the git config if they have changed...
  */
  if old_zigiuid /= zigiuid then do
    x = docmd('git config --global user.name "'zigiuid'"')
    if x > 0 then do
      zs1 = "something went wrong with git config user.name"
      x = so.0
      zs2 = so.x
      zs3 = se.1
      zs4 = null
      call do_popup4
    end
    x = docmd('git config --global user.email "'zigimail'"')
    if x > 0 then do
      zs1 = "something went wrong with git config user.email"
      x = so.0
      zs2 = so.x
      zs3 = se.1
      zs4 = null
      call do_popup4
    end
    /* Let's adopt the new style. Only push current branch */
    x = docmd('git config --global push.default simple')
  end
  'VPut (zigiuid zigimail zigissh) Profile'
  zerrsm = 'Updated.'
  zerrlm = 'zIGI Settings updated successfully.'
  'Setmsg msg(isrz003)'
  return

  /* --------------------------------------------------------- *
  | Save the so. and se. variables for later use as some code |
  | will overlay them but we need to use them again later.    |
  * --------------------------------------------------------- */
Save_DoVars: procedure expose so. se. sso. sse.
  do i = 1 to so.0
    sso.i = so.i
  end
  do i = 1 to se.0
    sse.i = se.i
  end
  sso.0 = so.0
  sse.0 = se.0
  return

  /* ----------------------------------------- *
  | Restore the so. and se. variables for use |
  * ----------------------------------------- */
Rest_DoVars: procedure expose so. se. sso. sse.
  do i = 1 to sso.0
    so.i = sso.i
  end
  do i = 1 to sse.0
    se.i = sse.i
  end
  so.0 = sso.0
  se.0 = sse.0
  return

MGEN: Procedure
  /* ---------------------------------------------------------- |
  | Name:      MGEN                                            |
  |                                                            |
  | Function:  Return the current system  MAXGENS_LIMIT        |
  |            which is the system max generations value       |
  |            for PDSE Version 2 libraries                    |
  |                                                            |
  | Syntax:    mgen=(mgen)                                     |
  |                                                            |
  | ---------------------------------------------------------- */
  parse source source
  Numeric Digits 10
  CVT      = C2D(Storage(10,4))
  CVTDFA   = C2D(Storage(D2X(CVT + 1216),4))   /* cvt + 4c0 */
  DFAMGEN  = C2D(Storage(D2X(cvtdfa + 76),4))  /* dfa + 4c */
  return dfamgen

get_binfiles:
  /* ---------------------------------------------------------\
  | Name:      get_binfiles                                    |
  |                                                            |
  | Function:  Fills the global binfiles. stem with all        |
  |            current repo files that are added as binary.    |
  \---------------------------------------------------------- */
  cmd = 'cd 'localrep'/'zigirep' &&'
  cmd = cmd 'cat .gitattributes | grep git-encoding=BINARY'
  cmd = cmd '| cut -d" " -f1'
  x = docmd(cmd)
  binfiles. = null
  do b = 1 to so.0
    binfiles.b = so.b
  end
  binfiles.0 = so.0
  return 0

bin_already:
  arg file
  if datatype(binfiles.0) /= 'NUM' then return 0
  do b = 1 to binfiles.0
    if file = binfiles.b then return 1
    if pos('/',binfiles.b) = 0
    then test = binfiles.b
    else parse value binfiles.b with test'/'.
    if file = test then return 1
  end
  return 0

is_binfile:
  /* ---------------------------------------------------------\
  | Name:      is_binfile                                      |
  |                                                            |
  | Function:  Checks the global binfiles. stem for the        |
  |            provided dataset or dataset/member              |
  \---------------------------------------------------------- */
  arg file
  if datatype(binfiles.0) /= 'NUM' then return 0
  do bi = 1 to binfiles.0
    if binfiles.bi = file then return 1
    if right(binfiles.bi,1) = '*' then do
      parse value file with test'/'.
      if left(binfiles.bi,length(binfiles.bi)-2) = test
      then return 1
    end
    if binfiles.bi = file then return 1
  end
  return 0

check_clean:
  /* ---------------------------------------------------------\
  | Name:      check_clean                                     |
  |                                                            |
  | Function:  Checks if working dir is clean                  |
  |            returns YES or NO                               |
  \---------------------------------------------------------- */
  cmd = 'cd 'localrep'/'zigirep' && git status'
  x = docmd(cmd)
  clast = so.0
  if pos('working tree clean',so.clast) > 0 then return 'YES'
  else return "NO"

flowselect:
  /* ----------------------------- *
  | Show the flows and select one |
  * ----------------------------- */
  if rtbf_open = 1 then 'tbend' rtbf
  'TBCreate' rtbf 'keys(bname) Names(brstatus) Replace NoWrite'
  rtbf_open = 1
  localdir = localrep'/'zigirep
  if zigi_offline = 0 then do
    cmd = ' && git remote prune origin > /dev/null 2>&1 && git branch -a'
    x = docmd('cd 'localdir cmd)
  end
  else parse value '0 0' with so.0 se.0
  if so.0 + se.0 = 0 then do
    cmd = '&& git branch -a'
    x = docmd('cd 'localdir cmd)
  end
  bl. = null
  bl.0 = 0
  do i = 1 to so.0
    b1 = strip(so.i,'B')
    if pos('/',b1) > 0 then do
      /* this is a remote branch we (maybe) have never checked out */
      seen_this_branch = 0
      parse var b1 remotes'/'origin'/'bname zooi
      bname = strip(bname)
      do ii = 1 to bl.0
        if bl.ii = bname then seen_this_branch = 1
      end
      if seen_this_branch = 1 then do
        sbname = bname
        'tbtop' rtbf
        do forever
          'tbskip' rtbf
          if rc > 0 then leave
          if sbname = bname then do
            brstatus = 'Local/Remote'
            'tbmod' rtbf
            leave
          end
        end
      end
      /* but only add it to table if we haven't yet */
      if seen_this_branch = 0 then do
        if bname <> branch & bname <> "HEAD" then do
          ni = bl.0 + 1
          bl.ni = bname
          bl.0 = ni
          brstatus = 'Remote'
          /* and only if it's a zigiflow branch */
          if substr(bname,1,9) = 'zigiflow-' then do
            'tbadd' rtbf
          end
        end
      end
    end
    else do
      /* this is already a local branch */
      if pos('*',b1) = 0 then do
        /* Add it to the table if it's not the current (*) branch */
        bname = strip(so.i)
        ni = bl.0 + 1
        bl.ni = b1
        bl.0 = ni
        brstatus = 'Local'
        if substr(bname,1,9) = 'zigiflow-' then do
          'tbadd' rtbf
        end
      end
    end
  end
  'tbsort' rtbf 'fields(bname,c,a)'
  'tbtop' rtbf
  save_btop = 0
  do forever
    zcmd = null
    cc_rc = 0
    newb = null
    zsel = null
    if save_btop > 0 then do
      'tbtop' rtbf
      'tbskip' rtbf 'number('save_btop')'
    end
    'tbdispl' rtbf 'panel(zigifsel)'
    if rc > 4 then leave
    save_btop = ztdtop
    /* ----------------------------- *
    | Workin selected flow          |
    * ----------------------------- */
    if zsel = "S" then do
      x = docmd('cd 'localdir' && git checkout 'bname)
      call Replace localrep zigirep pdshlq qualignr
      call update_repo_metadata
      branch = bname
      leave
    end
  end
  'tbend' rtbf
  rtbf_open = 0
  ztdsels = 0
  zsel = null
  return

  /* ------------------------------------------------------------- *
  | Convert a non-zig repository to enable zigi management.       |
  |  - for this to work the repository must be manually setup     |
  |    by the user after the clone thus:                          |
  |    - All sequential files in the repo root that are z/OS      |
  |      datasets must be renamed to upper case and using z/OS    |
  |      naming conventions.                                      |
  |   - all subdirectories that will be the OMVS copy of a PDS    |
  |     must also be upper case with z/OS naming                  |
  |   - all PDS members must be in their respective OMVS          |
  |     subdirectory without a suffix and follow PDS member       |
  |     name conventions and be upper case                        |
  |                                                               |
  | This routine will call ZIGICNVT and pass the OMVS directory   |
  | for the repository to be converted.                           |
  |                                                               |
  | After conversion the ZIGICKOT routine will be called to copy  |
  | the OMVS files into their respective z/OS datasts (which will |
  | be dynamically allocated)                                     |
  * ------------------------------------------------------------- */
Convert_Repo:
  convdir = localrep'/'zigirep
  'vput (convdir)'
  'Select cmd(%zigicnvt)'
  qualignr = words(translate(pdshlq,' ','.'))
  call Replace localrep zigirep pdshlq qualignr
  return

Do_Tag_Extract:
  do forever
    'Addpop row(3) column(4)'
    'Display Panel(zigitagx)'
    drc = rc
    'Rempop'
    if drc > 0 then do
      zerrsm = 'Canceled.'
      zerrlm = 'Extract canceled.'
      'setmsg msg(isrz003)'
      return
    end
    if tagxpath /= '?'
    then if tagxpath /= null
    then leave
    if tagxpath = '?' then tagxpath = zigiosel()
  end
  zs1 = 'Preparing the extract. This could take a minute'
  zs2 = '(or two) so please be patient.'
  call do_popup
  cmd = 'cd' localrep'/'zigirep
  cmd = cmd "&& git show" tags "| grep '+++'"
  x = docmd(cmd)
  if x > 0 then do
    zerrsm = 'Canceled.'
    zerrlm = 'There is nothing to extract from the selected tags.'
    'setmsg msg(isrz003)'
    return
  end
  parse value '' with files members. omvsfiles
  do ti = 1 to so.0
    if left(so.ti,3) /= '+++' then iterate
    parse value so.ti with . '/'fileo
    if left(fileo,5) = '.zigi' then iterate
    member = null
    if pos('/',fileo) > 0 then parse value fileo with file'/'member
    else file = fileo
    okng = dsnvalid(file)
    if okng = 'OK' then do
      if wordpos(file,files) = 0 then files = files file
      if member /= null then members.file = members.file member
    end
    else omvsfiles = omvsfiles fileo
  end

  /* ------------------------------ *
  | Make the target OMVS Directory |
  * ------------------------------ */
  cmd = 'mkdir' '"'tagxpath'"'
  x = bpxwunix(cmd,,so.,se.)
  if so.0 + se.0 > 0 then call view_std 'B'

  /* ----------------------------------------- *
  | Save a copy of the tag commit information |
  * ----------------------------------------- */
  cmd = 'cd' localrep'/'zigirep '&& git show' tags '>' tagxpath'tag.info'
  x = docmd(cmd)

  /* -------------------------------------------------- *
  | Copy the OMVS filesystem OMVS files from the       |
  | current repository to the new extract directory.   |
  |                                                    |
  | None of the z/OS OMVS elements will be copied.     |
  * -------------------------------------------------- */
  if words(omvsfiles) > 0 then do i = 1 to words(omvsfiles)
    file = word(omvsfiles,i)
    if pos('/',file) > 0 then do
      parse value file with sdir'/'file
      cmd = 'cd' tagxpath '&& mkdir' sdir
      cmd = cmd '&& cd' localrep'/'zigirep'/'sdir
      cmd = cmd '&& cp' file '"'tagxpath''sdir'"'
      x = bpxwunix(cmd,,so.,se.)
      if so.0 + se.0 > 0 then call view_std 'B'
    end
    else do
      cmd = 'cd' localrep'/'zigirep
      cmd = cmd '&& cp -r' file '"'tagxpath'"'
      x = bpxwunix(cmd,,so.,se.)
      if so.0 + se.0 > 0 then call view_std 'B'
    end
  end

  extdd = 'XD'random(99999)
  do i = 1 to words(files)
    f = word(files,i)
    oldfile = Add_DSN_HLQ(f)
    newfile = "'"tagxhlq'.'f"'"
    x = listdsi(oldfile)
    Address TSO
    "alloc f("extdd") new ds("newfile") like("oldfile")" ,
      'dsorg('sysdsorg')'
    'free  f('extdd')'
    if sysdsorg = 'PS' then  do
      'smcopy fds('oldfile') tds('newfile') notrans'
    end
    Address ISPExec
    if words(members.f) > 0 then do
      /* copy PDS and PDS members */
      "lminit dataid(indd1) dataset("oldfile")"
      "lminit dataid(outdd1) dataset("newfile")"
      do im = 1 to words(members.f)
        m = word(members.f,im)
        "lmcopy fromid("indd1") todataid("outdd1") frommem("m") replace"
      end
      "lmfree dataid("indd1")"
      "lmfree dataid("outdd1")"
    end
  end

  /* ----------------------------------------- *
  | DSList the z/OS datasets based on the hlq |
  * ----------------------------------------- */
  if words(files) > 0 then do
    Address ISPExec
    "LMDINIT LISTID(LISTID) LEVEL("tagxhlq")"
    "LMDDISP LISTID("ListId") Confirm(Yes)",
      "View(Volume)"
    "LMDFREE LISTID("ListId")"
  end

  /* ------------------------------------------- *
  | UDList the OMVS directory based on the path |
  * ------------------------------------------- */
  'Select Pgm(isrdslst) Parm(UDL' tagxpath ') SUSPEND'

  return

  /* --------------------------------------------------------- *
  | This routine checks for deletes that are not included     |
  | in the git messages. These would be PDS members that are  |
  | deleted and thus no longer in the OMVS directory and need |
  | to be removed from the z/OS PDS.                          |
  * --------------------------------------------------------- */
Check_For_More_Deletes: Procedure Expose delhlq deletes. ,
    localrep zigirep null

  cmd = 'cd' localrep'/'zigirep '&& ls -lR'
  x = bpxwunix(cmd,,so.,se.)

  dir = null

  do di = 1 to so.0
    if left(so.di,2) = './' then do
      parse value so.di with './'dir':'
      call Get_PDS_Members
    end
    if dir = null then iterate
    if left(so.di,1) /= '-' then iterate
    m = word(so.di,9)
    if wordpos(m,members) = 0 then do
      c = deletes.0 + 1
      deletes.c = dir'/'m
      deletes.0 = c
    end
  end
  return

Get_PDS_Members:
  members = null
  call outtrap 'pdsmems.'
  address tso "listd '"delhlq"."dir"' M"
  call outtrap 'off'
  do gm = 7 to pdsmems.0
    members = members word(pdsmems.gm,1)
  end
  drop pdsmems.
  return

get_dsn_info:
  zdsn. = null
  cmd = 'cat' localrep'/'zigirep'/.zigi/dsn'
  x = bpxwunix(cmd,,s.,e.)
  if x > 0 then return
  do di = 1 to s.0
    zd = word(s.di,1)
    zdsn.zd = word(s.di,6)
    zdsn.0 = zd
  end
  drop s. e.
  return

/* ------------------------------------- *
 * Name:     Lower                       *
 *                                       *
 * Function: Lowercase the provided data *
 *                                       *
 * Syntax:   x=lower(input)              *
 * ------------------------------------- */
Lower: Procedure
  parse arg input
  out = translate(input,"abcdefghijklmnopqrstuvwxyz",,
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
  return out
