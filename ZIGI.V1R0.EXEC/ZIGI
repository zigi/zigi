  /*%NOcomment ----------  rexx procedure  -------------------- *
  | Name:      zigi  (z ISPF Git Interface)                    |
  |                                                            |
  | Version:   V1R0 (november 2019)                            |
  |                                                            |
  | Function:  ISPF Interface to Git for source code           |
  |            management                                      |
  |                                                            |
  | Syntax:    ex 'zigi.v1r0.exec(zigi)'                       |
  |                                                            |
  | NOTE:      ZIGI MUST NEVER be started under the ZIGI       |
  |            ISPF Applications ID.                           |
  |                                                            |
  | Dependencies:                                              |
  |            1. Requires the z/OS port of GIT be installed   |
  |            2. Git setup in /etc/profile or ~/.profile      |
  |                                                            |
  | Authors:   Henri Kuiper                                    |
  |            Lionel B. Dyck                                  |
  |                                                            |
  | History:  (most recent on top, see git log for full info)  |
  |                                                            |
  |            10/24/19 LBD - Change 2 routines to procedure   |
  |                         - Add Commit message               |
  |            10/21/19 LBD - Use PARSE SOURCE for hlq         |
  |            10/20/19 HBK - Fix LMM things :)                |
  |            10/19/19 LBD - Better prefix, scrolling etc.    |
  |            10/17/19 HBK - Add back LMM, cleanup code       |
  |            09/30/19 HBK - Major rewrite :)                 |
  |            07/24/19 HBK - Some git functions               |
  |            06/15/19 HBK - Autofind git binary              |
  |            06/14/19 LBD - Major updates                    |
  |            06/12/19 LBD - Major updates                    |
  |            06/11/19 LBD - Creation                         |
  |                                                            |
  | ---------------------------------------------------------- |
  |   Copyleft (C) 2019                                        |
  * ---------------------------------------------------------- */
  Address ISPExec
  'vget (zapplid)'
  "Control Errors Return"

  parse value '' with null
  /* ----------------------------------------------------- *
  | Get the Active HLQ for use with the ALTLIB and LIBDEF |
  | of the zIGI libraries.                                |
  | 1st Get the active exec library or dd                 |
  * ----------------------------------------------------- */
  parse source x1 x2 x3 x4 exec .
  if exec = '?' then do
    x = listdsi(x4 'FILE')
    exec = sysdsname
  end
  /* ------------------------------------------ *
  | Now extract the HLQ for the Panels Library |
  * ------------------------------------------ */
  zigihlq = translate(exec,' ','.')
  zigihlq = subword(zigihlq,1,words(zigihlq)-1)
  zigihlq = translate(zigihlq,'.',' ')
  /* ---------------------------------------------- *
  | Fully qualify the EXEC and PANELS library dsns |
  * ---------------------------------------------- */
  exec = "'"exec"'"
  panels = "'"zigihlq".PANELS'"

  /* ---------------------------------------- *
  | If panels/exec then libdef and/or altlib |
  | but only if not under ZIGI applid.       |
  * ---------------------------------------- */
  if zapplid /= 'ZIGI' then do
    if panels /= null then
    'libdef ispplib dataset id('panels') stack'
    if exec /= null then
    Address TSO 'altlib act application(exec) dataset('exec')'
  end

  /* ----------------------------------------------------------- *
  | Check for running under the ZIGI ISPF application ID and if |
  | not then recurse into it.                                   |
  * ----------------------------------------------------------- */
  if zapplid <> "ZIGI" then do
    /* --------------------------------------- *
    | Make sure we are under the ZIGI applid  |
     * --------------------------------------- */
    "Select CMD(%zigi) Newappl(ZIGI) Passlib"
    if panels /= null then
    'libdef ispplib'
    if exec /= null then
    Address TSO 'altlib deact application(exec)'
    exit 0
  end

  /* ---------------------------------------------------------------- *
  | Running under the ZIGI ISPF Application ID so let's do some work |
  * ---------------------------------------------------------------- */
  zcmd = null
  'display panel(zigispls)'
  if rc = 8 then exit

  /* ------------------------------------ *
  | define our working default variables |
  * ------------------------------------ */
  zerrhm   = 'zigih00'
  zerralrm = 'NO'
  cmd = 'pwd'
  x = bpxwunix(cmd,,so.,se.)
  home    = strip(so.1)
  keyfile = home'/.ssh/id_rsa.pub'
  rtbl = 'ZIGL'random(9999)
  rtll = 'ZIGM'random(9999)
  rtbl_open = 0

  /* ------------------------------------ *
  | Let's try to find git.               |
  * ------------------------------------ */
  zs1 = 'Checking if you have git installed'
  zs2 = 'Please standby'
  call pfshow 'off'           /* make sure pfshow is off */
  'Control Display Lock'
  'Addpop row(4) column(12)'
  'Display Panel(zigipop)'

  cmd = docmd('command -v git')
  x = bpxwunix(cmd,,so.,se.)

  if so.0 = 1 then do
    zigigitl = strip(so.1)
    'vput (zigigitl) profile'
    'Rempop'
    call pfshow 'reset'         /* restore pfshow setting */
  end
  else do
    /* needs a nice error panel with a link to download git */
    say "Git not installed, or not in path. Check /etc/profile"
    say "Download via rocket, see installer on github gists."
    exit(0)
  end

  /* ------------------------------------------ *
  | Check for GIT Userid and if not found      |
  | then prompt for it along with a GIT E-Mail |
  | Find the SSH key and if not there generate |
  * ------------------------------------------ */
  zs1 = 'Checking for user.name and user.email'
  zs2 = 'Please standby'
  call pfshow 'off'           /* make sure pfshow is off */
  'Control Display Lock'
  'Addpop row(4) column(12)'
  'Display Panel(zigipop)'
  cmd = docmd('git config --global user.name')
  x = bpxwunix(cmd,,so.,se.)
  if x = 0 then do
    zigiuid = so.1
  end
  else do
    zigiuid = ''
  end
  cmd = docmd('git config --global user.email')
  x = bpxwunix(cmd,,so.,se.)

  if x = 0 then do
    zigimail = so.1
  end
  else do
    zigimail = ''
  end
  'Rempop'
  call pfshow 'reset'         /* restore pfshow setting */
  cmd = 'cat 'home'/.ssh/id_rsa.pub'
  x = bpxwunix(cmd,,so.,se.)
  if x > 0 then do
    zs1 = 'No SSH identity found in 'home'/.ssh/id_rsa'
    zs2 = 'Generating keypair, please standby'
    call pfshow 'off'           /* make sure pfshow is off */
    'Control Display Lock'
    'Addpop row(4) column(12)'
    'Display Panel(zigipop)'
    cmd = 'mkdir -p 'home'/.ssh'
    x = bpxwunix(cmd,,so.,se.)
    cmd = 'cd 'home' && ssh-keygen -t rsa -f .ssh/id_rsa'
    x = bpxwunix(cmd,,so.,se.)
    cmd = 'cat 'home'/.ssh/id_rsa.pub'
    x = bpxwunix(cmd,,so.,se.)
    'Rempop'
    call pfshow 'reset'         /* restore pfshow setting */
  end
  zigissh = so.1
  /* need these to see if changed, then we need to
  redo the command...... @lionel: there's probably
  a nicer way to do this (via the panel that sees if
  the value has changed?
  */
  old_zigiuid = zigiuid
  old_zigimail = zigimail
  /* end of save old values */

  /* this needs refactored :) */
  if zigiuid = '' | zigimail = '' then do
    hit = 0
  end
  else do
    hit = 1
  end
  do forever
    if hit = 1 then leave
    'Display Panel(zigiset)'
    /* dunno if we still need these in the profile?? */
    'VPut (zigiuid zigimail zigissh) Profile'
    /* maybe we could use the ispprof for some lazy caching */
    /* now that we've had the user see the settings.
    set the git config if they have changed...
    */
    if old_zigiuid /= zigiuid then do
      cmd = docmd('git config --global user.name "'zigiuid'"')
      x = bpxwunix(cmd,,so.,se.)
      if x > 0 then do
        say "something went wrong with git config user.name"
        say so.1
        say se.1
      end
      cmd = docmd('git config --global user.email "'zigimail'"')
      x = bpxwunix(cmd,,so.,se.)
      if x > 0 then do
        say "something went wrong with git config user.email"
        say so.1
        say se.1
      end
      /* Let's adopt the new style. Only push current branch */
      cmd = docmd('git config --global push.default simple')
      x = bpxwunix(cmd,,so.,se.)
    end
    'VPut (zigiuid zigimail zigissh) Profile'
    zerrsm = 'Updated.'
    zerrlm = 'zIGI Settings updated successfully.'
    'Setmsg msg(isrz002)'
    if zigiuid /= null
    then if zigimail /= null
    then if zigissh /= null
    then do forever
      zcmd = null
      'Display Panel(zigisshk)'
      if rc > 0 then do
        hit = 1
        leave
      end
    end
  end

  /* ---------------------------------------- *
  | Open (or create and open) the Repo Table |
  * ---------------------------------------- */
  'TBOpen zigirepo Library(isptabl) Write'
  if rc > 0 then do
    if rc = 8 then do
      "TBCreate zigirepo Keys(zigirep)",
        "Names(localrep pdshlq)",
        "Library(isptabl) Write"
      "TBSort   isptabl Fields(zigirepo,N,A)"
      "TBSAVE zigirepo REPLCOPY LIBRARY(isptabl)"
    end
    if rc > 8 then do
      'setmsg msg(isrz002)'
    end
  end

  do forever
    zsel = null
    zcmd = null
    'tbdispl zigirepo panel(zigiprim)'
    if rc > 0 then leave
    Select
      When abbrev('CREATE',zcmd,2) = 1 then call Create_Repo
      When abbrev('CLONE',zcmd,2) = 1 then call Clone_Repo
      When abbrev('CONFIG',zcmd,2) = 1 then do forever
        zcmd = null
        'display panel(zigiset)'
        /* TODO: Add code to apply the new settings..... */
        if rc = 0 | rc = 8 then leave
      end
      When abbrev('SSH',zcmd,2) = 1 then do forever
        zcmd = null
        'display panel(zigisshk)'
        if rc > 0 then leave
      end
      When zsel = 'S' then call Work_With_Repo
      When zsel = 'D' then do
        /* delete the repo. Maybe needs a 'are you sure' :)
        for now. we delete the table from ispfprof and
        make sure we cleanup the repodir...
        does not touch z/OS datasets                   */
        cmd = 'cd' localrep' && rm -rf 'zigirep
        x = bpxwunix(cmd,,so.,se.)
        'tbdelete zigirepo'
      end
      Otherwise nop
    End
  end

  'tbend' rtbl
  'tbclose zigirepo'
  Exit 0

  /* --------------------------------- *
  | Work with the selected repository |
  * --------------------------------- */
Work_With_Repo:
  parse value '' with dsn dsnstat zsel
  call update_repo_metadata
  /* -------------------------------- *
  | Process the Repository Data Sets |
  * -------------------------------- */
  do forever
    zsel = null
    zcmd = null
    'TBdispl' rtbl 'Panel(zigirepo)'
    if rc > 4 then leave
    drop so. se.
    zcmd = translate(zcmd)
    Select
      When abbrev('BRANCH',zcmd,2) = 1 then call Branch_it
      /* -------------------------------- *
      | View output of git log           |
      * -------------------------------- */
      When abbrev('GITLOG',zcmd,2) = 1 then do
        zcmd = null
        cmd = 'cd' localdir' && git log'
        cmd = docmd(cmd)
        x = bpxwunix(cmd,,so.,se.)
        call view_std
      end
      /* -------------------------------- *
      | Push current branch to origin    |
      * -------------------------------- */
      When abbrev('PUSH',zcmd,2) = 1 then do
        cmd = 'cd' localdir' && git push'
        cmd = docmd(cmd)
        call pop 'Pushing Updates to Remote Git'
        x = bpxwunix(cmd,,so.,se.)
        call view_std
        if se.0 > 0 then call view_std 'E'
      end
      /* --------------------------------------------------------- *
      | Pull latest version of remote current branch from origin  |
      * --------------------------------------------------------- */
      When abbrev('PULL',zcmd,3) = 1 then do
        cmd = 'cd' localdir' && git pull'
        cmd = docmd(cmd)
        call pop 'Pulling from remote'
        x = bpxwunix(cmd,,so.,se.)
        call view_std
        if se.0 > 0 then do
          call view_std 'E'
        end
        call Refresh localrep,zigirep,pdshlq
      end
      /* --------------------------------------------------------- *
      | Add a PDS or a Sequential File to "Working Directory"     |
      * --------------------------------------------------------- */
      When abbrev('ADD',zcmd,3) = 1 then do
        zcmd = null
        WHAT = null
        'display panel(zigiadd)'
        /* so we want to add dataset/member */
        zs1 = 'Copying selected datasets to OMVS'
        zs2 = 'Patience . . .'
        call pfshow 'off'           /* make sure pfshow is off */
        'Control Display Lock'
        'Addpop row(4) column(12)'
        'Display Panel(zigipop)'
        'Rempop'
        DIR=localrep'/'zigirep
        If POS('(', WHAT) > 0
        then do
          parse var WHAT PDS'('MEM')'
          PDS = strip(PDS,"B","'")
          PDS = usssafe(PDS)
          mkdir = "mkdir -p "DIR"/"PDS
          call bpxwunix mkdir
          target = "'"DIR"/"PDS"/"MEM"'"
          copycmd = "//'"WHAT"'"
          copycmd = '"'copycmd'"'
          copycmd = "cp -U -M" copycmd" "DIR"/"PDS"/"
          call bpxwunix copycmd
        end
        else do
          FC = LISTDSI("'"WHAT"'")
          if SYSDSORG = 'PO' then do
            parse VAR WHAT PDS
            PDS = strip(PDS,"B","'")
            PDS = usssafe(PDS)
            mkdir = "mkdir -p "DIR"/"PDS
            call bpxwunix mkdir
            copycmd = "//'"PDS"'"
            copycmd = '"'copycmd'"'
            copycmd = "cp -U -M" copycmd" "DIR"/"PDS"/"
            call bpxwunix copycmd
          end
          else do
            WHAT = usssafe(WHAT)
            copycmd = "//'"WHAT"'"
            copycmd = '"'copycmd'"'
            copycmd = "cp -U -M" copycmd" "DIR"/"WHAT
            call bpxwunix copycmd
          end
        end
        call pfshow 'reset'         /* restore pfshow setting */
        call update_repo_metadata
      end
      /* -------------------------------- *
      | View output of git status        |
      * -------------------------------- */
      When abbrev('STATUS',zcmd,2) = 1 then do
        zcmd = null
        cmd = 'cd' localrep'/'zigirep
        cmd = docmd(cmd || '&& git status')
        x = bpxwunix(cmd,,so.,se.)
        call view_std
      end
      /* -------------------------------- *
      | Refresh z/OS datasets            |
      * -------------------------------- */
      When abbrev('REFRESH',zcmd,3) = 1 then do
        zcmd = null
        call Refresh localrep,zigirep,pdshlq
      end
      /* -------------------------------- *
      | GIT GREP                         |
      * -------------------------------- */
      When abbrev('GREP',zcmd,3) = 1 then do
        zcmd = null
        'display panel(zigigrep)'
        cmd = 'cd' localrep'/'zigirep
        cmd = docmd(cmd || '&& git grep "'grep'"')
        x = bpxwunix(cmd,,so.,se.)
        call View_std
        call View_std E
      end
      /* -------------------------------- *
      | Commit to current branch         |
      * -------------------------------- */
      When abbrev('COMMIT',zcmd,3) = 1 then do
        zcmd = null
        msg = ''
        'display panel(zigicom)'
        cmd = 'cd' localrep'/'zigirep
        cmd = docmd(cmd || '&& git commit -m "'msg'"')
        x = bpxwunix(cmd,,so.,se.)
        if x = 0
        then call view_std
        else call view_std 'E'
        call update_repo_metadata
        call view_std
      end
      /* -------------------------------- *
      | Add/replace remote URI (origin)  |
      * -------------------------------- */
      When abbrev('REMOTE',zcmd,3) = 1 then do
        zcmd = null
        'display panel(zigiremo)'
        parse var origin guser '@' host ':' rest
        cmd = 'touch 'home'/.ssh/known_hosts && '
        cmd = cmd || 'ssh-keyscan -t rsa,dsa 'host
        cmd = cmd || ' 2>&1 | sort -u - 'home'/.ssh/known_hosts >'
        cmd = cmd || ' 'home'/.ssh/tmp_hosts && '
        cmd = cmd || 'mv 'home'/.ssh/tmp_hosts 'home'/.ssh/known_hosts'
        x = bpxwunix(cmd,,so.,se.)
        cmd = 'cd' localrep'/'zigirep
        cmd = docmd(cmd || '&& git remote add origin 'origin)
        x = bpxwunix(cmd,,so.,se.)
        call View_std
        call View_std E
        cmd = 'cd' localrep'/'zigirep
        cmd = docmd(cmd || '&& git push -u origin 'branch)
        x = bpxwunix(cmd,,so.,se.)
        call View_std
        call View_std E
        call update_repo_metadata
      end
      /* -------------------------------- *
      | Work with a repo item            |
      * -------------------------------- */
      When zsel = 'S' then do
        zs1 = 'Building list of library statuses....'
        zs2 = 'Patience . . .'
        call pfshow 'off'           /* make sure pfshow is off */
        'Control Display Lock'
        'Addpop row(4) column(12)'
        'Display Panel(zigipop)'
        'Rempop'
        call pfshow 'reset'         /* restore pfshow setting */
        'TBCreate' rtll 'Names(mem memstat pdshlq ussmem) replace NoWrite'
        /* Determine if the repo item is a PDS or a flat-file */
        cmd = "[[ -f "localrep"/"zigirep"/"dsn" ]] && echo f"
        x = bpxwunix(cmd,,so.,se.)
        if so.0 = 1 & so.1 = "f" then do
          /* Do this if it's a regular file (sequential in z/OS) */
          if pdshlq <> "" then
          edsn = pdshlq"."dsn
          else
          edsn = dsn
          "Edit Dataset('"edsn"')"
          /* so after the edit, we should update it to working directory */
          edsn = usssafe(edsn)
          copcm = "//'"edsn"'"
          copcm = 'cp -U -M "'copcm'" 'localrep'/'zigirep'/'dsn
          call bpxwunix copcm
          dsnstat = '*Edit'
        end
        else do
          /* Do this if it's a directory */
          address syscall
          'readdir 'localrep'/'zigirep'/'dsn' root.'
          address ispexec
          do i = 1 to root.0
            /* for all files but not . or .. */
            if root.i = "." | root.i = ".." then do
              iterate
            end
            else do
              mem = root.i
              memstat = ''
              do ii = 1 to stats.0
                /* see if we have this file in git status */
                stat = substr(stats.ii,1,2)
                thepath = substr(stats.ii,3)
                parse var thepath FOLDER "/" MEMBER
                if mem = MEMBER then do
                  memstat = porcelain(stat)
                  if FOLDER = "./" & stat = "??" then
                  memstat = 'Untracked'
                  leave
                end
              end
            end
            /* The files in USS have some chars changed due to cp -M */
            /* So we fix the name before we save to table :) */
            ussmem = mem
            mem = strreplace(mem '.' '#')
            mem = strreplace(mem '_' '@')
            mem = strreplace(mem '-' '$')
            'tbadd' rtll
          end
          'tbtop' rtll
          /* ---------------------------------- *
          | Process the Member list until done |
          * ---------------------------------- */
          Do Forever
            zsel = ''
            zcmd = ''
            'TBdispl' rtll 'Panel(zigilist)'
            if rc > 0 then do
              'tbend' rtll
              leave
            end
            /* Make sure we edit (and copy) right dataset when we have
            a prefix set */
            if pdshlq <> "" then
            edsn = pdshlq"."dsn
            else
            edsn = dsn
            select
              when zsel = 'S' then do
                /* -------------------------------- *
                | Edit member of a PDS             |
                * -------------------------------- */
                "Edit Dataset('"edsn"("mem")'"
                if rc = 0 then do
                  memstat = 'Modified'
                  'TBPut' rtll
                end
                /* so after the edit, we should update it to repo */
                mem = usssafe(mem)
                edsn = usssafe(edsn)
                copcm = "//'"edsn"("mem")'"
                copcm = 'cp -U -M "'copcm'" 'localrep'/'zigirep'/'dsn'/'ussmem
                call bpxwunix copcm
              end
              when zsel = 'A' then do
                /* -------------------------------- *
                | Add member of PDS to staging area|
                * -------------------------------- */
                d = usssafe(dsn)
                cmd = 'cd' localrep'/'zigirep'/'d
                /* These cp -M issues are really getting annoying */
                m = strreplace(mem '#' '.')
                m = strreplace(m '$' '-')
                m = strreplace(m '@' '_')
                cmd = docmd(cmd || ' && git add 'm)
                x = bpxwunix(cmd,,so.,se.)
                memstat = 'Added'
                'tbput' rtll
                if ztdsels = 1 then
                call update_repo_metadata
              end
              when zsel = 'D' then do
                /* -------------------------------- *
                | Show the diff for the member     |
                * -------------------------------- */
                d = usssafe(dsn)
                cmd = 'cd' localrep'/'zigirep'/'d
                /* These cp -M issues are really getting annoying */
                m = strreplace(mem '#' '.')
                m = strreplace(m '$' '-')
                m = strreplace(m '@' '_')
                cmd = docmd(cmd || ' && git diff 'm)
                x = bpxwunix(cmd,,so.,se.)
                call View_std
              end
              otherwise nope
            end
          end
        end
      end
      /* -------------------------------- *
      | Add repo item to staging area    |
      * -------------------------------- */
      When zsel = 'A' then do
        d = usssafe(dsn)
        cmd = 'cd' localrep'/'zigirep
        cmd = docmd(cmd || ' && git add 'd)
        x = bpxwunix(cmd,,so.,se.)
        call update_repo_metadata
      end
      Otherwise nope
    end
  end
  if ztdsels = 1 then do
    'tbend' rtbl
    rtbl_open = 0
    call work_with_repo
  end
  return

  /* ----------------------------- *
  | Clone a remote repo           |
  * ----------------------------- */
Clone_Repo:
  do forever
    zcmd = null
    cc_rc = 0
    'Display Panel(zigicc)'
    if rc > 0 then return
    if localrep = "?" then
    localrep = zigiosel()
    parse var remote site ':' user '/' zigirep '.git'
    parse var site guser '@' host
    /* Let's clone the remote repo... */
    zs1 = "Cloning "zigirep" by "user
    zs2 = "from "host
    call pfshow 'off'           /* make sure pfshow is off */
    'Control Display Lock'
    'Addpop row(4) column(12)'
    'Display Panel(zigipop)'
    cmd = 'touch 'home'/.ssh/known_hosts && '
    cmd = cmd || 'ssh-keyscan -t rsa,dsa 'host
    cmd = cmd || ' 2>&1 | sort -u - 'home'/.ssh/known_hosts >'
    cmd = cmd || ' 'home'/.ssh/tmp_hosts && '
    cmd = cmd || 'mv 'home'/.ssh/tmp_hosts 'home'/.ssh/known_hosts'
    x = bpxwunix(cmd,,so.,se.)
    cmd = docmd('cd 'localrep' && git clone 'remote)
    x = bpxwunix(cmd,,so.,se.)
    'Rempop'
    call pfshow 'reset'         /* restore pfshow setting */
    if x > 0 then do
      zs1 = 'Clone failed'
      zs2 = se.1
      call pfshow 'off'           /* make sure pfshow is off */
      'Control Display Lock'
      'Addpop row(4) column(12)'
      'Display Panel(zigipop)'
      address 'SYSCALL' 'SLEEP (2)'
      'Rempop'
      call pfshow 'reset'         /* restore pfshow setting */
      leave
    end
    /* Check to see if this is a zigi-managed repo */
    cmd = '[[ ! -d 'localrep'/'zigirep'/.zigi ]] && echo 0'
    x = bpxwunix(cmd,,so.,se.)
    if so.0 = 1 & so.1 = 0 then do
      zs1 = 'Clone failed'
      zs2 = zigirep' is not a zigi-managed repo'
      call pfshow 'off'           /* make sure pfshow is off */
      'Control Display Lock'
      'Addpop row(4) column(12)'
      'Display Panel(zigipop)'
      x = bpxwunix('rm -rf 'localrep'/'zigirep,,so.,se.)
      address 'SYSCALL' 'SLEEP (2)'
      'Rempop'
      call pfshow 'reset'         /* restore pfshow setting */
      leave
    end
    call Refresh localrep,zigirep,pdshlq
    Address ISPExec
    'tbadd zigirepo'
    "TBSAVE zigirepo REPLCOPY LIBRARY(isptabl)"
    zerrsm = 'Complete'
    zerrlm = zigirep 'has been added/updated in the table'
    'setmsg msg(isrz002)'
    leave
  end
  return



  /* ----------------------------- *
  | Refresh z/OS side of repo     |
  * ----------------------------- */
Refresh:
  parse arg localrep,zigirep,pdshlq,nodel
  zs1 = "Refreshing from repo"
  zs2 = "   USS -> z/OS      "
  call pfshow 'off'           /* make sure pfshow is off */
  'Control Display Lock'
  'Addpop row(4) column(12)'
  'Display Panel(zigipop)'
  address 'SYSCALL' 'SLEEP (2)'
  cmd = docmd('cd 'localrep' && git clone 'remote)
  x = bpxwunix(cmd,,so.,se.)
  /* All is well. Let's bring this stuff to z/OS */
  address syscall
  'readdir 'localrep'/'zigirep' root.'
  address ispexec
  do i = 1 to root.0
    dsnstat = ''
    if root.i = "." | root.i = ".." then do
      /* skip the . and .. things */
      iterate
    end
    else do
      if dsnvalid(root.i) = "OK" then do
        /* this is a valid DSN, check if dir or file */
        t='unknown'
        cmd = '[[ -d 'localrep'/'zigirep'/'root.i' ]] && echo d'
        x = bpxwunix(cmd,,so.,se.)
        if so.0 = 1 & so.1 = 'd' then do
          t='dir'
        end
        cmd = '[[ -f 'localrep'/'zigirep'/'root.i' ]] && echo f'
        x = bpxwunix(cmd,,so.,se.)
        if so.0 = 1 & so.1 = 'f' then do
          t='file'
        end
        if pdshlq <> "" then
        target = pdshlq"."root.i
        else
        target = root.i
        meh = OUTTRAP('var')
        if t = 'dir' then do
          /* Git is always leading, refreshes delete z/OS stuff */
          /* But we have a 'fallback' in case we need it... */
          if nodel = "" then
          ADDRESS "TSO" "DELETE '"target"'"
          if sysdsn(target) == "DATASET NOT FOUND" then do
            /* create if not there */
            ADDRESS "TSO" "ALLOC DD(DD) DS('"target"') NEW",
              "DSORG(PO) RECFM(F B) LRECL(80) SPACE(1, 5) DIR(24) CYLINDERS"
            ADDRESS "TSO" "FREE FILE(DD)"
          end
          /* get all the members from the dir */
          address syscall
          'readdir 'localrep'/'zigirep'/'root.i'/ mems.'
          address ispexec
          do ii = 1 to mems.0
            if mems.ii = "." | mems.ii = ".." then do
              /* skip the . and .. things */
              iterate
            end
            src = localrep"/"zigirep"/"root.i"/"mems.ii
            /* fix the cp -M behavior on the way in */
            m = strreplace(mems.ii '.' '#')
            m = strreplace(m '_' '@')
            m = strreplace(m '-' '$')
            ADDRESS TSO
            'OGET' "'"src"'" "'"target"("m")'"
            /* Set statistics */
            address ispexec
            "LMINIT DATAID(DATAID) Dataset('"target"')"
            "LMOPEN DATAID("dataid")"
            "LMMSTATS DATAID("dataid") Member("m") User(ZIGI)"
            "LMCLOSE DATAID("dataid")"
            "LMFREE  DATAID("dataid")"
          end
        end
        if t = 'file' then do
          /* it'a file, just oget it over */
          ADDRESS TSO
          /* TODO: supress messages */
          'OGET' "'"localrep"/"zigirep"/"root.i"'" "'"target"'"
          address ispexec
        end
      end
    end
  end
  meh = OUTTRAP('OFF')
  'Rempop'
  call pfshow 'reset'         /* restore pfshow setting */
  return

  /* ----------------------------- *
  | Branch management             |
  * ----------------------------- */
Branch_it:
  rtbb = 'ZIGB'random(9999)
  'TBCreate' rtbb 'Names(bname) Replace NoWrite'
  localdir = localrep'/'zigirep
  cmd = docmd('cd 'localdir' && git branch -a')
  x = bpxwunix(cmd,,so.,se.)
  bl. = ''
  bl.0 = 0
  do i = 1 to so.0
    b1 = strip(so.i,'B')
    if pos('/',b1) > 0 then do
      /* this is a remote branch we (maybe) have never checked out */
      seen_this_branch = 0
      parse var b1 remotes'/'origin'/'bname zooi
      do ii = 1 to bl.0
        if bl.ii = bname then seen_this_branch = 1
      end
      /* but only add it to table if we haven't yet */
      if seen_this_branch = 0 then do
        if bname <> branch & bname <> "HEAD" then do
          ni = bl.0 + 1
          bl.ni = bname
          bl.0 = ni
          'tbadd' rtbb
        end
      end
    end
    else do
      /* this is already a local branch */
      if pos('*',b1) = 0 then do
        /* Add it to the table if it's not the current (*) branch */
        bname = so.i
        ni = bl.0 + 1
        bl.ni = b1
        bl.0 = ni
        'tbadd' rtbb
      end
    end
  end
  'tbtop' rtbb
  do forever
    zcmd = null
    cc_rc = 0
    newb = ''
    'tbdispl' rtbb 'panel(zigibra)'
    if rc > 0 then return
    if newb <> "" then do
      /* ----------------------------- *
      | Create this new branch, switch|
      * ----------------------------- */
      localdir = localrep'/'zigirep
      cmd = docmd('cd 'localdir' && git checkout -b 'newb)
      x = bpxwunix(cmd,,so.,se.)
      cmd = docmd('cd 'localdir' && git push -u origin 'newb)
      x = bpxwunix(cmd,,so.,se.)
      branch = newb
      return
    end
    /* ----------------------------- *
    | Checkout the selected bname   |
    * ----------------------------- */
    if zsel = "C" then do
      cmd = docmd('cd 'localdir' && git status --porcelain')
      x = bpxwunix(cmd,,so.,se.)
      if so.0 > 0 then do
        zs1 = 'Cannot checkout branch.'
        zs2 = so.1
        call pfshow 'off'           /* make sure pfshow is off */
        'Control Display Lock'
        'Addpop row(4) column(12)'
        'Display Panel(zigipop)'
        cmd = docmd('sleep 2')
        address 'SYSCALL' 'SLEEP (2)'
        'Rempop'
        call pfshow 'reset'         /* restore pfshow setting */
      end
      cmd = docmd('cd 'localdir' && git checkout 'bname)
      x = bpxwunix(cmd,,so.,se.)
      call Refresh localrep,zigirep,pdshlq
      branch = bname
      return
    end
    if zsel = "D" then do
      cmd = docmd('cd 'localdir' && git branch -d 'bname)
      x = bpxwunix(cmd,,so.,se.)
      'tbdelete' rtbb
      zerrsm = 'Deleted.'
      zerrlm = 'Branch 'bname' succesfully deleted'
      'Setmsg msg(isrz002)'
      return
    end
  end
  return

Create_Repo:
  do forever
    zcmd = null
    zigirep = null
    cc_rc = 0
    pdshlq = ''
    'Display Panel(ziginew)'
    if rc > 0 then return
    if localrep = '?' then
    localrep = zigiosel()
    /* ---------------------------------------------------- *
    | We do some basic git repo setup here...              |
    | Fair warning, it's going to be very verbose.         |
    | But that eases feature adding :)                     |
    * ---------------------------------------------------- */
    /* test if localrep is present */
    cmd = '[[ -d 'localrep' ]] && echo 1'
    x = bpxwunix(cmd,,so.,se.)
    if so.0 = 1 & so.1 = 1 then do
      /* ok, localrep is there. better not have zigirep */
      cmd = '[[ -d 'localrep'/'zigirep' ]] && echo 1'
      x = bpxwunix(cmd,,so.,se.)
      if so.0 = 1 & so.1 = 1 then do
        zerrsm = "FAILED"
        zerrlm = "Error: "localrep"/"zigirep" exists."
        'setmsg msg(isrz002)'
        leave
      end
    end
    /* If we made it here, we can freely git init */
    zs1 = 'Creating your repository'
    zs2 = 'Please standby'
    call pfshow 'off'           /* make sure pfshow is off */
    'Control Display Lock'
    'Addpop row(4) column(12)'
    'Display Panel(zigipop)'

    cmd = docmd('cd 'localrep' && git init 'zigirep)
    x = bpxwunix(cmd,,so.,se.)
    /* The git repo is initialized. Time to stick a
    .gitattributes (ASCII) in there */
    call syscalls 'ON'
    address syscall
    path = localrep"/"zigirep"/.ga"
    'open' path,
      O_rdwr+O_creat+O_trunc,
      660
    if retval = -1 then do
      say "Something bad when creating .gitattributes. Make errormsg"
      leave
    end
    fd = retval  /* as I think it's weird to write to a retval lol */
    ga1  = "# This .gitattributes file is autogenerated with zigi v1r0"
    ga2  = "*   git-encoding=iso8859-1 zos-working-tree-encoding=ibm-1047"
    ga3a = ".gitattributes    "
    ga3b = "git-encoding=iso8859-1 zos-working-tree-encoding=iso8859-1"
    ga3  = ga3a || ga3b
    ga4a = ".gitignore        "
    ga4b = "git-encoding=iso8859-1 zos-working-tree-encoding=iso8859-1"
    ga4  = ga4a || ga4b
    ga1 = ga1 || esc_r || esc_n
    ga2 = ga2 || esc_r || esc_n
    ga3 = ga3 || esc_r || esc_n
    ga4 = ga4 || esc_r || esc_n
    'write' fd 'ga1' length(ga1)
    'write' fd 'ga2' length(ga2)
    'write' fd 'ga3' length(ga3)
    'write' fd 'ga4' length(ga4)
    'close' fd
    /* -------------------- .gitattributes written ----------- */
    /*             UNFORTUNATELY, IT'S IN EBCDIC :(            */
    /* ------------------------------------------------------- */
    reporoot = localrep'/'zigirep'/'
    /* convert to iso8859-1 */
    cmd = 'cd 'localrep'/'zigirep' && '
    cmd = cmd || 'iconv -f ibm-1047 -t iso8859-1 .ga'
    cmd = cmd || ' > .gitattributes'
    x = bpxwunix(cmd,,so.,se.)

    /* delete the .ga file */
    cmd = 'cd 'localrep'/'zigirep' && rm -rf .ga'
    x = bpxwunix(cmd,,so.,se.)

    /* tag it and bag it */
    cmd = 'cd 'localrep'/'zigirep' && '
    cmd = cmd || 'chtag -tc iso8859-1 .gitattributes'
    x = bpxwunix(cmd,,so.,se.)


    /* Create the .zigi folder in the repo and add the dsn-file */
    cmd = 'cd 'localrep'/'zigirep' && mkdir .zigi'
    x = bpxwunix(cmd,,so.se.)

    /* Fill dsn file with the comments */
    path = localrep"/"zigirep"/.zigi/dsn"
    'open' path,
      O_rdwr+O_creat+O_trunc,
      660
    if retval = -1 then do
      say "Something bad when creating .gitattributes. Make errormsg"
      leave
    end
    fd = retval  /* as I think it's weird to write to a retval lol */
    ga1  = "# zigi v1.0 dsn-file "
    ga2  = "# This file needs to be here."
    ga3  = "# Don't edit unless you know what you're doing :)"
    ga1 = ga1 || esc_r || esc_n
    ga2 = ga2 || esc_r || esc_n
    ga3 = ga3 || esc_r || esc_n
    'write' fd 'ga1' length(ga1)
    'write' fd 'ga2' length(ga2)
    'write' fd 'ga3' length(ga3)
    'close' fd

    /* ------------------ Let's make our first commit :)       */
    cmd = docmd('cd 'reporoot' && git add .gitattributes')
    x = bpxwunix(cmd,,so.,se.)

    cmd = docmd('cd 'reporoot' && git add .zigi/dsn')
    x = bpxwunix(cmd,,so.,se.)

    commitmsg = "added by zigi v1r0 for "
    commitmsg = commitmsg || MVSVAR('SYMDEF','JOBNAME')
    commitmsg = commitmsg || " on "
    commitmsg = commitmsg || MVSVAR('SYSNAME')
    cmd = docmd('cd 'reporoot' && git commit -m "'commitmsg'"')
    x = bpxwunix(cmd,,so.,se.)

    Address ISPExec
    'Rempop'
    call pfshow 'reset'         /* restore pfshow setting */

    'tbadd zigirepo'
    "TBSAVE zigirepo REPLCOPY LIBRARY(isptabl)"
    zerrsm = 'Complete'
    zerrlm = zigirep 'has been added/updated in the table'
    'setmsg msg(isrz002)'
    leave
  end
  return

  /* ---------------------------------------------------------- *
  | Generalized routine to view stdout. (so.) or stderr. (se.) |
  | based on the parm passed                                   |
  * ---------------------------------------------------------- */
view_std:
  arg stdopt
  /* ------------------------------- *
  | Randomly define a DDName to use |
  * ------------------------------- */
  dd = 'dd'random(9999)
  /* ------------------------------------------ *
  | Allocate a temporary data set for our data |
  * ------------------------------------------ */
  Address TSO
  'Alloc f('dd') new spa(5,5) tr' ,
    'recfm(v b) lrecl(80) blksize(0)'
  /* ------------------------------- *
  | Replace null records with blank |
  * ------------------------------- */
  if stdopt = null then
  do xi = 1 to so.0
    if so.xi = null
    then so.xi = ' '
  end
  else do xi = 1 to se.0
    if se.xi = null
    then se.xi = ' '
  end
  /* ----------------------- *
  | Write out the stem data |
  * ----------------------- */
  if stdopt = null
  then 'Execio * diskw' dd '(finis stem so.'
  else 'Execio * diskw' dd '(finis stem se.'
  /* -------------------------------------------------- *
  | Access the Temporary Data Set using ISPF           |
  | Library Services.                                  |
  | Then using ISPF Browse service to browse the data. |
  | And use Library Services to Free the Data Set.     |
  * -------------------------------------------------- */
  Address ISPExec
  'lminit dataid(ddb) ddname('dd')'
  'browse dataid('ddb') panel(zigibrow)'
  'lmfree dataid('ddb')'
  /* ----------------------------- *
  | Last Free the z/OS Allocation |
  * ----------------------------- */
  Address TSO ,
    'Free f('dd')'
  return


  /* -------------------------------------------------------- *
  | This routine will generate the users personal SSH Public |
  | Key.                                                     |
  * -------------------------------------------------------- */
Build_SSH:
  parse value '' with zigissh
  zs1 = 'Building SSH Key'
  zs2 = 'Patience . . .'
  do forever
    call pfshow 'off'           /* make sure pfshow is off */
    'Control Display Lock'
    'Addpop row(4) column(12)'
    'Display Panel(zigipop)'
    'Rempop'
    call pfshow 'reset'         /* restore pfshow setting */
    call catsshk
    if zigissh /= null then leave
  end
  return

  /* ----------------------- *
  | Generalized Pop Message |
  * ----------------------- */
Pop:
  parse arg zs1,zs2
  add = address()
  Address ISPExec
  call pfshow 'off'           /* make sure pfshow is off */
  'Control Display Lock'
  'addpop row(4) column(4)'
  'display panel(zigipop)'
  'rempop'
  call pfshow 'reset'         /* restore pfshow setting */
  Address add
  return

  /* ------------------------------ *
  | Cat the current ssh key if any |
  * ------------------------------ */
catsshk:
  drop so. se.
  cmd = 'cat' keyfile
  x = bpxwunix(cmd,,so.,se.)
  if se.0 = 0
  then do
    zigissh = so.1
    'vput (zigissh) profile'
  end
  else zigissh = null
  return


  /* -------------------------- *
  | Lowercase the input string |
  * -------------------------- */
Lower:
  parse arg input
  out = translate(input,"abcdefghijklmnopqrstuvwxyz",,
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ")
  return out

Upper:
  parse arg input
  OUT = TRANSLATE(input,"ABCDEFGHIJKLMNOPQRSTUVWXYZ",,
    "abcdefghijklmnopqrstuvwxyz")
  return out

  /* -------------------------- *
  | Prefix the git commands    |
  * -------------------------- */
docmd:
  /* quircky thing, we need to export HOME as we are
  not running a login shell via bpxwunix */
  parse arg cmd
  return 'export HOME='home' && . /etc/profile && bash &&  '  || cmd

dsnvalid: Procedure
  /* Tests for a 'potentially valid' z/OS datasetname */
  parse arg dsn
  upp = TRANSLATE(dsn,".ABCDEFGHIJKLMNOPQRSTUVWXYZ",,
    ".abcdefghijklmnopqrstuvwxyz")
  if upp = dsn then do
    if sysdsn(dsn) = "OK" | sysdsn(dsn) = "DATASET NOT FOUND" then do
      return "OK"
    end
  end
  else do
    return "NO"
  end

strreplace: Procedure
parse arg string strfrom strto
if pos(strfrom,string) = 0 then return string
newString = ''
do i = 1 to length(string)
   if substr(string,i,1) /= strfrom
      then newstring = newstring''substr(string,i,1)
      else  newstring = newstring''strto
   end
return newstring

idle:
  parse arg secs
  if secs = '' | secs = null then secs=1
  cmd = docmd('sleepnd -v git')
  x = bpxwunix(cmd,,so.,se.)
  return

update_repo_metadata:
  if rtbl_open = 1 then do
    'tbend' rtbl
    rtbl_open = 0
  end
  if rtbl_open = 0 then
  'TBCreate' rtbl 'Names(dsnstat dsn pdshlq fulldsn) Replace NoWrite'
  rtbl_open = 1
  /* We always fetch when we start to work on a repo */
  zs1 = 'Fetching Remote info'
  zs2 = 'Patience . . .'
  call pfshow 'off'         /* turn off pfshow setting */
  'Control Display Lock'
  'Addpop row(4) column(12)'
  'Display Panel(zigipop)'
  'Rempop'
  call pfshow 'reset'         /* restore pfshow setting */
  cmd = 'cd' localrep'/'zigirep
  cmd = docmd(cmd || '&& git fetch --all')
  x = bpxwunix(cmd,,so.,se.)
  /* now we get the status for all in the repo */
  if se.0 > 1 then fetchmsg = "Remote updates, consider a pull"
  else fetchmsg = "No remote updates"
  /* get all the files that are in the repo */
  address syscall
  'readdir 'localrep'/'zigirep' root.'
  address ispexec
  do i = 1 to root.0
    if root.i = "." | root.i = ".." then do
      iterate
    end
    else do
      /* not the . and .. things */
      if dsnvalid(root.i) = "OK" then do
        /* and only for valid z/OS-datasets (skip README.md et al) */
        r = usssafe(root.i)
        cmd = '[ -d 'localrep'/'zigirep'/'r' ] && echo "DIR"'
        so.1 = ""
        x = bpxwunix(cmd,,so.,se.)
        if so.1 = "DIR" & x = 0 then do
          /* And only for dirs in the repo (PDSes in z/OS) */
          if pdshlq /= "" then
          /* make sure to add the prefix :) */
          edsn = pdshlq'.'root.i
          else
          edsn = root.i
          /* see if any members not touched by zigi */
          mem = ''
          "LMINIT DATAID(zigilmm) DATASET('"edsn"')"
          "LMOPEN DATAID("zigilmm") OPTION(INPUT)"
          do forever
            "LMMLIST DATAID("zigilmm") OPTION(LIST) MEMBER(MEM)" ,
              "STATS(YES)"
            if rc > 7 then do
              "LMClose Dataid("zigilmm")"
              "LMFree  Dataid("zigilmm")"
              mem = ''
              leave
            end
            if zluser /= "ZIGI" then do
              /* if not touched by zigi, add to repo */
              m = strip(mem)
              m = usssafe(m)
              e = usssafe(edsn)
              r = usssafe(root.i)
              /* TODO? Use Scottish Command here ? */
              copycmd = "//'"e"("m")'"
              copycmd = '"'copycmd'"'
              copycmd = "cp -U -M" copycmd" "localrep"/"zigirep
              copycmd = copycmd || "/"r"/"
              call bpxwunix copycmd
              /* update ispf-statistics to reflect zigi control */
              "LMMSTATS DATAID("zigilmm") MEMBER("mem") USER(ZIGI)"
            end
          end
        end
      end
    end
  end


  zs1 = 'Building List of repository Data Sets'
  zs2 = fetchmsg
  call pfshow 'off'           /* make sure pfshow is off */
  'Control Display Lock'
  'Addpop row(4) column(12)'
  'Display Panel(zigipop)'
  cmd = 'cd' localrep'/'zigirep
  cmd = docmd(cmd || '&& git status --porcelain')
  x = bpxwunix(cmd,,stats.,se.)

  /* get the stuff from the repo-file */
  address syscall
  'readdir 'localrep'/'zigirep' root.'
  address ispexec
  do i = 1 to root.0
    dsnstat = ''
    if root.i = "." | root.i = ".." then do
      iterate
    end
    else do
      if dsnvalid(root.i) = "OK" then do
        dsn = root.i
        do ii = 1 to stats.0
          stat = substr(stats.ii,1,2)
          PATH = substr(stats.ii,4)
          if pos(dsn, PATH) = 1 then do
            dsnstat = porcelain(stat)
            leave
          end
        end

        if pdshlq /= "" then
        fulldsn = "'"pdshlq"."dsn"'"
        else
        fulldsn = "'"dsn"'"

        'tbadd' rtbl
      end
    end
  end
  'tbtop' rtbl
  'Rempop'
  call pfshow 'reset'         /* restore pfshow setting */

  /* --------------------------- *
  | Get the current branch info |
  * --------------------------- */
  localdir = localrep'/'zigirep
  cmd = docmd('cd 'localdir' && git status')
  x = bpxwunix(cmd,,so.,se.)
  branch = word(so.1,3)
  branch_status = word(so.2,4)
  branch_how    = word(so.2,8)
  if branch_status != "up-to-date" then
  bextra = branch_how
  else
  bextra = ''
  /* get the remote info.....but */
  /* we have to get rid of the tab in git output */
  gitcmd = 'git remote -v | sed -e "s/[[:space:]]\+/ /g"'
  cmd = docmd('cd 'localdir' && 'gitcmd)
  x = bpxwunix(cmd,,so.,se.)
  if so.0 > 0 then do
    remote1 = word(so.1,1) || ' ' || word(so.1,2) || ' ' || word(so.1,3)
    remote2 = word(so.2,1) || ' ' || word(so.2,2) || ' ' || word(so.2,3)
  end
  else do
    remote1 = "<no remote defined>"
    remote2 = ""
  end
  trace off
  return

porcelain:
  parse arg status

  /* parse git status --short as documented in
  https://www.git-scm.com/docs/git-status#_short_format */

  Select
  When stat == " M" then res = "ModWhenied"
  When stat == " D" then res = "Deleted"
  When stat == " R" then res = "Renamed"
  When stat == " C" then res = "Copied"
  When stat == "M " then res = "Ready to commit"
  When left(stat,1) == " " then res = "Not Updated"
  When left(stat,1) == "M" then res = "Updated in index"
  When left(stat,1) == "A" then res = "Added to index"
  When left(stat,1) == "D" then res = "Deleted from index"
  When left(stat,1) == "R" then res = "Renamed in index"
  When left(stat,1) == "C" then res = "Copied in index"
  When stat == "??" then res = "Untracked"
  When stat == "MM" then res = "ModWhenied"
  When stat == "AM" then res = "ModWhenied"
  When stat == "RM" then res = "ModWhenied"
  When stat == "CM" then res = "ModWhenied"
  When stat == "MD" then res = "Deleted"
  When stat == "AD" then res = "Deleted"
  When stat == "RD" then res = "Deleted"
  When stat == "CD" then res = "Deleted"
  When stat == "DR" then res = "Renamed"
  When stat == "DC" then res = "Copied"
  When stat == "??" then res = "Untracked"
  When stat == "!!" then res = "Ignored"
  Otherwise res = ''
  end
  return '[' || status || '] ' || res

usssafe: procedure
  parse arg dsn
  dsn = strreplace(dsn  '$'  '\$')
  return dsn

  /* ------------------------------------------------------ *
  | The pfshow routine will:                               |
  | 1. check to see the passed option                      |
  | 2. if Off then it will save the current pfshow setting |
  |    - save the current setting                          |
  |    - turn off pfshow                                   |
  | 3. if the option is Reset then it will                 |
  |    - test if pfshow was on and turn it back on         |
  * ------------------------------------------------------ */
pfshow:
  arg pfkopt
  if pfkopt = 'RESET' then do
    if pfkeys = 'ON' then
    'select pgm(ispopf) parm(FKA,ON)'
  end
  if pfkopt = 'OFF' then do
    'vget (zpfshow)'
    pfkeys = zpfshow
    if pfkeys /= 'OFF' then
    'select pgm(ispopf) parm(FKA,OFF)'
  end
  return
